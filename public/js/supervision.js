/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

eval("/**\n * @license AngularJS v1.6.1\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/**\n * @ngdoc module\n * @name ngCookies\n * @description\n *\n * # ngCookies\n *\n * The `ngCookies` module provides a convenient wrapper for reading and writing browser cookies.\n *\n *\n * <div doc-module-components=\"ngCookies\"></div>\n *\n * See {@link ngCookies.$cookies `$cookies`} for usage.\n */\n\n\nangular.module('ngCookies', ['ng']).\n  /**\n   * @ngdoc provider\n   * @name $cookiesProvider\n   * @description\n   * Use `$cookiesProvider` to change the default behavior of the {@link ngCookies.$cookies $cookies} service.\n   * */\n   provider('$cookies', [/** @this */function $CookiesProvider() {\n    /**\n     * @ngdoc property\n     * @name $cookiesProvider#defaults\n     * @description\n     *\n     * Object containing default options to pass when setting cookies.\n     *\n     * The object may have following properties:\n     *\n     * - **path** - `{string}` - The cookie will be available only for this path and its\n     *   sub-paths. By default, this is the URL that appears in your `<base>` tag.\n     * - **domain** - `{string}` - The cookie will be available only for this domain and\n     *   its sub-domains. For security reasons the user agent will not accept the cookie\n     *   if the current domain is not a sub-domain of this domain or equal to it.\n     * - **expires** - `{string|Date}` - String of the form \"Wdy, DD Mon YYYY HH:MM:SS GMT\"\n     *   or a Date object indicating the exact date/time this cookie will expire.\n     * - **secure** - `{boolean}` - If `true`, then the cookie will only be available through a\n     *   secured connection.\n     *\n     * Note: By default, the address that appears in your `<base>` tag will be used as the path.\n     * This is important so that cookies will be visible for all routes when html5mode is enabled.\n     *\n     * @example\n     *\n     * ```js\n     * angular.module('cookiesProviderExample', ['ngCookies'])\n     *   .config(['$cookiesProvider', function($cookiesProvider) {\n     *     // Setting default options\n     *     $cookiesProvider.defaults.domain = 'foo.com';\n     *     $cookiesProvider.defaults.secure = true;\n     *   }]);\n     * ```\n     **/\n    var defaults = this.defaults = {};\n\n    function calcOptions(options) {\n      return options ? angular.extend({}, defaults, options) : defaults;\n    }\n\n    /**\n     * @ngdoc service\n     * @name $cookies\n     *\n     * @description\n     * Provides read/write access to browser's cookies.\n     *\n     * <div class=\"alert alert-info\">\n     * Up until Angular 1.3, `$cookies` exposed properties that represented the\n     * current browser cookie values. In version 1.4, this behavior has changed, and\n     * `$cookies` now provides a standard api of getters, setters etc.\n     * </div>\n     *\n     * Requires the {@link ngCookies `ngCookies`} module to be installed.\n     *\n     * @example\n     *\n     * ```js\n     * angular.module('cookiesExample', ['ngCookies'])\n     *   .controller('ExampleController', ['$cookies', function($cookies) {\n     *     // Retrieving a cookie\n     *     var favoriteCookie = $cookies.get('myFavorite');\n     *     // Setting a cookie\n     *     $cookies.put('myFavorite', 'oatmeal');\n     *   }]);\n     * ```\n     */\n    this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {\n      return {\n        /**\n         * @ngdoc method\n         * @name $cookies#get\n         *\n         * @description\n         * Returns the value of given cookie key\n         *\n         * @param {string} key Id to use for lookup.\n         * @returns {string} Raw cookie value.\n         */\n        get: function(key) {\n          return $$cookieReader()[key];\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#getObject\n         *\n         * @description\n         * Returns the deserialized value of given cookie key\n         *\n         * @param {string} key Id to use for lookup.\n         * @returns {Object} Deserialized cookie value.\n         */\n        getObject: function(key) {\n          var value = this.get(key);\n          return value ? angular.fromJson(value) : value;\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#getAll\n         *\n         * @description\n         * Returns a key value object with all the cookies\n         *\n         * @returns {Object} All cookies\n         */\n        getAll: function() {\n          return $$cookieReader();\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#put\n         *\n         * @description\n         * Sets a value for given cookie key\n         *\n         * @param {string} key Id for the `value`.\n         * @param {string} value Raw value to be stored.\n         * @param {Object=} options Options object.\n         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n         */\n        put: function(key, value, options) {\n          $$cookieWriter(key, value, calcOptions(options));\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#putObject\n         *\n         * @description\n         * Serializes and sets a value for given cookie key\n         *\n         * @param {string} key Id for the `value`.\n         * @param {Object} value Value to be stored.\n         * @param {Object=} options Options object.\n         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n         */\n        putObject: function(key, value, options) {\n          this.put(key, angular.toJson(value), options);\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#remove\n         *\n         * @description\n         * Remove given cookie\n         *\n         * @param {string} key Id of the key-value pair to delete.\n         * @param {Object=} options Options object.\n         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n         */\n        remove: function(key, options) {\n          $$cookieWriter(key, undefined, calcOptions(options));\n        }\n      };\n    }];\n  }]);\n\nangular.module('ngCookies').\n/**\n * @ngdoc service\n * @name $cookieStore\n * @deprecated\n * sinceVersion=\"v1.4.0\"\n * Please use the {@link ngCookies.$cookies `$cookies`} service instead.\n *\n * @requires $cookies\n *\n * @description\n * Provides a key-value (string-object) storage, that is backed by session cookies.\n * Objects put or retrieved from this storage are automatically serialized or\n * deserialized by angular's toJson/fromJson.\n *\n * Requires the {@link ngCookies `ngCookies`} module to be installed.\n *\n * @example\n *\n * ```js\n * angular.module('cookieStoreExample', ['ngCookies'])\n *   .controller('ExampleController', ['$cookieStore', function($cookieStore) {\n *     // Put cookie\n *     $cookieStore.put('myFavorite','oatmeal');\n *     // Get cookie\n *     var favoriteCookie = $cookieStore.get('myFavorite');\n *     // Removing a cookie\n *     $cookieStore.remove('myFavorite');\n *   }]);\n * ```\n */\n factory('$cookieStore', ['$cookies', function($cookies) {\n\n    return {\n      /**\n       * @ngdoc method\n       * @name $cookieStore#get\n       *\n       * @description\n       * Returns the value of given cookie key\n       *\n       * @param {string} key Id to use for lookup.\n       * @returns {Object} Deserialized cookie value, undefined if the cookie does not exist.\n       */\n      get: function(key) {\n        return $cookies.getObject(key);\n      },\n\n      /**\n       * @ngdoc method\n       * @name $cookieStore#put\n       *\n       * @description\n       * Sets a value for given cookie key\n       *\n       * @param {string} key Id for the `value`.\n       * @param {Object} value Value to be stored.\n       */\n      put: function(key, value) {\n        $cookies.putObject(key, value);\n      },\n\n      /**\n       * @ngdoc method\n       * @name $cookieStore#remove\n       *\n       * @description\n       * Remove given cookie\n       *\n       * @param {string} key Id of the key-value pair to delete.\n       */\n      remove: function(key) {\n        $cookies.remove(key);\n      }\n    };\n\n  }]);\n\n/**\n * @name $$cookieWriter\n * @requires $document\n *\n * @description\n * This is a private service for writing cookies\n *\n * @param {string} name Cookie name\n * @param {string=} value Cookie value (if undefined, cookie will be deleted)\n * @param {Object=} options Object with options that need to be stored for the cookie.\n */\nfunction $$CookieWriter($document, $log, $browser) {\n  var cookiePath = $browser.baseHref();\n  var rawDocument = $document[0];\n\n  function buildCookieString(name, value, options) {\n    var path, expires;\n    options = options || {};\n    expires = options.expires;\n    path = angular.isDefined(options.path) ? options.path : cookiePath;\n    if (angular.isUndefined(value)) {\n      expires = 'Thu, 01 Jan 1970 00:00:00 GMT';\n      value = '';\n    }\n    if (angular.isString(expires)) {\n      expires = new Date(expires);\n    }\n\n    var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n    str += path ? ';path=' + path : '';\n    str += options.domain ? ';domain=' + options.domain : '';\n    str += expires ? ';expires=' + expires.toUTCString() : '';\n    str += options.secure ? ';secure' : '';\n\n    // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n    // - 300 cookies\n    // - 20 cookies per unique domain\n    // - 4096 bytes per cookie\n    var cookieLength = str.length + 1;\n    if (cookieLength > 4096) {\n      $log.warn('Cookie \\'' + name +\n        '\\' possibly not set or overflowed because it was too large (' +\n        cookieLength + ' > 4096 bytes)!');\n    }\n\n    return str;\n  }\n\n  return function(name, value, options) {\n    rawDocument.cookie = buildCookieString(name, value, options);\n  };\n}\n\n$$CookieWriter.$inject = ['$document', '$log', '$browser'];\n\nangular.module('ngCookies').provider('$$cookieWriter', /** @this */ function $$CookieWriterProvider() {\n  this.$get = $$CookieWriter;\n});\n\n\n})(window, window.angular);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vYW5ndWxhci1jb29raWVzL2FuZ3VsYXItY29va2llcy5qcz80YjljIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhckpTIHYxLjYuMVxuICogKGMpIDIwMTAtMjAxNiBHb29nbGUsIEluYy4gaHR0cDovL2FuZ3VsYXJqcy5vcmdcbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7J3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuZ2RvYyBtb2R1bGVcbiAqIEBuYW1lIG5nQ29va2llc1xuICogQGRlc2NyaXB0aW9uXG4gKlxuICogIyBuZ0Nvb2tpZXNcbiAqXG4gKiBUaGUgYG5nQ29va2llc2AgbW9kdWxlIHByb3ZpZGVzIGEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGJyb3dzZXIgY29va2llcy5cbiAqXG4gKlxuICogPGRpdiBkb2MtbW9kdWxlLWNvbXBvbmVudHM9XCJuZ0Nvb2tpZXNcIj48L2Rpdj5cbiAqXG4gKiBTZWUge0BsaW5rIG5nQ29va2llcy4kY29va2llcyBgJGNvb2tpZXNgfSBmb3IgdXNhZ2UuXG4gKi9cblxuXG5hbmd1bGFyLm1vZHVsZSgnbmdDb29raWVzJywgWyduZyddKS5cbiAgLyoqXG4gICAqIEBuZ2RvYyBwcm92aWRlclxuICAgKiBAbmFtZSAkY29va2llc1Byb3ZpZGVyXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBVc2UgYCRjb29raWVzUHJvdmlkZXJgIHRvIGNoYW5nZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUge0BsaW5rIG5nQ29va2llcy4kY29va2llcyAkY29va2llc30gc2VydmljZS5cbiAgICogKi9cbiAgIHByb3ZpZGVyKCckY29va2llcycsIFsvKiogQHRoaXMgKi9mdW5jdGlvbiAkQ29va2llc1Byb3ZpZGVyKCkge1xuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBwcm9wZXJ0eVxuICAgICAqIEBuYW1lICRjb29raWVzUHJvdmlkZXIjZGVmYXVsdHNcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIE9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgb3B0aW9ucyB0byBwYXNzIHdoZW4gc2V0dGluZyBjb29raWVzLlxuICAgICAqXG4gICAgICogVGhlIG9iamVjdCBtYXkgaGF2ZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKlxuICAgICAqIC0gKipwYXRoKiogLSBge3N0cmluZ31gIC0gVGhlIGNvb2tpZSB3aWxsIGJlIGF2YWlsYWJsZSBvbmx5IGZvciB0aGlzIHBhdGggYW5kIGl0c1xuICAgICAqICAgc3ViLXBhdGhzLiBCeSBkZWZhdWx0LCB0aGlzIGlzIHRoZSBVUkwgdGhhdCBhcHBlYXJzIGluIHlvdXIgYDxiYXNlPmAgdGFnLlxuICAgICAqIC0gKipkb21haW4qKiAtIGB7c3RyaW5nfWAgLSBUaGUgY29va2llIHdpbGwgYmUgYXZhaWxhYmxlIG9ubHkgZm9yIHRoaXMgZG9tYWluIGFuZFxuICAgICAqICAgaXRzIHN1Yi1kb21haW5zLiBGb3Igc2VjdXJpdHkgcmVhc29ucyB0aGUgdXNlciBhZ2VudCB3aWxsIG5vdCBhY2NlcHQgdGhlIGNvb2tpZVxuICAgICAqICAgaWYgdGhlIGN1cnJlbnQgZG9tYWluIGlzIG5vdCBhIHN1Yi1kb21haW4gb2YgdGhpcyBkb21haW4gb3IgZXF1YWwgdG8gaXQuXG4gICAgICogLSAqKmV4cGlyZXMqKiAtIGB7c3RyaW5nfERhdGV9YCAtIFN0cmluZyBvZiB0aGUgZm9ybSBcIldkeSwgREQgTW9uIFlZWVkgSEg6TU06U1MgR01UXCJcbiAgICAgKiAgIG9yIGEgRGF0ZSBvYmplY3QgaW5kaWNhdGluZyB0aGUgZXhhY3QgZGF0ZS90aW1lIHRoaXMgY29va2llIHdpbGwgZXhwaXJlLlxuICAgICAqIC0gKipzZWN1cmUqKiAtIGB7Ym9vbGVhbn1gIC0gSWYgYHRydWVgLCB0aGVuIHRoZSBjb29raWUgd2lsbCBvbmx5IGJlIGF2YWlsYWJsZSB0aHJvdWdoIGFcbiAgICAgKiAgIHNlY3VyZWQgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIE5vdGU6IEJ5IGRlZmF1bHQsIHRoZSBhZGRyZXNzIHRoYXQgYXBwZWFycyBpbiB5b3VyIGA8YmFzZT5gIHRhZyB3aWxsIGJlIHVzZWQgYXMgdGhlIHBhdGguXG4gICAgICogVGhpcyBpcyBpbXBvcnRhbnQgc28gdGhhdCBjb29raWVzIHdpbGwgYmUgdmlzaWJsZSBmb3IgYWxsIHJvdXRlcyB3aGVuIGh0bWw1bW9kZSBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogYW5ndWxhci5tb2R1bGUoJ2Nvb2tpZXNQcm92aWRlckV4YW1wbGUnLCBbJ25nQ29va2llcyddKVxuICAgICAqICAgLmNvbmZpZyhbJyRjb29raWVzUHJvdmlkZXInLCBmdW5jdGlvbigkY29va2llc1Byb3ZpZGVyKSB7XG4gICAgICogICAgIC8vIFNldHRpbmcgZGVmYXVsdCBvcHRpb25zXG4gICAgICogICAgICRjb29raWVzUHJvdmlkZXIuZGVmYXVsdHMuZG9tYWluID0gJ2Zvby5jb20nO1xuICAgICAqICAgICAkY29va2llc1Byb3ZpZGVyLmRlZmF1bHRzLnNlY3VyZSA9IHRydWU7XG4gICAgICogICB9XSk7XG4gICAgICogYGBgXG4gICAgICoqL1xuICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuZGVmYXVsdHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGNhbGNPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zID8gYW5ndWxhci5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKSA6IGRlZmF1bHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBzZXJ2aWNlXG4gICAgICogQG5hbWUgJGNvb2tpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFByb3ZpZGVzIHJlYWQvd3JpdGUgYWNjZXNzIHRvIGJyb3dzZXIncyBjb29raWVzLlxuICAgICAqXG4gICAgICogPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LWluZm9cIj5cbiAgICAgKiBVcCB1bnRpbCBBbmd1bGFyIDEuMywgYCRjb29raWVzYCBleHBvc2VkIHByb3BlcnRpZXMgdGhhdCByZXByZXNlbnRlZCB0aGVcbiAgICAgKiBjdXJyZW50IGJyb3dzZXIgY29va2llIHZhbHVlcy4gSW4gdmVyc2lvbiAxLjQsIHRoaXMgYmVoYXZpb3IgaGFzIGNoYW5nZWQsIGFuZFxuICAgICAqIGAkY29va2llc2Agbm93IHByb3ZpZGVzIGEgc3RhbmRhcmQgYXBpIG9mIGdldHRlcnMsIHNldHRlcnMgZXRjLlxuICAgICAqIDwvZGl2PlxuICAgICAqXG4gICAgICogUmVxdWlyZXMgdGhlIHtAbGluayBuZ0Nvb2tpZXMgYG5nQ29va2llc2B9IG1vZHVsZSB0byBiZSBpbnN0YWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBhbmd1bGFyLm1vZHVsZSgnY29va2llc0V4YW1wbGUnLCBbJ25nQ29va2llcyddKVxuICAgICAqICAgLmNvbnRyb2xsZXIoJ0V4YW1wbGVDb250cm9sbGVyJywgWyckY29va2llcycsIGZ1bmN0aW9uKCRjb29raWVzKSB7XG4gICAgICogICAgIC8vIFJldHJpZXZpbmcgYSBjb29raWVcbiAgICAgKiAgICAgdmFyIGZhdm9yaXRlQ29va2llID0gJGNvb2tpZXMuZ2V0KCdteUZhdm9yaXRlJyk7XG4gICAgICogICAgIC8vIFNldHRpbmcgYSBjb29raWVcbiAgICAgKiAgICAgJGNvb2tpZXMucHV0KCdteUZhdm9yaXRlJywgJ29hdG1lYWwnKTtcbiAgICAgKiAgIH1dKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aGlzLiRnZXQgPSBbJyQkY29va2llUmVhZGVyJywgJyQkY29va2llV3JpdGVyJywgZnVuY3Rpb24oJCRjb29raWVSZWFkZXIsICQkY29va2llV3JpdGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkY29va2llcyNnZXRcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGdpdmVuIGNvb2tpZSBrZXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBJZCB0byB1c2UgZm9yIGxvb2t1cC5cbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gUmF3IGNvb2tpZSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuICQkY29va2llUmVhZGVyKClba2V5XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkY29va2llcyNnZXRPYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRlc2VyaWFsaXplZCB2YWx1ZSBvZiBnaXZlbiBjb29raWUga2V5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgSWQgdG8gdXNlIGZvciBsb29rdXAuXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IERlc2VyaWFsaXplZCBjb29raWUgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRPYmplY3Q6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID8gYW5ndWxhci5mcm9tSnNvbih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSAkY29va2llcyNnZXRBbGxcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFJldHVybnMgYSBrZXkgdmFsdWUgb2JqZWN0IHdpdGggYWxsIHRoZSBjb29raWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEFsbCBjb29raWVzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAkJGNvb2tpZVJlYWRlcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRjb29raWVzI3B1dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogU2V0cyBhIHZhbHVlIGZvciBnaXZlbiBjb29raWUga2V5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgSWQgZm9yIHRoZSBgdmFsdWVgLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgUmF3IHZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAgKiAgICBTZWUge0BsaW5rIG5nQ29va2llcy4kY29va2llc1Byb3ZpZGVyI2RlZmF1bHRzICRjb29raWVzUHJvdmlkZXIuZGVmYXVsdHN9XG4gICAgICAgICAqL1xuICAgICAgICBwdXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAkJGNvb2tpZVdyaXRlcihrZXksIHZhbHVlLCBjYWxjT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgJGNvb2tpZXMjcHV0T2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBTZXJpYWxpemVzIGFuZCBzZXRzIGEgdmFsdWUgZm9yIGdpdmVuIGNvb2tpZSBrZXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBJZCBmb3IgdGhlIGB2YWx1ZWAuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBiZSBzdG9yZWQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC5cbiAgICAgICAgICogICAgU2VlIHtAbGluayBuZ0Nvb2tpZXMuJGNvb2tpZXNQcm92aWRlciNkZWZhdWx0cyAkY29va2llc1Byb3ZpZGVyLmRlZmF1bHRzfVxuICAgICAgICAgKi9cbiAgICAgICAgcHV0T2JqZWN0OiBmdW5jdGlvbihrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgdGhpcy5wdXQoa2V5LCBhbmd1bGFyLnRvSnNvbih2YWx1ZSksIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAqIEBuYW1lICRjb29raWVzI3JlbW92ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogUmVtb3ZlIGdpdmVuIGNvb2tpZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IElkIG9mIHRoZSBrZXktdmFsdWUgcGFpciB0byBkZWxldGUuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC5cbiAgICAgICAgICogICAgU2VlIHtAbGluayBuZ0Nvb2tpZXMuJGNvb2tpZXNQcm92aWRlciNkZWZhdWx0cyAkY29va2llc1Byb3ZpZGVyLmRlZmF1bHRzfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgICAkJGNvb2tpZVdyaXRlcihrZXksIHVuZGVmaW5lZCwgY2FsY09wdGlvbnMob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1dO1xuICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCduZ0Nvb2tpZXMnKS5cbi8qKlxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRjb29raWVTdG9yZVxuICogQGRlcHJlY2F0ZWRcbiAqIHNpbmNlVmVyc2lvbj1cInYxLjQuMFwiXG4gKiBQbGVhc2UgdXNlIHRoZSB7QGxpbmsgbmdDb29raWVzLiRjb29raWVzIGAkY29va2llc2B9IHNlcnZpY2UgaW5zdGVhZC5cbiAqXG4gKiBAcmVxdWlyZXMgJGNvb2tpZXNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVzIGEga2V5LXZhbHVlIChzdHJpbmctb2JqZWN0KSBzdG9yYWdlLCB0aGF0IGlzIGJhY2tlZCBieSBzZXNzaW9uIGNvb2tpZXMuXG4gKiBPYmplY3RzIHB1dCBvciByZXRyaWV2ZWQgZnJvbSB0aGlzIHN0b3JhZ2UgYXJlIGF1dG9tYXRpY2FsbHkgc2VyaWFsaXplZCBvclxuICogZGVzZXJpYWxpemVkIGJ5IGFuZ3VsYXIncyB0b0pzb24vZnJvbUpzb24uXG4gKlxuICogUmVxdWlyZXMgdGhlIHtAbGluayBuZ0Nvb2tpZXMgYG5nQ29va2llc2B9IG1vZHVsZSB0byBiZSBpbnN0YWxsZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogYW5ndWxhci5tb2R1bGUoJ2Nvb2tpZVN0b3JlRXhhbXBsZScsIFsnbmdDb29raWVzJ10pXG4gKiAgIC5jb250cm9sbGVyKCdFeGFtcGxlQ29udHJvbGxlcicsIFsnJGNvb2tpZVN0b3JlJywgZnVuY3Rpb24oJGNvb2tpZVN0b3JlKSB7XG4gKiAgICAgLy8gUHV0IGNvb2tpZVxuICogICAgICRjb29raWVTdG9yZS5wdXQoJ215RmF2b3JpdGUnLCdvYXRtZWFsJyk7XG4gKiAgICAgLy8gR2V0IGNvb2tpZVxuICogICAgIHZhciBmYXZvcml0ZUNvb2tpZSA9ICRjb29raWVTdG9yZS5nZXQoJ215RmF2b3JpdGUnKTtcbiAqICAgICAvLyBSZW1vdmluZyBhIGNvb2tpZVxuICogICAgICRjb29raWVTdG9yZS5yZW1vdmUoJ215RmF2b3JpdGUnKTtcbiAqICAgfV0pO1xuICogYGBgXG4gKi9cbiBmYWN0b3J5KCckY29va2llU3RvcmUnLCBbJyRjb29raWVzJywgZnVuY3Rpb24oJGNvb2tpZXMpIHtcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAqIEBuYW1lICRjb29raWVTdG9yZSNnZXRcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGdpdmVuIGNvb2tpZSBrZXlcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IElkIHRvIHVzZSBmb3IgbG9va3VwLlxuICAgICAgICogQHJldHVybnMge09iamVjdH0gRGVzZXJpYWxpemVkIGNvb2tpZSB2YWx1ZSwgdW5kZWZpbmVkIGlmIHRoZSBjb29raWUgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAkY29va2llcy5nZXRPYmplY3Qoa2V5KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICogQG5hbWUgJGNvb2tpZVN0b3JlI3B1dFxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogU2V0cyBhIHZhbHVlIGZvciBnaXZlbiBjb29raWUga2V5XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBJZCBmb3IgdGhlIGB2YWx1ZWAuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVmFsdWUgdG8gYmUgc3RvcmVkLlxuICAgICAgICovXG4gICAgICBwdXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgJGNvb2tpZXMucHV0T2JqZWN0KGtleSwgdmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgKiBAbmFtZSAkY29va2llU3RvcmUjcmVtb3ZlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZW1vdmUgZ2l2ZW4gY29va2llXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBJZCBvZiB0aGUga2V5LXZhbHVlIHBhaXIgdG8gZGVsZXRlLlxuICAgICAgICovXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAkY29va2llcy5yZW1vdmUoa2V5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH1dKTtcblxuLyoqXG4gKiBAbmFtZSAkJGNvb2tpZVdyaXRlclxuICogQHJlcXVpcmVzICRkb2N1bWVudFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBpcyBhIHByaXZhdGUgc2VydmljZSBmb3Igd3JpdGluZyBjb29raWVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ29va2llIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdmFsdWUgQ29va2llIHZhbHVlIChpZiB1bmRlZmluZWQsIGNvb2tpZSB3aWxsIGJlIGRlbGV0ZWQpXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT2JqZWN0IHdpdGggb3B0aW9ucyB0aGF0IG5lZWQgdG8gYmUgc3RvcmVkIGZvciB0aGUgY29va2llLlxuICovXG5mdW5jdGlvbiAkJENvb2tpZVdyaXRlcigkZG9jdW1lbnQsICRsb2csICRicm93c2VyKSB7XG4gIHZhciBjb29raWVQYXRoID0gJGJyb3dzZXIuYmFzZUhyZWYoKTtcbiAgdmFyIHJhd0RvY3VtZW50ID0gJGRvY3VtZW50WzBdO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkQ29va2llU3RyaW5nKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhdGgsIGV4cGlyZXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgZXhwaXJlcyA9IG9wdGlvbnMuZXhwaXJlcztcbiAgICBwYXRoID0gYW5ndWxhci5pc0RlZmluZWQob3B0aW9ucy5wYXRoKSA/IG9wdGlvbnMucGF0aCA6IGNvb2tpZVBhdGg7XG4gICAgaWYgKGFuZ3VsYXIuaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICBleHBpcmVzID0gJ1RodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UJztcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKGV4cGlyZXMpKSB7XG4gICAgICBleHBpcmVzID0gbmV3IERhdGUoZXhwaXJlcyk7XG4gICAgfVxuXG4gICAgdmFyIHN0ciA9IGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgc3RyICs9IHBhdGggPyAnO3BhdGg9JyArIHBhdGggOiAnJztcbiAgICBzdHIgKz0gb3B0aW9ucy5kb21haW4gPyAnO2RvbWFpbj0nICsgb3B0aW9ucy5kb21haW4gOiAnJztcbiAgICBzdHIgKz0gZXhwaXJlcyA/ICc7ZXhwaXJlcz0nICsgZXhwaXJlcy50b1VUQ1N0cmluZygpIDogJyc7XG4gICAgc3RyICs9IG9wdGlvbnMuc2VjdXJlID8gJztzZWN1cmUnIDogJyc7XG5cbiAgICAvLyBwZXIgaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjEwOS50eHQgYnJvd3NlciBtdXN0IGFsbG93IGF0IG1pbmltdW06XG4gICAgLy8gLSAzMDAgY29va2llc1xuICAgIC8vIC0gMjAgY29va2llcyBwZXIgdW5pcXVlIGRvbWFpblxuICAgIC8vIC0gNDA5NiBieXRlcyBwZXIgY29va2llXG4gICAgdmFyIGNvb2tpZUxlbmd0aCA9IHN0ci5sZW5ndGggKyAxO1xuICAgIGlmIChjb29raWVMZW5ndGggPiA0MDk2KSB7XG4gICAgICAkbG9nLndhcm4oJ0Nvb2tpZSBcXCcnICsgbmFtZSArXG4gICAgICAgICdcXCcgcG9zc2libHkgbm90IHNldCBvciBvdmVyZmxvd2VkIGJlY2F1c2UgaXQgd2FzIHRvbyBsYXJnZSAoJyArXG4gICAgICAgIGNvb2tpZUxlbmd0aCArICcgPiA0MDk2IGJ5dGVzKSEnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmF3RG9jdW1lbnQuY29va2llID0gYnVpbGRDb29raWVTdHJpbmcobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICB9O1xufVxuXG4kJENvb2tpZVdyaXRlci4kaW5qZWN0ID0gWyckZG9jdW1lbnQnLCAnJGxvZycsICckYnJvd3NlciddO1xuXG5hbmd1bGFyLm1vZHVsZSgnbmdDb29raWVzJykucHJvdmlkZXIoJyQkY29va2llV3JpdGVyJywgLyoqIEB0aGlzICovIGZ1bmN0aW9uICQkQ29va2llV3JpdGVyUHJvdmlkZXIoKSB7XG4gIHRoaXMuJGdldCA9ICQkQ29va2llV3JpdGVyO1xufSk7XG5cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhci1jb29raWVzL2FuZ3VsYXItY29va2llcy5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

eval("/**\n * @license AngularJS v1.6.2\n * (c) 2010-2017 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\nvar bind;\nvar extend;\nvar forEach;\nvar isDefined;\nvar lowercase;\nvar noop;\nvar htmlParser;\nvar htmlSanitizeWriter;\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   Sanitizes an html string by stripping all potentially dangerous tokens.\n *\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string.\n *\n *   The whitelist for URL sanitization of attribute values is configured using the functions\n *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider\n *   `$compileProvider`}.\n *\n *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\" name=\"sanitize-service\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\n\n\n/**\n * @ngdoc provider\n * @name $sanitizeProvider\n * @this\n *\n * @description\n * Creates and configures {@link $sanitize} instance.\n */\nfunction $SanitizeProvider() {\n  var svgEnabled = false;\n\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    if (svgEnabled) {\n      extend(validElements, svgElements);\n    }\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n\n\n  /**\n   * @ngdoc method\n   * @name $sanitizeProvider#enableSvg\n   * @kind function\n   *\n   * @description\n   * Enables a subset of svg to be supported by the sanitizer.\n   *\n   * <div class=\"alert alert-warning\">\n   *   <p>By enabling this setting without taking other precautions, you might expose your\n   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned\n   *   outside of the containing element and be rendered over other elements on the page (e.g. a login\n   *   link). Such behavior can then result in phishing incidents.</p>\n   *\n   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg\n   *   tags within the sanitized content:</p>\n   *\n   *   <br>\n   *\n   *   <pre><code>\n   *   .rootOfTheIncludedContent svg {\n   *     overflow: hidden !important;\n   *   }\n   *   </code></pre>\n   * </div>\n   *\n   * @param {boolean=} flag Enable or disable SVG support in the sanitizer.\n   * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called\n   *    without an argument or self for chaining otherwise.\n   */\n  this.enableSvg = function(enableSvg) {\n    if (isDefined(enableSvg)) {\n      svgEnabled = enableSvg;\n      return this;\n    } else {\n      return svgEnabled;\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // Private stuff\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n\n  bind = angular.bind;\n  extend = angular.extend;\n  forEach = angular.forEach;\n  isDefined = angular.isDefined;\n  lowercase = angular.lowercase;\n  noop = angular.noop;\n\n  htmlParser = htmlParserImpl;\n  htmlSanitizeWriter = htmlSanitizeWriterImpl;\n\n  // Regular Expressions for parsing tags and attributes\n  var SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n    // Match everything outside of normal chars and \" (quote character)\n    NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g;\n\n\n  // Good source of info about elements and attributes\n  // http://dev.w3.org/html5/spec/Overview.html#semantics\n  // http://simon.html5.org/html-elements\n\n  // Safe Void Elements - HTML5\n  // http://dev.w3.org/html5/spec/Overview.html#void-elements\n  var voidElements = toMap('area,br,col,hr,img,wbr');\n\n  // Elements that you can, intentionally, leave open (and which close themselves)\n  // http://dev.w3.org/html5/spec/Overview.html#optional-tags\n  var optionalEndTagBlockElements = toMap('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'),\n      optionalEndTagInlineElements = toMap('rp,rt'),\n      optionalEndTagElements = extend({},\n                                              optionalEndTagInlineElements,\n                                              optionalEndTagBlockElements);\n\n  // Safe Block Elements - HTML5\n  var blockElements = extend({}, optionalEndTagBlockElements, toMap('address,article,' +\n          'aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n          'h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul'));\n\n  // Inline Elements - HTML5\n  var inlineElements = extend({}, optionalEndTagInlineElements, toMap('a,abbr,acronym,b,' +\n          'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,' +\n          'samp,small,span,strike,strong,sub,sup,time,tt,u,var'));\n\n  // SVG Elements\n  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n  // Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n  // They can potentially allow for arbitrary javascript to be executed. See #11290\n  var svgElements = toMap('circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,' +\n          'hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,' +\n          'radialGradient,rect,stop,svg,switch,text,title,tspan');\n\n  // Blocked Elements (will be stripped)\n  var blockedElements = toMap('script,style');\n\n  var validElements = extend({},\n                                     voidElements,\n                                     blockElements,\n                                     inlineElements,\n                                     optionalEndTagElements);\n\n  //Attributes that have href and hence need to be sanitized\n  var uriAttrs = toMap('background,cite,href,longdesc,src,xlink:href');\n\n  var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n      'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n      'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n      'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n      'valign,value,vspace,width');\n\n  // SVG attributes (without \"id\" and \"name\" attributes)\n  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\n  var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n      'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n      'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n      'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n      'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n      'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n      'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n      'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n      'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n      'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n      'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n      'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n      'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n      'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n      'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\n  var validAttrs = extend({},\n                                  uriAttrs,\n                                  svgAttrs,\n                                  htmlAttrs);\n\n  function toMap(str, lowercaseKeys) {\n    var obj = {}, items = str.split(','), i;\n    for (i = 0; i < items.length; i++) {\n      obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;\n    }\n    return obj;\n  }\n\n  var inertBodyElement;\n  (function(window) {\n    var doc;\n    if (window.document && window.document.implementation) {\n      doc = window.document.implementation.createHTMLDocument('inert');\n    } else {\n      throw $sanitizeMinErr('noinert', 'Can\\'t create an inert html document');\n    }\n    var docElement = doc.documentElement || doc.getDocumentElement();\n    var bodyElements = docElement.getElementsByTagName('body');\n\n    // usually there should be only one body element in the document, but IE doesn't have any, so we need to create one\n    if (bodyElements.length === 1) {\n      inertBodyElement = bodyElements[0];\n    } else {\n      var html = doc.createElement('html');\n      inertBodyElement = doc.createElement('body');\n      html.appendChild(inertBodyElement);\n      doc.appendChild(html);\n    }\n  })(window);\n\n  /**\n   * @example\n   * htmlParser(htmlString, {\n   *     start: function(tag, attrs) {},\n   *     end: function(tag) {},\n   *     chars: function(text) {},\n   *     comment: function(text) {}\n   * });\n   *\n   * @param {string} html string\n   * @param {object} handler\n   */\n  function htmlParserImpl(html, handler) {\n    if (html === null || html === undefined) {\n      html = '';\n    } else if (typeof html !== 'string') {\n      html = '' + html;\n    }\n    inertBodyElement.innerHTML = html;\n\n    //mXSS protection\n    var mXSSAttempts = 5;\n    do {\n      if (mXSSAttempts === 0) {\n        throw $sanitizeMinErr('uinput', 'Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n\n      // strip custom-namespaced attributes on IE<=11\n      if (window.document.documentMode) {\n        stripCustomNsAttrs(inertBodyElement);\n      }\n      html = inertBodyElement.innerHTML; //trigger mXSS\n      inertBodyElement.innerHTML = html;\n    } while (html !== inertBodyElement.innerHTML);\n\n    var node = inertBodyElement.firstChild;\n    while (node) {\n      switch (node.nodeType) {\n        case 1: // ELEMENT_NODE\n          handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));\n          break;\n        case 3: // TEXT NODE\n          handler.chars(node.textContent);\n          break;\n      }\n\n      var nextNode;\n      if (!(nextNode = node.firstChild)) {\n        if (node.nodeType === 1) {\n          handler.end(node.nodeName.toLowerCase());\n        }\n        nextNode = node.nextSibling;\n        if (!nextNode) {\n          while (nextNode == null) {\n            node = node.parentNode;\n            if (node === inertBodyElement) break;\n            nextNode = node.nextSibling;\n            if (node.nodeType === 1) {\n              handler.end(node.nodeName.toLowerCase());\n            }\n          }\n        }\n      }\n      node = nextNode;\n    }\n\n    while ((node = inertBodyElement.firstChild)) {\n      inertBodyElement.removeChild(node);\n    }\n  }\n\n  function attrToMap(attrs) {\n    var map = {};\n    for (var i = 0, ii = attrs.length; i < ii; i++) {\n      var attr = attrs[i];\n      map[attr.name] = attr.value;\n    }\n    return map;\n  }\n\n\n  /**\n   * Escapes all potentially dangerous characters, so that the\n   * resulting string can be safely inserted into attribute or\n   * element text.\n   * @param value\n   * @returns {string} escaped text\n   */\n  function encodeEntities(value) {\n    return value.\n      replace(/&/g, '&amp;').\n      replace(SURROGATE_PAIR_REGEXP, function(value) {\n        var hi = value.charCodeAt(0);\n        var low = value.charCodeAt(1);\n        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n      }).\n      replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n        return '&#' + value.charCodeAt(0) + ';';\n      }).\n      replace(/</g, '&lt;').\n      replace(/>/g, '&gt;');\n  }\n\n  /**\n   * create an HTML/XML writer which writes to buffer\n   * @param {Array} buf use buf.join('') to get out sanitized html string\n   * @returns {object} in the form of {\n   *     start: function(tag, attrs) {},\n   *     end: function(tag) {},\n   *     chars: function(text) {},\n   *     comment: function(text) {}\n   * }\n   */\n  function htmlSanitizeWriterImpl(buf, uriValidator) {\n    var ignoreCurrentElement = false;\n    var out = bind(buf, buf.push);\n    return {\n      start: function(tag, attrs) {\n        tag = lowercase(tag);\n        if (!ignoreCurrentElement && blockedElements[tag]) {\n          ignoreCurrentElement = tag;\n        }\n        if (!ignoreCurrentElement && validElements[tag] === true) {\n          out('<');\n          out(tag);\n          forEach(attrs, function(value, key) {\n            var lkey = lowercase(key);\n            var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n            if (validAttrs[lkey] === true &&\n              (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n              out(' ');\n              out(key);\n              out('=\"');\n              out(encodeEntities(value));\n              out('\"');\n            }\n          });\n          out('>');\n        }\n      },\n      end: function(tag) {\n        tag = lowercase(tag);\n        if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        // eslint-disable-next-line eqeqeq\n        if (tag == ignoreCurrentElement) {\n          ignoreCurrentElement = false;\n        }\n      },\n      chars: function(chars) {\n        if (!ignoreCurrentElement) {\n          out(encodeEntities(chars));\n        }\n      }\n    };\n  }\n\n\n  /**\n   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare\n   * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want\n   * to allow any of these custom attributes. This method strips them all.\n   *\n   * @param node Root element to process\n   */\n  function stripCustomNsAttrs(node) {\n    while (node) {\n      if (node.nodeType === window.Node.ELEMENT_NODE) {\n        var attrs = node.attributes;\n        for (var i = 0, l = attrs.length; i < l; i++) {\n          var attrNode = attrs[i];\n          var attrName = attrNode.name.toLowerCase();\n          if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {\n            node.removeAttributeNode(attrNode);\n            i--;\n            l--;\n          }\n        }\n      }\n\n      var nextNode = node.firstChild;\n      if (nextNode) {\n        stripCustomNsAttrs(nextNode);\n      }\n\n      node = node.nextSibling;\n    }\n  }\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.\n * @param {object|function(url)} [attributes] Add custom attributes to the link element.\n *\n *    Can be one of:\n *\n *    - `object`: A map of attributes\n *    - `function`: Takes the url as a parameter and returns a map of attributes\n *\n *    If the map of attributes contains a value for `target`, it overrides the value of\n *    the target parameter.\n *\n *\n * @returns {string} Html-linkified and {@link $sanitize sanitized} text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\" name=\"linky-filter\">\n     <file name=\"index.html\">\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <th>Filter</th>\n           <th>Source</th>\n           <th>Rendered</th>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"linky-custom-attributes\">\n          <td>linky custom attributes</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"script.js\">\n       angular.module('linkyExample', ['ngSanitize'])\n         .controller('ExampleController', ['$scope', function($scope) {\n           $scope.snippet =\n             'Pretty text with some links:\\n' +\n             'http://angularjs.org/,\\n' +\n             'mailto:us@somewhere.org,\\n' +\n             'another@somewhere.org,\\n' +\n             'and one more: ftp://127.0.0.1/.';\n           $scope.snippetWithSingleURL = 'http://angularjs.org/';\n         }]);\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithSingleURL | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n\n       it('should optionally add custom attributes', function() {\n        expect(element(by.id('linky-custom-attributes')).\n            element(by.binding(\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  var linkyMinErr = angular.$$minErr('linky');\n  var isDefined = angular.isDefined;\n  var isFunction = angular.isFunction;\n  var isObject = angular.isObject;\n  var isString = angular.isString;\n\n  return function(text, target, attributes) {\n    if (text == null || text === '') return text;\n    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);\n\n    var attributesFn =\n      isFunction(attributes) ? attributes :\n      isObject(attributes) ? function getAttributesObject() {return attributes;} :\n      function getEmptyAttributesObject() {return {};};\n\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      var key, linkAttributes = attributesFn(url);\n      html.push('<a ');\n\n      for (key in linkAttributes) {\n        html.push(key + '=\"' + linkAttributes[key] + '\" ');\n      }\n\n      if (isDefined(target) && !('target' in linkAttributes)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vYW5ndWxhci1zYW5pdGl6ZS9hbmd1bGFyLXNhbml0aXplLmpzP2ViOTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFySlMgdjEuNi4yXG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwOi8vYW5ndWxhcmpzLm9yZ1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHsndXNlIHN0cmljdCc7XG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICBBbnkgY29tbWl0cyB0byB0aGlzIGZpbGUgc2hvdWxkIGJlIHJldmlld2VkIHdpdGggc2VjdXJpdHkgaW4gbWluZC4gICpcbiAqICAgQ2hhbmdlcyB0byB0aGlzIGZpbGUgY2FuIHBvdGVudGlhbGx5IGNyZWF0ZSBzZWN1cml0eSB2dWxuZXJhYmlsaXRpZXMuICpcbiAqICAgICAgICAgIEFuIGFwcHJvdmFsIGZyb20gMiBDb3JlIG1lbWJlcnMgd2l0aCBoaXN0b3J5IG9mIG1vZGlmeWluZyAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgZmlsZSBpcyByZXF1aXJlZC4gICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICBEb2VzIHRoZSBjaGFuZ2Ugc29tZWhvdyBhbGxvdyBmb3IgYXJiaXRyYXJ5IGphdmFzY3JpcHQgdG8gYmUgZXhlY3V0ZWQ/ICpcbiAqICAgIE9yIGFsbG93cyBmb3Igc29tZW9uZSB0byBjaGFuZ2UgdGhlIHByb3RvdHlwZSBvZiBidWlsdC1pbiBvYmplY3RzPyAgICpcbiAqICAgICBPciBnaXZlcyB1bmRlc2lyZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyBsaWtlcyBkb2N1bWVudCBvciB3aW5kb3c/ICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbnZhciAkc2FuaXRpemVNaW5FcnIgPSBhbmd1bGFyLiQkbWluRXJyKCckc2FuaXRpemUnKTtcbnZhciBiaW5kO1xudmFyIGV4dGVuZDtcbnZhciBmb3JFYWNoO1xudmFyIGlzRGVmaW5lZDtcbnZhciBsb3dlcmNhc2U7XG52YXIgbm9vcDtcbnZhciBodG1sUGFyc2VyO1xudmFyIGh0bWxTYW5pdGl6ZVdyaXRlcjtcblxuLyoqXG4gKiBAbmdkb2MgbW9kdWxlXG4gKiBAbmFtZSBuZ1Nhbml0aXplXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiAjIG5nU2FuaXRpemVcbiAqXG4gKiBUaGUgYG5nU2FuaXRpemVgIG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHNhbml0aXplIEhUTUwuXG4gKlxuICpcbiAqIDxkaXYgZG9jLW1vZHVsZS1jb21wb25lbnRzPVwibmdTYW5pdGl6ZVwiPjwvZGl2PlxuICpcbiAqIFNlZSB7QGxpbmsgbmdTYW5pdGl6ZS4kc2FuaXRpemUgYCRzYW5pdGl6ZWB9IGZvciB1c2FnZS5cbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkc2FuaXRpemVcbiAqIEBraW5kIGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFNhbml0aXplcyBhbiBodG1sIHN0cmluZyBieSBzdHJpcHBpbmcgYWxsIHBvdGVudGlhbGx5IGRhbmdlcm91cyB0b2tlbnMuXG4gKlxuICogICBUaGUgaW5wdXQgaXMgc2FuaXRpemVkIGJ5IHBhcnNpbmcgdGhlIEhUTUwgaW50byB0b2tlbnMuIEFsbCBzYWZlIHRva2VucyAoZnJvbSBhIHdoaXRlbGlzdCkgYXJlXG4gKiAgIHRoZW4gc2VyaWFsaXplZCBiYWNrIHRvIHByb3Blcmx5IGVzY2FwZWQgaHRtbCBzdHJpbmcuIFRoaXMgbWVhbnMgdGhhdCBubyB1bnNhZmUgaW5wdXQgY2FuIG1ha2VcbiAqICAgaXQgaW50byB0aGUgcmV0dXJuZWQgc3RyaW5nLlxuICpcbiAqICAgVGhlIHdoaXRlbGlzdCBmb3IgVVJMIHNhbml0aXphdGlvbiBvZiBhdHRyaWJ1dGUgdmFsdWVzIGlzIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIGZ1bmN0aW9uc1xuICogICBgYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3RgIGFuZCBgaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0YCBvZiB7QGxpbmsgbmcuJGNvbXBpbGVQcm92aWRlclxuICogICBgJGNvbXBpbGVQcm92aWRlcmB9LlxuICpcbiAqICAgVGhlIGlucHV0IG1heSBhbHNvIGNvbnRhaW4gU1ZHIG1hcmt1cCBpZiB0aGlzIGlzIGVuYWJsZWQgdmlhIHtAbGluayAkc2FuaXRpemVQcm92aWRlcn0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgSFRNTCBpbnB1dC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFNhbml0aXplZCBIVE1MLlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZXhhbXBsZSBtb2R1bGU9XCJzYW5pdGl6ZUV4YW1wbGVcIiBkZXBzPVwiYW5ndWxhci1zYW5pdGl6ZS5qc1wiIG5hbWU9XCJzYW5pdGl6ZS1zZXJ2aWNlXCI+XG4gICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICA8c2NyaXB0PlxuICAgICAgICAgYW5ndWxhci5tb2R1bGUoJ3Nhbml0aXplRXhhbXBsZScsIFsnbmdTYW5pdGl6ZSddKVxuICAgICAgICAgICAuY29udHJvbGxlcignRXhhbXBsZUNvbnRyb2xsZXInLCBbJyRzY29wZScsICckc2NlJywgZnVuY3Rpb24oJHNjb3BlLCAkc2NlKSB7XG4gICAgICAgICAgICAgJHNjb3BlLnNuaXBwZXQgPVxuICAgICAgICAgICAgICAgJzxwIHN0eWxlPVwiY29sb3I6Ymx1ZVwiPmFuIGh0bWxcXG4nICtcbiAgICAgICAgICAgICAgICc8ZW0gb25tb3VzZW92ZXI9XCJ0aGlzLnRleHRDb250ZW50PVxcJ1BXTjNEIVxcJ1wiPmNsaWNrIGhlcmU8L2VtPlxcbicgK1xuICAgICAgICAgICAgICAgJ3NuaXBwZXQ8L3A+JztcbiAgICAgICAgICAgICAkc2NvcGUuZGVsaWJlcmF0ZWx5VHJ1c3REYW5nZXJvdXNTbmlwcGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzSHRtbCgkc2NvcGUuc25pcHBldCk7XG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgfV0pO1xuICAgICA8L3NjcmlwdD5cbiAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiRXhhbXBsZUNvbnRyb2xsZXJcIj5cbiAgICAgICAgU25pcHBldDogPHRleHRhcmVhIG5nLW1vZGVsPVwic25pcHBldFwiIGNvbHM9XCI2MFwiIHJvd3M9XCIzXCI+PC90ZXh0YXJlYT5cbiAgICAgICA8dGFibGU+XG4gICAgICAgICA8dHI+XG4gICAgICAgICAgIDx0ZD5EaXJlY3RpdmU8L3RkPlxuICAgICAgICAgICA8dGQ+SG93PC90ZD5cbiAgICAgICAgICAgPHRkPlNvdXJjZTwvdGQ+XG4gICAgICAgICAgIDx0ZD5SZW5kZXJlZDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwiYmluZC1odG1sLXdpdGgtc2FuaXRpemVcIj5cbiAgICAgICAgICAgPHRkPm5nLWJpbmQtaHRtbDwvdGQ+XG4gICAgICAgICAgIDx0ZD5BdXRvbWF0aWNhbGx5IHVzZXMgJHNhbml0aXplPC90ZD5cbiAgICAgICAgICAgPHRkPjxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0XCImZ3Q7PGJyLz4mbHQ7L2RpdiZndDs8L3ByZT48L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0XCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJiaW5kLWh0bWwtd2l0aC10cnVzdFwiPlxuICAgICAgICAgICA8dGQ+bmctYmluZC1odG1sPC90ZD5cbiAgICAgICAgICAgPHRkPkJ5cGFzcyAkc2FuaXRpemUgYnkgZXhwbGljaXRseSB0cnVzdGluZyB0aGUgZGFuZ2Vyb3VzIHZhbHVlPC90ZD5cbiAgICAgICAgICAgPHRkPlxuICAgICAgICAgICA8cHJlPiZsdDtkaXYgbmctYmluZC1odG1sPVwiZGVsaWJlcmF0ZWx5VHJ1c3REYW5nZXJvdXNTbmlwcGV0KClcIiZndDtcbiZsdDsvZGl2Jmd0OzwvcHJlPlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kLWh0bWw9XCJkZWxpYmVyYXRlbHlUcnVzdERhbmdlcm91c1NuaXBwZXQoKVwiPjwvZGl2PjwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwiYmluZC1kZWZhdWx0XCI+XG4gICAgICAgICAgIDx0ZD5uZy1iaW5kPC90ZD5cbiAgICAgICAgICAgPHRkPkF1dG9tYXRpY2FsbHkgZXNjYXBlczwvdGQ+XG4gICAgICAgICAgIDx0ZD48cHJlPiZsdDtkaXYgbmctYmluZD1cInNuaXBwZXRcIiZndDs8YnIvPiZsdDsvZGl2Jmd0OzwvcHJlPjwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQ9XCJzbmlwcGV0XCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgPC90YWJsZT5cbiAgICAgICA8L2Rpdj5cbiAgIDwvZmlsZT5cbiAgIDxmaWxlIG5hbWU9XCJwcm90cmFjdG9yLmpzXCIgdHlwZT1cInByb3RyYWN0b3JcIj5cbiAgICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSB0aGUgaHRtbCBzbmlwcGV0IGJ5IGRlZmF1bHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC1zYW5pdGl6ZSBkaXYnKSkuZ2V0QXR0cmlidXRlKCdpbm5lckhUTUwnKSkuXG4gICAgICAgICB0b0JlKCc8cD5hbiBodG1sXFxuPGVtPmNsaWNrIGhlcmU8L2VtPlxcbnNuaXBwZXQ8L3A+Jyk7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgaW5saW5lIHJhdyBzbmlwcGV0IGlmIGJvdW5kIHRvIGEgdHJ1c3RlZCB2YWx1ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXRydXN0IGRpdicpKS5nZXRBdHRyaWJ1dGUoJ2lubmVySFRNTCcpKS5cbiAgICAgICAgIHRvQmUoXCI8cCBzdHlsZT1cXFwiY29sb3I6Ymx1ZVxcXCI+YW4gaHRtbFxcblwiICtcbiAgICAgICAgICAgICAgXCI8ZW0gb25tb3VzZW92ZXI9XFxcInRoaXMudGV4dENvbnRlbnQ9J1BXTjNEISdcXFwiPmNsaWNrIGhlcmU8L2VtPlxcblwiICtcbiAgICAgICAgICAgICAgXCJzbmlwcGV0PC9wPlwiKTtcbiAgICAgfSk7XG5cbiAgICAgaXQoJ3Nob3VsZCBlc2NhcGUgc25pcHBldCB3aXRob3V0IGFueSBmaWx0ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWRlZmF1bHQgZGl2JykpLmdldEF0dHJpYnV0ZSgnaW5uZXJIVE1MJykpLlxuICAgICAgICAgdG9CZShcIiZsdDtwIHN0eWxlPVxcXCJjb2xvcjpibHVlXFxcIiZndDthbiBodG1sXFxuXCIgK1xuICAgICAgICAgICAgICBcIiZsdDtlbSBvbm1vdXNlb3Zlcj1cXFwidGhpcy50ZXh0Q29udGVudD0nUFdOM0QhJ1xcXCImZ3Q7Y2xpY2sgaGVyZSZsdDsvZW0mZ3Q7XFxuXCIgK1xuICAgICAgICAgICAgICBcInNuaXBwZXQmbHQ7L3AmZ3Q7XCIpO1xuICAgICB9KTtcblxuICAgICBpdCgnc2hvdWxkIHVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuY2xlYXIoKTtcbiAgICAgICBlbGVtZW50KGJ5Lm1vZGVsKCdzbmlwcGV0JykpLnNlbmRLZXlzKCduZXcgPGIgb25jbGljaz1cImFsZXJ0KDEpXCI+dGV4dDwvYj4nKTtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC1zYW5pdGl6ZSBkaXYnKSkuZ2V0QXR0cmlidXRlKCdpbm5lckhUTUwnKSkuXG4gICAgICAgICB0b0JlKCduZXcgPGI+dGV4dDwvYj4nKTtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC10cnVzdCBkaXYnKSkuZ2V0QXR0cmlidXRlKCdpbm5lckhUTUwnKSkudG9CZShcbiAgICAgICAgICduZXcgPGIgb25jbGljaz1cImFsZXJ0KDEpXCI+dGV4dDwvYj4nKTtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWRlZmF1bHQgZGl2JykpLmdldEF0dHJpYnV0ZSgnaW5uZXJIVE1MJykpLnRvQmUoXG4gICAgICAgICBcIm5ldyAmbHQ7YiBvbmNsaWNrPVxcXCJhbGVydCgxKVxcXCImZ3Q7dGV4dCZsdDsvYiZndDtcIik7XG4gICAgIH0pO1xuICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2MgcHJvdmlkZXJcbiAqIEBuYW1lICRzYW5pdGl6ZVByb3ZpZGVyXG4gKiBAdGhpc1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhbmQgY29uZmlndXJlcyB7QGxpbmsgJHNhbml0aXplfSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gJFNhbml0aXplUHJvdmlkZXIoKSB7XG4gIHZhciBzdmdFbmFibGVkID0gZmFsc2U7XG5cbiAgdGhpcy4kZ2V0ID0gWyckJHNhbml0aXplVXJpJywgZnVuY3Rpb24oJCRzYW5pdGl6ZVVyaSkge1xuICAgIGlmIChzdmdFbmFibGVkKSB7XG4gICAgICBleHRlbmQodmFsaWRFbGVtZW50cywgc3ZnRWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oaHRtbCkge1xuICAgICAgdmFyIGJ1ZiA9IFtdO1xuICAgICAgaHRtbFBhcnNlcihodG1sLCBodG1sU2FuaXRpemVXcml0ZXIoYnVmLCBmdW5jdGlvbih1cmksIGlzSW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuICEvXnVuc2FmZTovLnRlc3QoJCRzYW5pdGl6ZVVyaSh1cmksIGlzSW1hZ2UpKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBidWYuam9pbignJyk7XG4gICAgfTtcbiAgfV07XG5cblxuICAvKipcbiAgICogQG5nZG9jIG1ldGhvZFxuICAgKiBAbmFtZSAkc2FuaXRpemVQcm92aWRlciNlbmFibGVTdmdcbiAgICogQGtpbmQgZnVuY3Rpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEVuYWJsZXMgYSBzdWJzZXQgb2Ygc3ZnIHRvIGJlIHN1cHBvcnRlZCBieSB0aGUgc2FuaXRpemVyLlxuICAgKlxuICAgKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtd2FybmluZ1wiPlxuICAgKiAgIDxwPkJ5IGVuYWJsaW5nIHRoaXMgc2V0dGluZyB3aXRob3V0IHRha2luZyBvdGhlciBwcmVjYXV0aW9ucywgeW91IG1pZ2h0IGV4cG9zZSB5b3VyXG4gICAqICAgYXBwbGljYXRpb24gdG8gY2xpY2staGlqYWNraW5nIGF0dGFja3MuIEluIHRoZXNlIGF0dGFja3MsIHNhbml0aXplZCBzdmcgZWxlbWVudHMgY291bGQgYmUgcG9zaXRpb25lZFxuICAgKiAgIG91dHNpZGUgb2YgdGhlIGNvbnRhaW5pbmcgZWxlbWVudCBhbmQgYmUgcmVuZGVyZWQgb3ZlciBvdGhlciBlbGVtZW50cyBvbiB0aGUgcGFnZSAoZS5nLiBhIGxvZ2luXG4gICAqICAgbGluaykuIFN1Y2ggYmVoYXZpb3IgY2FuIHRoZW4gcmVzdWx0IGluIHBoaXNoaW5nIGluY2lkZW50cy48L3A+XG4gICAqXG4gICAqICAgPHA+VG8gcHJvdGVjdCBhZ2FpbnN0IHRoZXNlLCBleHBsaWNpdGx5IHNldHVwIGBvdmVyZmxvdzogaGlkZGVuYCBjc3MgcnVsZSBmb3IgYWxsIHBvdGVudGlhbCBzdmdcbiAgICogICB0YWdzIHdpdGhpbiB0aGUgc2FuaXRpemVkIGNvbnRlbnQ6PC9wPlxuICAgKlxuICAgKiAgIDxicj5cbiAgICpcbiAgICogICA8cHJlPjxjb2RlPlxuICAgKiAgIC5yb290T2ZUaGVJbmNsdWRlZENvbnRlbnQgc3ZnIHtcbiAgICogICAgIG92ZXJmbG93OiBoaWRkZW4gIWltcG9ydGFudDtcbiAgICogICB9XG4gICAqICAgPC9jb2RlPjwvcHJlPlxuICAgKiA8L2Rpdj5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZmxhZyBFbmFibGUgb3IgZGlzYWJsZSBTVkcgc3VwcG9ydCBpbiB0aGUgc2FuaXRpemVyLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxuZy4kc2FuaXRpemVQcm92aWRlcn0gUmV0dXJucyB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgdmFsdWUgaWYgY2FsbGVkXG4gICAqICAgIHdpdGhvdXQgYW4gYXJndW1lbnQgb3Igc2VsZiBmb3IgY2hhaW5pbmcgb3RoZXJ3aXNlLlxuICAgKi9cbiAgdGhpcy5lbmFibGVTdmcgPSBmdW5jdGlvbihlbmFibGVTdmcpIHtcbiAgICBpZiAoaXNEZWZpbmVkKGVuYWJsZVN2ZykpIHtcbiAgICAgIHN2Z0VuYWJsZWQgPSBlbmFibGVTdmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN2Z0VuYWJsZWQ7XG4gICAgfVxuICB9O1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFByaXZhdGUgc3R1ZmZcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBiaW5kID0gYW5ndWxhci5iaW5kO1xuICBleHRlbmQgPSBhbmd1bGFyLmV4dGVuZDtcbiAgZm9yRWFjaCA9IGFuZ3VsYXIuZm9yRWFjaDtcbiAgaXNEZWZpbmVkID0gYW5ndWxhci5pc0RlZmluZWQ7XG4gIGxvd2VyY2FzZSA9IGFuZ3VsYXIubG93ZXJjYXNlO1xuICBub29wID0gYW5ndWxhci5ub29wO1xuXG4gIGh0bWxQYXJzZXIgPSBodG1sUGFyc2VySW1wbDtcbiAgaHRtbFNhbml0aXplV3JpdGVyID0gaHRtbFNhbml0aXplV3JpdGVySW1wbDtcblxuICAvLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbiAgdmFyIFNVUlJPR0FURV9QQUlSX1JFR0VYUCA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csXG4gICAgLy8gTWF0Y2ggZXZlcnl0aGluZyBvdXRzaWRlIG9mIG5vcm1hbCBjaGFycyBhbmQgXCIgKHF1b3RlIGNoYXJhY3RlcilcbiAgICBOT05fQUxQSEFOVU1FUklDX1JFR0VYUCA9IC8oW14jLX4gfCFdKS9nO1xuXG5cbiAgLy8gR29vZCBzb3VyY2Ugb2YgaW5mbyBhYm91dCBlbGVtZW50cyBhbmQgYXR0cmlidXRlc1xuICAvLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjc2VtYW50aWNzXG4gIC8vIGh0dHA6Ly9zaW1vbi5odG1sNS5vcmcvaHRtbC1lbGVtZW50c1xuXG4gIC8vIFNhZmUgVm9pZCBFbGVtZW50cyAtIEhUTUw1XG4gIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCN2b2lkLWVsZW1lbnRzXG4gIHZhciB2b2lkRWxlbWVudHMgPSB0b01hcCgnYXJlYSxicixjb2wsaHIsaW1nLHdicicpO1xuXG4gIC8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlbiAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG4gIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCNvcHRpb25hbC10YWdzXG4gIHZhciBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMgPSB0b01hcCgnY29sZ3JvdXAsZGQsZHQsbGkscCx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCx0cicpLFxuICAgICAgb3B0aW9uYWxFbmRUYWdJbmxpbmVFbGVtZW50cyA9IHRvTWFwKCdycCxydCcpLFxuICAgICAgb3B0aW9uYWxFbmRUYWdFbGVtZW50cyA9IGV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbEVuZFRhZ0lubGluZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsRW5kVGFnQmxvY2tFbGVtZW50cyk7XG5cbiAgLy8gU2FmZSBCbG9jayBFbGVtZW50cyAtIEhUTUw1XG4gIHZhciBibG9ja0VsZW1lbnRzID0gZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMsIHRvTWFwKCdhZGRyZXNzLGFydGljbGUsJyArXG4gICAgICAgICAgJ2FzaWRlLGJsb2NrcXVvdGUsY2FwdGlvbixjZW50ZXIsZGVsLGRpcixkaXYsZGwsZmlndXJlLGZpZ2NhcHRpb24sZm9vdGVyLGgxLGgyLGgzLGg0LGg1LCcgK1xuICAgICAgICAgICdoNixoZWFkZXIsaGdyb3VwLGhyLGlucyxtYXAsbWVudSxuYXYsb2wscHJlLHNlY3Rpb24sdGFibGUsdWwnKSk7XG5cbiAgLy8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTDVcbiAgdmFyIGlubGluZUVsZW1lbnRzID0gZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0lubGluZUVsZW1lbnRzLCB0b01hcCgnYSxhYmJyLGFjcm9ueW0sYiwnICtcbiAgICAgICAgICAnYmRpLGJkbyxiaWcsYnIsY2l0ZSxjb2RlLGRlbCxkZm4sZW0sZm9udCxpLGltZyxpbnMsa2JkLGxhYmVsLG1hcCxtYXJrLHEscnVieSxycCxydCxzLCcgK1xuICAgICAgICAgICdzYW1wLHNtYWxsLHNwYW4sc3RyaWtlLHN0cm9uZyxzdWIsc3VwLHRpbWUsdHQsdSx2YXInKSk7XG5cbiAgLy8gU1ZHIEVsZW1lbnRzXG4gIC8vIGh0dHBzOi8vd2lraS53aGF0d2cub3JnL3dpa2kvU2FuaXRpemF0aW9uX3J1bGVzI3N2Z19FbGVtZW50c1xuICAvLyBOb3RlOiB0aGUgZWxlbWVudHMgYW5pbWF0ZSxhbmltYXRlQ29sb3IsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLHNldCBhcmUgaW50ZW50aW9uYWxseSBvbWl0dGVkLlxuICAvLyBUaGV5IGNhbiBwb3RlbnRpYWxseSBhbGxvdyBmb3IgYXJiaXRyYXJ5IGphdmFzY3JpcHQgdG8gYmUgZXhlY3V0ZWQuIFNlZSAjMTEyOTBcbiAgdmFyIHN2Z0VsZW1lbnRzID0gdG9NYXAoJ2NpcmNsZSxkZWZzLGRlc2MsZWxsaXBzZSxmb250LWZhY2UsZm9udC1mYWNlLW5hbWUsZm9udC1mYWNlLXNyYyxnLGdseXBoLCcgK1xuICAgICAgICAgICdoa2VybixpbWFnZSxsaW5lYXJHcmFkaWVudCxsaW5lLG1hcmtlcixtZXRhZGF0YSxtaXNzaW5nLWdseXBoLG1wYXRoLHBhdGgscG9seWdvbixwb2x5bGluZSwnICtcbiAgICAgICAgICAncmFkaWFsR3JhZGllbnQscmVjdCxzdG9wLHN2Zyxzd2l0Y2gsdGV4dCx0aXRsZSx0c3BhbicpO1xuXG4gIC8vIEJsb2NrZWQgRWxlbWVudHMgKHdpbGwgYmUgc3RyaXBwZWQpXG4gIHZhciBibG9ja2VkRWxlbWVudHMgPSB0b01hcCgnc2NyaXB0LHN0eWxlJyk7XG5cbiAgdmFyIHZhbGlkRWxlbWVudHMgPSBleHRlbmQoe30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZEVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5saW5lRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdFbGVtZW50cyk7XG5cbiAgLy9BdHRyaWJ1dGVzIHRoYXQgaGF2ZSBocmVmIGFuZCBoZW5jZSBuZWVkIHRvIGJlIHNhbml0aXplZFxuICB2YXIgdXJpQXR0cnMgPSB0b01hcCgnYmFja2dyb3VuZCxjaXRlLGhyZWYsbG9uZ2Rlc2Msc3JjLHhsaW5rOmhyZWYnKTtcblxuICB2YXIgaHRtbEF0dHJzID0gdG9NYXAoJ2FiYnIsYWxpZ24sYWx0LGF4aXMsYmdjb2xvcixib3JkZXIsY2VsbHBhZGRpbmcsY2VsbHNwYWNpbmcsY2xhc3MsY2xlYXIsJyArXG4gICAgICAnY29sb3IsY29scyxjb2xzcGFuLGNvbXBhY3QsY29vcmRzLGRpcixmYWNlLGhlYWRlcnMsaGVpZ2h0LGhyZWZsYW5nLGhzcGFjZSwnICtcbiAgICAgICdpc21hcCxsYW5nLGxhbmd1YWdlLG5vaHJlZixub3dyYXAscmVsLHJldixyb3dzLHJvd3NwYW4scnVsZXMsJyArXG4gICAgICAnc2NvcGUsc2Nyb2xsaW5nLHNoYXBlLHNpemUsc3BhbixzdGFydCxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0eXBlLCcgK1xuICAgICAgJ3ZhbGlnbix2YWx1ZSx2c3BhY2Usd2lkdGgnKTtcblxuICAvLyBTVkcgYXR0cmlidXRlcyAod2l0aG91dCBcImlkXCIgYW5kIFwibmFtZVwiIGF0dHJpYnV0ZXMpXG4gIC8vIGh0dHBzOi8vd2lraS53aGF0d2cub3JnL3dpa2kvU2FuaXRpemF0aW9uX3J1bGVzI3N2Z19BdHRyaWJ1dGVzXG4gIHZhciBzdmdBdHRycyA9IHRvTWFwKCdhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxwaGFiZXRpYyxhcmFiaWMtZm9ybSxhc2NlbnQsJyArXG4gICAgICAnYmFzZVByb2ZpbGUsYmJveCxiZWdpbixieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNvbG9yLGNvbG9yLXJlbmRlcmluZyxjb250ZW50LCcgK1xuICAgICAgJ2N4LGN5LGQsZHgsZHksZGVzY2VudCxkaXNwbGF5LGR1cixlbmQsZmlsbCxmaWxsLXJ1bGUsZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc3RyZXRjaCwnICtcbiAgICAgICdmb250LXN0eWxlLGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmcm9tLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ3JhZGllbnRVbml0cyxoYW5naW5nLCcgK1xuICAgICAgJ2hlaWdodCxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZGVvZ3JhcGhpYyxrLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsJyArXG4gICAgICAnbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWF0aGVtYXRpY2FsLCcgK1xuICAgICAgJ21heCxtaW4sb2Zmc2V0LG9wYWNpdHksb3JpZW50LG9yaWdpbixvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEsJyArXG4gICAgICAncGF0aCxwYXRoTGVuZ3RoLHBvaW50cyxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHIscmVmWCxyZWZZLHJlcGVhdENvdW50LHJlcGVhdER1ciwnICtcbiAgICAgICdyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxyZXN0YXJ0LHJvdGF0ZSxyeCxyeSxzbG9wZSxzdGVtaCxzdGVtdixzdG9wLWNvbG9yLCcgK1xuICAgICAgJ3N0b3Atb3BhY2l0eSxzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LCcgK1xuICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSwnICtcbiAgICAgICdzdHJva2Utd2lkdGgsc3lzdGVtTGFuZ3VhZ2UsdGFyZ2V0LHRleHQtYW5jaG9yLHRvLHRyYW5zZm9ybSx0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbiwnICtcbiAgICAgICd1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdmFsdWVzLHZlcnNpb24sdmlld0JveCx2aXNpYmlsaXR5LCcgK1xuICAgICAgJ3dpZHRoLHdpZHRocyx4LHgtaGVpZ2h0LHgxLHgyLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSx4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUsJyArXG4gICAgICAneGxpbms6dHlwZSx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseG1sbnMseG1sbnM6eGxpbmsseSx5MSx5Mix6b29tQW5kUGFuJywgdHJ1ZSk7XG5cbiAgdmFyIHZhbGlkQXR0cnMgPSBleHRlbmQoe30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEF0dHJzKTtcblxuICBmdW5jdGlvbiB0b01hcChzdHIsIGxvd2VyY2FzZUtleXMpIHtcbiAgICB2YXIgb2JqID0ge30sIGl0ZW1zID0gc3RyLnNwbGl0KCcsJyksIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmpbbG93ZXJjYXNlS2V5cyA/IGxvd2VyY2FzZShpdGVtc1tpXSkgOiBpdGVtc1tpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIGluZXJ0Qm9keUVsZW1lbnQ7XG4gIChmdW5jdGlvbih3aW5kb3cpIHtcbiAgICB2YXIgZG9jO1xuICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmltcGxlbWVudGF0aW9uKSB7XG4gICAgICBkb2MgPSB3aW5kb3cuZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCdpbmVydCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAkc2FuaXRpemVNaW5FcnIoJ25vaW5lcnQnLCAnQ2FuXFwndCBjcmVhdGUgYW4gaW5lcnQgaHRtbCBkb2N1bWVudCcpO1xuICAgIH1cbiAgICB2YXIgZG9jRWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQgfHwgZG9jLmdldERvY3VtZW50RWxlbWVudCgpO1xuICAgIHZhciBib2R5RWxlbWVudHMgPSBkb2NFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5Jyk7XG5cbiAgICAvLyB1c3VhbGx5IHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBib2R5IGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50LCBidXQgSUUgZG9lc24ndCBoYXZlIGFueSwgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgaWYgKGJvZHlFbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGluZXJ0Qm9keUVsZW1lbnQgPSBib2R5RWxlbWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBodG1sID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICAgIGluZXJ0Qm9keUVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudCgnYm9keScpO1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChpbmVydEJvZHlFbGVtZW50KTtcbiAgICAgIGRvYy5hcHBlbmRDaGlsZChodG1sKTtcbiAgICB9XG4gIH0pKHdpbmRvdyk7XG5cbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIGh0bWxQYXJzZXIoaHRtbFN0cmluZywge1xuICAgKiAgICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgYXR0cnMpIHt9LFxuICAgKiAgICAgZW5kOiBmdW5jdGlvbih0YWcpIHt9LFxuICAgKiAgICAgY2hhcnM6IGZ1bmN0aW9uKHRleHQpIHt9LFxuICAgKiAgICAgY29tbWVudDogZnVuY3Rpb24odGV4dCkge31cbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIHN0cmluZ1xuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gaHRtbFBhcnNlckltcGwoaHRtbCwgaGFuZGxlcikge1xuICAgIGlmIChodG1sID09PSBudWxsIHx8IGh0bWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaHRtbCA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGh0bWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICBodG1sID0gJycgKyBodG1sO1xuICAgIH1cbiAgICBpbmVydEJvZHlFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAvL21YU1MgcHJvdGVjdGlvblxuICAgIHZhciBtWFNTQXR0ZW1wdHMgPSA1O1xuICAgIGRvIHtcbiAgICAgIGlmIChtWFNTQXR0ZW1wdHMgPT09IDApIHtcbiAgICAgICAgdGhyb3cgJHNhbml0aXplTWluRXJyKCd1aW5wdXQnLCAnRmFpbGVkIHRvIHNhbml0aXplIGh0bWwgYmVjYXVzZSB0aGUgaW5wdXQgaXMgdW5zdGFibGUnKTtcbiAgICAgIH1cbiAgICAgIG1YU1NBdHRlbXB0cy0tO1xuXG4gICAgICAvLyBzdHJpcCBjdXN0b20tbmFtZXNwYWNlZCBhdHRyaWJ1dGVzIG9uIElFPD0xMVxuICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudE1vZGUpIHtcbiAgICAgICAgc3RyaXBDdXN0b21Oc0F0dHJzKGluZXJ0Qm9keUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaHRtbCA9IGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MOyAvL3RyaWdnZXIgbVhTU1xuICAgICAgaW5lcnRCb2R5RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0gd2hpbGUgKGh0bWwgIT09IGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MKTtcblxuICAgIHZhciBub2RlID0gaW5lcnRCb2R5RWxlbWVudC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSAxOiAvLyBFTEVNRU5UX05PREVcbiAgICAgICAgICBoYW5kbGVyLnN0YXJ0KG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgYXR0clRvTWFwKG5vZGUuYXR0cmlidXRlcykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6IC8vIFRFWFQgTk9ERVxuICAgICAgICAgIGhhbmRsZXIuY2hhcnMobm9kZS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0Tm9kZTtcbiAgICAgIGlmICghKG5leHROb2RlID0gbm9kZS5maXJzdENoaWxkKSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIGhhbmRsZXIuZW5kKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIW5leHROb2RlKSB7XG4gICAgICAgICAgd2hpbGUgKG5leHROb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gaW5lcnRCb2R5RWxlbWVudCkgYnJlYWs7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICBoYW5kbGVyLmVuZChub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSA9IG5leHROb2RlO1xuICAgIH1cblxuICAgIHdoaWxlICgobm9kZSA9IGluZXJ0Qm9keUVsZW1lbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgIGluZXJ0Qm9keUVsZW1lbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0clRvTWFwKGF0dHJzKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGF0dHJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgICBtYXBbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIGFsbCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY2hhcmFjdGVycywgc28gdGhhdCB0aGVcbiAgICogcmVzdWx0aW5nIHN0cmluZyBjYW4gYmUgc2FmZWx5IGluc2VydGVkIGludG8gYXR0cmlidXRlIG9yXG4gICAqIGVsZW1lbnQgdGV4dC5cbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgdGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gZW5jb2RlRW50aXRpZXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuXG4gICAgICByZXBsYWNlKC8mL2csICcmYW1wOycpLlxuICAgICAgcmVwbGFjZShTVVJST0dBVEVfUEFJUl9SRUdFWFAsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBoaSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHZhciBsb3cgPSB2YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgICByZXR1cm4gJyYjJyArICgoKGhpIC0gMHhEODAwKSAqIDB4NDAwKSArIChsb3cgLSAweERDMDApICsgMHgxMDAwMCkgKyAnOyc7XG4gICAgICB9KS5cbiAgICAgIHJlcGxhY2UoTk9OX0FMUEhBTlVNRVJJQ19SRUdFWFAsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnJiMnICsgdmFsdWUuY2hhckNvZGVBdCgwKSArICc7JztcbiAgICAgIH0pLlxuICAgICAgcmVwbGFjZSgvPC9nLCAnJmx0OycpLlxuICAgICAgcmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhbiBIVE1ML1hNTCB3cml0ZXIgd2hpY2ggd3JpdGVzIHRvIGJ1ZmZlclxuICAgKiBAcGFyYW0ge0FycmF5fSBidWYgdXNlIGJ1Zi5qb2luKCcnKSB0byBnZXQgb3V0IHNhbml0aXplZCBodG1sIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBpbiB0aGUgZm9ybSBvZiB7XG4gICAqICAgICBzdGFydDogZnVuY3Rpb24odGFnLCBhdHRycykge30sXG4gICAqICAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge30sXG4gICAqICAgICBjaGFyczogZnVuY3Rpb24odGV4dCkge30sXG4gICAqICAgICBjb21tZW50OiBmdW5jdGlvbih0ZXh0KSB7fVxuICAgKiB9XG4gICAqL1xuICBmdW5jdGlvbiBodG1sU2FuaXRpemVXcml0ZXJJbXBsKGJ1ZiwgdXJpVmFsaWRhdG9yKSB7XG4gICAgdmFyIGlnbm9yZUN1cnJlbnRFbGVtZW50ID0gZmFsc2U7XG4gICAgdmFyIG91dCA9IGJpbmQoYnVmLCBidWYucHVzaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzKSB7XG4gICAgICAgIHRhZyA9IGxvd2VyY2FzZSh0YWcpO1xuICAgICAgICBpZiAoIWlnbm9yZUN1cnJlbnRFbGVtZW50ICYmIGJsb2NrZWRFbGVtZW50c1t0YWddKSB7XG4gICAgICAgICAgaWdub3JlQ3VycmVudEVsZW1lbnQgPSB0YWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpZ25vcmVDdXJyZW50RWxlbWVudCAmJiB2YWxpZEVsZW1lbnRzW3RhZ10gPT09IHRydWUpIHtcbiAgICAgICAgICBvdXQoJzwnKTtcbiAgICAgICAgICBvdXQodGFnKTtcbiAgICAgICAgICBmb3JFYWNoKGF0dHJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgbGtleSA9IGxvd2VyY2FzZShrZXkpO1xuICAgICAgICAgICAgdmFyIGlzSW1hZ2UgPSAodGFnID09PSAnaW1nJyAmJiBsa2V5ID09PSAnc3JjJykgfHwgKGxrZXkgPT09ICdiYWNrZ3JvdW5kJyk7XG4gICAgICAgICAgICBpZiAodmFsaWRBdHRyc1tsa2V5XSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAodXJpQXR0cnNbbGtleV0gIT09IHRydWUgfHwgdXJpVmFsaWRhdG9yKHZhbHVlLCBpc0ltYWdlKSkpIHtcbiAgICAgICAgICAgICAgb3V0KCcgJyk7XG4gICAgICAgICAgICAgIG91dChrZXkpO1xuICAgICAgICAgICAgICBvdXQoJz1cIicpO1xuICAgICAgICAgICAgICBvdXQoZW5jb2RlRW50aXRpZXModmFsdWUpKTtcbiAgICAgICAgICAgICAgb3V0KCdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG91dCgnPicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5kOiBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgdGFnID0gbG93ZXJjYXNlKHRhZyk7XG4gICAgICAgIGlmICghaWdub3JlQ3VycmVudEVsZW1lbnQgJiYgdmFsaWRFbGVtZW50c1t0YWddID09PSB0cnVlICYmIHZvaWRFbGVtZW50c1t0YWddICE9PSB0cnVlKSB7XG4gICAgICAgICAgb3V0KCc8LycpO1xuICAgICAgICAgIG91dCh0YWcpO1xuICAgICAgICAgIG91dCgnPicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgaWYgKHRhZyA9PSBpZ25vcmVDdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIGlnbm9yZUN1cnJlbnRFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjaGFyczogZnVuY3Rpb24oY2hhcnMpIHtcbiAgICAgICAgaWYgKCFpZ25vcmVDdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIG91dChlbmNvZGVFbnRpdGllcyhjaGFycykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdoZW4gSUU5LTExIGNvbWVzIGFjcm9zcyBhbiB1bmtub3duIG5hbWVzcGFjZWQgYXR0cmlidXRlIGUuZy4gJ3hsaW5rOmZvbycgaXQgYWRkcyAneG1sbnM6bnMxJyBhdHRyaWJ1dGUgdG8gZGVjbGFyZVxuICAgKiBuczEgbmFtZXNwYWNlIGFuZCBwcmVmaXhlcyB0aGUgYXR0cmlidXRlIHdpdGggJ25zMScgKGUuZy4gJ25zMTp4bGluazpmb28nKS4gVGhpcyBpcyB1bmRlc2lyYWJsZSBzaW5jZSB3ZSBkb24ndCB3YW50XG4gICAqIHRvIGFsbG93IGFueSBvZiB0aGVzZSBjdXN0b20gYXR0cmlidXRlcy4gVGhpcyBtZXRob2Qgc3RyaXBzIHRoZW0gYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSBSb290IGVsZW1lbnQgdG8gcHJvY2Vzc1xuICAgKi9cbiAgZnVuY3Rpb24gc3RyaXBDdXN0b21Oc0F0dHJzKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IHdpbmRvdy5Ob2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGF0dHJOb2RlID0gYXR0cnNbaV07XG4gICAgICAgICAgdmFyIGF0dHJOYW1lID0gYXR0ck5vZGUubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ3htbG5zOm5zMScgfHwgYXR0ck5hbWUubGFzdEluZGV4T2YoJ25zMTonLCAwKSA9PT0gMCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOb2RlKGF0dHJOb2RlKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGwtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5leHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgIHN0cmlwQ3VzdG9tTnNBdHRycyhuZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVRleHQoY2hhcnMpIHtcbiAgdmFyIGJ1ZiA9IFtdO1xuICB2YXIgd3JpdGVyID0gaHRtbFNhbml0aXplV3JpdGVyKGJ1Ziwgbm9vcCk7XG4gIHdyaXRlci5jaGFycyhjaGFycyk7XG4gIHJldHVybiBidWYuam9pbignJyk7XG59XG5cblxuLy8gZGVmaW5lIG5nU2FuaXRpemUgbW9kdWxlIGFuZCByZWdpc3RlciAkc2FuaXRpemUgc2VydmljZVxuYW5ndWxhci5tb2R1bGUoJ25nU2FuaXRpemUnLCBbXSkucHJvdmlkZXIoJyRzYW5pdGl6ZScsICRTYW5pdGl6ZVByb3ZpZGVyKTtcblxuLyoqXG4gKiBAbmdkb2MgZmlsdGVyXG4gKiBAbmFtZSBsaW5reVxuICogQGtpbmQgZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEZpbmRzIGxpbmtzIGluIHRleHQgaW5wdXQgYW5kIHR1cm5zIHRoZW0gaW50byBodG1sIGxpbmtzLiBTdXBwb3J0cyBgaHR0cC9odHRwcy9mdHAvbWFpbHRvYCBhbmRcbiAqIHBsYWluIGVtYWlsIGFkZHJlc3MgbGlua3MuXG4gKlxuICogUmVxdWlyZXMgdGhlIHtAbGluayBuZ1Nhbml0aXplIGBuZ1Nhbml0aXplYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBJbnB1dCB0ZXh0LlxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBXaW5kb3cgKGBfYmxhbmt8X3NlbGZ8X3BhcmVudHxfdG9wYCkgb3IgbmFtZWQgZnJhbWUgdG8gb3BlbiBsaW5rcyBpbi5cbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9uKHVybCl9IFthdHRyaWJ1dGVzXSBBZGQgY3VzdG9tIGF0dHJpYnV0ZXMgdG8gdGhlIGxpbmsgZWxlbWVudC5cbiAqXG4gKiAgICBDYW4gYmUgb25lIG9mOlxuICpcbiAqICAgIC0gYG9iamVjdGA6IEEgbWFwIG9mIGF0dHJpYnV0ZXNcbiAqICAgIC0gYGZ1bmN0aW9uYDogVGFrZXMgdGhlIHVybCBhcyBhIHBhcmFtZXRlciBhbmQgcmV0dXJucyBhIG1hcCBvZiBhdHRyaWJ1dGVzXG4gKlxuICogICAgSWYgdGhlIG1hcCBvZiBhdHRyaWJ1dGVzIGNvbnRhaW5zIGEgdmFsdWUgZm9yIGB0YXJnZXRgLCBpdCBvdmVycmlkZXMgdGhlIHZhbHVlIG9mXG4gKiAgICB0aGUgdGFyZ2V0IHBhcmFtZXRlci5cbiAqXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gSHRtbC1saW5raWZpZWQgYW5kIHtAbGluayAkc2FuaXRpemUgc2FuaXRpemVkfSB0ZXh0LlxuICpcbiAqIEB1c2FnZVxuICAgPHNwYW4gbmctYmluZC1odG1sPVwibGlua3lfZXhwcmVzc2lvbiB8IGxpbmt5XCI+PC9zcGFuPlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZXhhbXBsZSBtb2R1bGU9XCJsaW5reUV4YW1wbGVcIiBkZXBzPVwiYW5ndWxhci1zYW5pdGl6ZS5qc1wiIG5hbWU9XCJsaW5reS1maWx0ZXJcIj5cbiAgICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJFeGFtcGxlQ29udHJvbGxlclwiPlxuICAgICAgIFNuaXBwZXQ6IDx0ZXh0YXJlYSBuZy1tb2RlbD1cInNuaXBwZXRcIiBjb2xzPVwiNjBcIiByb3dzPVwiM1wiPjwvdGV4dGFyZWE+XG4gICAgICAgPHRhYmxlPlxuICAgICAgICAgPHRyPlxuICAgICAgICAgICA8dGg+RmlsdGVyPC90aD5cbiAgICAgICAgICAgPHRoPlNvdXJjZTwvdGg+XG4gICAgICAgICAgIDx0aD5SZW5kZXJlZDwvdGg+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwibGlua3ktZmlsdGVyXCI+XG4gICAgICAgICAgIDx0ZD5saW5reSBmaWx0ZXI8L3RkPlxuICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgPHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXQgfCBsaW5reVwiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT5cbiAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgIDxkaXYgbmctYmluZC1odG1sPVwic25pcHBldCB8IGxpbmt5XCI+PC9kaXY+XG4gICAgICAgICAgIDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwibGlua3ktdGFyZ2V0XCI+XG4gICAgICAgICAgPHRkPmxpbmt5IHRhcmdldDwvdGQ+XG4gICAgICAgICAgPHRkPlxuICAgICAgICAgICAgPHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRXaXRoU2luZ2xlVVJMIHwgbGlua3k6J19ibGFuaydcIiZndDs8YnI+Jmx0Oy9kaXYmZ3Q7PC9wcmU+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICA8ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRXaXRoU2luZ2xlVVJMIHwgbGlua3k6J19ibGFuaydcIj48L2Rpdj5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImxpbmt5LWN1c3RvbS1hdHRyaWJ1dGVzXCI+XG4gICAgICAgICAgPHRkPmxpbmt5IGN1c3RvbSBhdHRyaWJ1dGVzPC90ZD5cbiAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICA8cHJlPiZsdDtkaXYgbmctYmluZC1odG1sPVwic25pcHBldFdpdGhTaW5nbGVVUkwgfCBsaW5reTonX3NlbGYnOntyZWw6ICdub2ZvbGxvdyd9XCImZ3Q7PGJyPiZsdDsvZGl2Jmd0OzwvcHJlPlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPHRkPlxuICAgICAgICAgICAgPGRpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5Oidfc2VsZic6e3JlbDogJ25vZm9sbG93J31cIj48L2Rpdj5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImVzY2FwZWQtaHRtbFwiPlxuICAgICAgICAgICA8dGQ+bm8gZmlsdGVyPC90ZD5cbiAgICAgICAgICAgPHRkPjxwcmU+Jmx0O2RpdiBuZy1iaW5kPVwic25pcHBldFwiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT48L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kPVwic25pcHBldFwiPjwvZGl2PjwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgIDwvdGFibGU+XG4gICAgIDwvZmlsZT5cbiAgICAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuICAgICAgIGFuZ3VsYXIubW9kdWxlKCdsaW5reUV4YW1wbGUnLCBbJ25nU2FuaXRpemUnXSlcbiAgICAgICAgIC5jb250cm9sbGVyKCdFeGFtcGxlQ29udHJvbGxlcicsIFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICRzY29wZS5zbmlwcGV0ID1cbiAgICAgICAgICAgICAnUHJldHR5IHRleHQgd2l0aCBzb21lIGxpbmtzOlxcbicgK1xuICAgICAgICAgICAgICdodHRwOi8vYW5ndWxhcmpzLm9yZy8sXFxuJyArXG4gICAgICAgICAgICAgJ21haWx0bzp1c0Bzb21ld2hlcmUub3JnLFxcbicgK1xuICAgICAgICAgICAgICdhbm90aGVyQHNvbWV3aGVyZS5vcmcsXFxuJyArXG4gICAgICAgICAgICAgJ2FuZCBvbmUgbW9yZTogZnRwOi8vMTI3LjAuMC4xLy4nO1xuICAgICAgICAgICAkc2NvcGUuc25pcHBldFdpdGhTaW5nbGVVUkwgPSAnaHR0cDovL2FuZ3VsYXJqcy5vcmcvJztcbiAgICAgICAgIH1dKTtcbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwicHJvdHJhY3Rvci5qc1wiIHR5cGU9XCJwcm90cmFjdG9yXCI+XG4gICAgICAgaXQoJ3Nob3VsZCBsaW5raWZ5IHRoZSBzbmlwcGV0IHdpdGggdXJscycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2xpbmt5LWZpbHRlcicpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQgfCBsaW5reScpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgIHRvQmUoJ1ByZXR0eSB0ZXh0IHdpdGggc29tZSBsaW5rczogaHR0cDovL2FuZ3VsYXJqcy5vcmcvLCB1c0Bzb21ld2hlcmUub3JnLCAnICtcbiAgICAgICAgICAgICAgICAgICdhbm90aGVyQHNvbWV3aGVyZS5vcmcsIGFuZCBvbmUgbW9yZTogZnRwOi8vMTI3LjAuMC4xLy4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNsaW5reS1maWx0ZXIgYScpKS5jb3VudCgpKS50b0VxdWFsKDQpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCBub3QgbGlua2lmeSBzbmlwcGV0IHdpdGhvdXQgdGhlIGxpbmt5IGZpbHRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2VzY2FwZWQtaHRtbCcpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQnKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgICB0b0JlKCdQcmV0dHkgdGV4dCB3aXRoIHNvbWUgbGlua3M6IGh0dHA6Ly9hbmd1bGFyanMub3JnLywgbWFpbHRvOnVzQHNvbWV3aGVyZS5vcmcsICcgK1xuICAgICAgICAgICAgICAgICAgJ2Fub3RoZXJAc29tZXdoZXJlLm9yZywgYW5kIG9uZSBtb3JlOiBmdHA6Ly8xMjcuMC4wLjEvLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQuYWxsKGJ5LmNzcygnI2VzY2FwZWQtaHRtbCBhJykpLmNvdW50KCkpLnRvRXF1YWwoMCk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5jbGVhcigpO1xuICAgICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5zZW5kS2V5cygnbmV3IGh0dHA6Ly9saW5rLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2xpbmt5LWZpbHRlcicpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQgfCBsaW5reScpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgIHRvQmUoJ25ldyBodHRwOi8vbGluay4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNsaW5reS1maWx0ZXIgYScpKS5jb3VudCgpKS50b0VxdWFsKDEpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2VzY2FwZWQtaHRtbCcpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQnKSkuZ2V0VGV4dCgpKVxuICAgICAgICAgICAgIC50b0JlKCduZXcgaHR0cDovL2xpbmsuJyk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIHdvcmsgd2l0aCB0aGUgdGFyZ2V0IHByb3BlcnR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdsaW5reS10YXJnZXQnKSkuXG4gICAgICAgICAgICBlbGVtZW50KGJ5LmJpbmRpbmcoXCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5OidfYmxhbmsnXCIpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgdG9CZSgnaHR0cDovL2FuZ3VsYXJqcy5vcmcvJyk7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2xpbmt5LXRhcmdldCBhJykpLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykpLnRvRXF1YWwoJ19ibGFuaycpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCBvcHRpb25hbGx5IGFkZCBjdXN0b20gYXR0cmlidXRlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoZWxlbWVudChieS5pZCgnbGlua3ktY3VzdG9tLWF0dHJpYnV0ZXMnKSkuXG4gICAgICAgICAgICBlbGVtZW50KGJ5LmJpbmRpbmcoXCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5Oidfc2VsZic6e3JlbDogJ25vZm9sbG93J31cIikpLmdldFRleHQoKSkuXG4gICAgICAgICAgICB0b0JlKCdodHRwOi8vYW5ndWxhcmpzLm9yZy8nKTtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjbGlua3ktY3VzdG9tLWF0dHJpYnV0ZXMgYScpKS5nZXRBdHRyaWJ1dGUoJ3JlbCcpKS50b0VxdWFsKCdub2ZvbGxvdycpO1xuICAgICAgIH0pO1xuICAgICA8L2ZpbGU+XG4gICA8L2V4YW1wbGU+XG4gKi9cbmFuZ3VsYXIubW9kdWxlKCduZ1Nhbml0aXplJykuZmlsdGVyKCdsaW5reScsIFsnJHNhbml0aXplJywgZnVuY3Rpb24oJHNhbml0aXplKSB7XG4gIHZhciBMSU5LWV9VUkxfUkVHRVhQID1cbiAgICAgICAgLygoZnRwfGh0dHBzPyk6XFwvXFwvfCh3d3dcXC4pfChtYWlsdG86KT9bQS1aYS16MC05Ll8lKy1dK0ApXFxTKlteXFxzLjssKCl7fTw+XCJcXHUyMDFkXFx1MjAxOV0vaSxcbiAgICAgIE1BSUxUT19SRUdFWFAgPSAvXm1haWx0bzovaTtcblxuICB2YXIgbGlua3lNaW5FcnIgPSBhbmd1bGFyLiQkbWluRXJyKCdsaW5reScpO1xuICB2YXIgaXNEZWZpbmVkID0gYW5ndWxhci5pc0RlZmluZWQ7XG4gIHZhciBpc0Z1bmN0aW9uID0gYW5ndWxhci5pc0Z1bmN0aW9uO1xuICB2YXIgaXNPYmplY3QgPSBhbmd1bGFyLmlzT2JqZWN0O1xuICB2YXIgaXNTdHJpbmcgPSBhbmd1bGFyLmlzU3RyaW5nO1xuXG4gIHJldHVybiBmdW5jdGlvbih0ZXh0LCB0YXJnZXQsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGV4dCA9PSBudWxsIHx8IHRleHQgPT09ICcnKSByZXR1cm4gdGV4dDtcbiAgICBpZiAoIWlzU3RyaW5nKHRleHQpKSB0aHJvdyBsaW5reU1pbkVycignbm90c3RyaW5nJywgJ0V4cGVjdGVkIHN0cmluZyBidXQgcmVjZWl2ZWQ6IHswfScsIHRleHQpO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXNGbiA9XG4gICAgICBpc0Z1bmN0aW9uKGF0dHJpYnV0ZXMpID8gYXR0cmlidXRlcyA6XG4gICAgICBpc09iamVjdChhdHRyaWJ1dGVzKSA/IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNPYmplY3QoKSB7cmV0dXJuIGF0dHJpYnV0ZXM7fSA6XG4gICAgICBmdW5jdGlvbiBnZXRFbXB0eUF0dHJpYnV0ZXNPYmplY3QoKSB7cmV0dXJuIHt9O307XG5cbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIHJhdyA9IHRleHQ7XG4gICAgdmFyIGh0bWwgPSBbXTtcbiAgICB2YXIgdXJsO1xuICAgIHZhciBpO1xuICAgIHdoaWxlICgobWF0Y2ggPSByYXcubWF0Y2goTElOS1lfVVJMX1JFR0VYUCkpKSB7XG4gICAgICAvLyBXZSBjYW4gbm90IGVuZCBpbiB0aGVzZSBhcyB0aGV5IGFyZSBzb21ldGltZXMgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgc2VudGVuY2VcbiAgICAgIHVybCA9IG1hdGNoWzBdO1xuICAgICAgLy8gaWYgd2UgZGlkIG5vdCBtYXRjaCBmdHAvaHR0cC93d3cvbWFpbHRvIHRoZW4gYXNzdW1lIG1haWx0b1xuICAgICAgaWYgKCFtYXRjaFsyXSAmJiAhbWF0Y2hbNF0pIHtcbiAgICAgICAgdXJsID0gKG1hdGNoWzNdID8gJ2h0dHA6Ly8nIDogJ21haWx0bzonKSArIHVybDtcbiAgICAgIH1cbiAgICAgIGkgPSBtYXRjaC5pbmRleDtcbiAgICAgIGFkZFRleHQocmF3LnN1YnN0cigwLCBpKSk7XG4gICAgICBhZGRMaW5rKHVybCwgbWF0Y2hbMF0ucmVwbGFjZShNQUlMVE9fUkVHRVhQLCAnJykpO1xuICAgICAgcmF3ID0gcmF3LnN1YnN0cmluZyhpICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICB9XG4gICAgYWRkVGV4dChyYXcpO1xuICAgIHJldHVybiAkc2FuaXRpemUoaHRtbC5qb2luKCcnKSk7XG5cbiAgICBmdW5jdGlvbiBhZGRUZXh0KHRleHQpIHtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBodG1sLnB1c2goc2FuaXRpemVUZXh0KHRleHQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRMaW5rKHVybCwgdGV4dCkge1xuICAgICAgdmFyIGtleSwgbGlua0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzRm4odXJsKTtcbiAgICAgIGh0bWwucHVzaCgnPGEgJyk7XG5cbiAgICAgIGZvciAoa2V5IGluIGxpbmtBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGh0bWwucHVzaChrZXkgKyAnPVwiJyArIGxpbmtBdHRyaWJ1dGVzW2tleV0gKyAnXCIgJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlZmluZWQodGFyZ2V0KSAmJiAhKCd0YXJnZXQnIGluIGxpbmtBdHRyaWJ1dGVzKSkge1xuICAgICAgICBodG1sLnB1c2goJ3RhcmdldD1cIicsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAnXCIgJyk7XG4gICAgICB9XG4gICAgICBodG1sLnB1c2goJ2hyZWY9XCInLFxuICAgICAgICAgICAgICAgIHVybC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JyksXG4gICAgICAgICAgICAgICAgJ1wiPicpO1xuICAgICAgYWRkVGV4dCh0ZXh0KTtcbiAgICAgIGh0bWwucHVzaCgnPC9hPicpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyLXNhbml0aXplL2FuZ3VsYXItc2FuaXRpemUuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports) {

eval("/*! angular-trix - v1.0.0 - 2015-12-09\r\n* https://github.com/sachinchoolur/angular-trix\r\n* Copyright (c) 2015 Sachin; Licensed MIT */\r\n!function(){\"use strict\";angular.module(\"angularTrix\",[]).directive(\"angularTrix\",function(){return{restrict:\"A\",require:\"ngModel\",scope:{trixInitialize:\"&\",trixChange:\"&\",trixSelectionChange:\"&\",trixFocus:\"&\",trixBlur:\"&\",trixFileAccept:\"&\",trixAttachmentAdd:\"&\",trixAttachmentRemove:\"&\"},link:function(a,b,c,d){b.on(\"trix-initialize\",function(){d.$modelValue&&b[0].editor.loadHTML(d.$modelValue)}),d.$render=function(){b[0].editor&&b[0].editor.loadHTML(d.$modelValue),b.on(\"trix-change\",function(){d.$setViewValue(b.html())})};var e=function(d,e){b[0].addEventListener(d,function(f){\"trix-file-accept\"===d&&\"true\"===c.preventTrixFileAccept&&f.preventDefault(),a[e]({e:f,editor:b[0].editor})})};e(\"trix-initialize\",\"trixInitialize\"),e(\"trix-change\",\"trixChange\"),e(\"trix-selection-change\",\"trixSelectionChange\"),e(\"trix-focus\",\"trixFocus\"),e(\"trix-blur\",\"trixBlur\"),e(\"trix-file-accept\",\"trixFileAccept\"),e(\"trix-attachment-add\",\"trixAttachmentAdd\"),e(\"trix-attachment-remove\",\"trixAttachmentRemove\")}}})}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vYW5ndWxhci10cml4L2Rpc3QvYW5ndWxhci10cml4Lm1pbi5qcz9hMTllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBhbmd1bGFyLXRyaXggLSB2MS4wLjAgLSAyMDE1LTEyLTA5XHJcbiogaHR0cHM6Ly9naXRodWIuY29tL3NhY2hpbmNob29sdXIvYW5ndWxhci10cml4XHJcbiogQ29weXJpZ2h0IChjKSAyMDE1IFNhY2hpbjsgTGljZW5zZWQgTUlUICovXHJcbiFmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2FuZ3VsYXIubW9kdWxlKFwiYW5ndWxhclRyaXhcIixbXSkuZGlyZWN0aXZlKFwiYW5ndWxhclRyaXhcIixmdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcIkFcIixyZXF1aXJlOlwibmdNb2RlbFwiLHNjb3BlOnt0cml4SW5pdGlhbGl6ZTpcIiZcIix0cml4Q2hhbmdlOlwiJlwiLHRyaXhTZWxlY3Rpb25DaGFuZ2U6XCImXCIsdHJpeEZvY3VzOlwiJlwiLHRyaXhCbHVyOlwiJlwiLHRyaXhGaWxlQWNjZXB0OlwiJlwiLHRyaXhBdHRhY2htZW50QWRkOlwiJlwiLHRyaXhBdHRhY2htZW50UmVtb3ZlOlwiJlwifSxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2Iub24oXCJ0cml4LWluaXRpYWxpemVcIixmdW5jdGlvbigpe2QuJG1vZGVsVmFsdWUmJmJbMF0uZWRpdG9yLmxvYWRIVE1MKGQuJG1vZGVsVmFsdWUpfSksZC4kcmVuZGVyPWZ1bmN0aW9uKCl7YlswXS5lZGl0b3ImJmJbMF0uZWRpdG9yLmxvYWRIVE1MKGQuJG1vZGVsVmFsdWUpLGIub24oXCJ0cml4LWNoYW5nZVwiLGZ1bmN0aW9uKCl7ZC4kc2V0Vmlld1ZhbHVlKGIuaHRtbCgpKX0pfTt2YXIgZT1mdW5jdGlvbihkLGUpe2JbMF0uYWRkRXZlbnRMaXN0ZW5lcihkLGZ1bmN0aW9uKGYpe1widHJpeC1maWxlLWFjY2VwdFwiPT09ZCYmXCJ0cnVlXCI9PT1jLnByZXZlbnRUcml4RmlsZUFjY2VwdCYmZi5wcmV2ZW50RGVmYXVsdCgpLGFbZV0oe2U6ZixlZGl0b3I6YlswXS5lZGl0b3J9KX0pfTtlKFwidHJpeC1pbml0aWFsaXplXCIsXCJ0cml4SW5pdGlhbGl6ZVwiKSxlKFwidHJpeC1jaGFuZ2VcIixcInRyaXhDaGFuZ2VcIiksZShcInRyaXgtc2VsZWN0aW9uLWNoYW5nZVwiLFwidHJpeFNlbGVjdGlvbkNoYW5nZVwiKSxlKFwidHJpeC1mb2N1c1wiLFwidHJpeEZvY3VzXCIpLGUoXCJ0cml4LWJsdXJcIixcInRyaXhCbHVyXCIpLGUoXCJ0cml4LWZpbGUtYWNjZXB0XCIsXCJ0cml4RmlsZUFjY2VwdFwiKSxlKFwidHJpeC1hdHRhY2htZW50LWFkZFwiLFwidHJpeEF0dGFjaG1lbnRBZGRcIiksZShcInRyaXgtYXR0YWNobWVudC1yZW1vdmVcIixcInRyaXhBdHRhY2htZW50UmVtb3ZlXCIpfX19KX0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhci10cml4L2Rpc3QvYW5ndWxhci10cml4Lm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports) {

eval("/**\n * State-based routing for AngularJS\n * @version v0.3.2\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n// issue #2676 #2889\nfunction silenceUncaughtInPromise (promise) {\n  return promise.then(undefined, function() {}) && promise;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/(~|\\/)/g, function (m) { return {'~':'~~', '/':'~2F'}[m]; }) : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/(~~|~2F)/g, function (m) { return {'~~':'~', '~2F':'/'}[m]; }) : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSupersededError = new Error('transition superseded');\n\n    var TransitionSuperseded = silenceUncaughtInPromise($q.reject(TransitionSupersededError));\n    var TransitionPrevented = silenceUncaughtInPromise($q.reject(new Error('transition prevented')));\n    var TransitionAborted = silenceUncaughtInPromise($q.reject(new Error('transition aborted')));\n    var TransitionFailed = silenceUncaughtInPromise($q.reject(new Error('transition failed')));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) {\n          $rootScope.$broadcast('$stateChangeCancel', redirect.to, redirect.toParams, state, params);\n          return TransitionSuperseded;\n        }\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          return TransitionSuperseded;\n        }\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          return TransitionSuperseded;\n        }\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }).then(null, function (error) {\n        // propagate TransitionSuperseded error without emitting $stateChangeCancel\n        // as it was already emitted in the success handler above\n        if (error === TransitionSupersededError) return TransitionSuperseded;\n\n        if ($state.transition !== transition) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          return TransitionSuperseded;\n        }\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n          $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      if (!params) { return true; }\n\n      var keys = objectKeys(params);\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i], paramDef = state.params[key];\n        if (paramDef && !paramDef.type.equals($stateParams[key], params[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            result.$$resolveAs = view.resolveAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .constant(\"$state.runtime\", { autoinject: true })\n  .provider('$state', $StateProvider)\n  // Inject $state to initialize when entering runtime. #2574\n  .run(['$injector', function ($injector) {\n    // Allow tests (stateSpec.js) to turn this off by defining this constant\n    if ($injector.get(\"$state.runtime\").autoinject) {\n      $injector.get('$state');\n    }\n  }]);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @example\n * A view can be unnamed or named.\n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div>\n *\n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#methods_state `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre>\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * </pre>\n *\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * Example usage of $resolve in a view template\n * <pre>\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate,   $q) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope),\n            inherited     = $element.inheritedData('$uiView');\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            var $uiViewData = currentEl.data('$uiViewAnim');\n            renderer.leave(currentEl, function() {\n              $uiViewData.$$animLeave.resolve();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            var animEnter = $q.defer(), animLeave = $q.defer();\n            var viewAnimData = {\n              $animEnter: animEnter.promise,\n              $animLeave: animLeave.promise,\n              $$animLeave: animLeave\n            };\n\n            clone.data('$uiViewAnim', viewAnimData);\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              animEnter.resolve();\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var resolveData = angular.extend({}, locals);\n        scope[locals.$$resolveAs] = resolveData;\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n            scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;\n          }\n          if (isFunction(controller.$onInit)) controller.$onInit();\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var uiViewCreatedBy = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (uiViewCreatedBy ? uiViewCreatedBy.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var unlinkInfoFn = null;\n      var hookFn;\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (unlinkInfoFn) unlinkInfoFn();\n        if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n      element[element.on ? 'on' : 'bind'](\"click\", hookFn);\n      scope.$on('$destroy', function() {\n        element[element.off ? 'off' : 'unbind'](\"click\", hookFn);\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#methods_href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n      var unlinkInfoFn = null;\n      var hookFn;\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (unlinkInfoFn) unlinkInfoFn();\n        if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n      element[element.on ? 'on' : 'bind'](\"click\", hookFn);\n      scope.$on('$destroy', function() {\n        element[element.off ? 'off' : 'unbind'](\"click\", hookFn);\n      });\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        var deregister = addState(newState, newParams, uiSrefActive);\n        update();\n        return deregister;\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        var stateInfo = {\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        };\n\n        states.push(stateInfo);\n        activeClasses[stateHash] = activeClass;\n\n        return function removeState() {\n          var idx = states.indexOf(stateInfo);\n          if (idx !== -1) states.splice(idx, 1);\n        };\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vYW5ndWxhci11aS1yb3V0ZXIvcmVsZWFzZS9hbmd1bGFyLXVpLXJvdXRlci5qcz9kZmU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3RhdGUtYmFzZWQgcm91dGluZyBmb3IgQW5ndWxhckpTXG4gKiBAdmVyc2lvbiB2MC4zLjJcbiAqIEBsaW5rIGh0dHA6Ly9hbmd1bGFyLXVpLmdpdGh1Yi5jb20vXG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSwgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBjb21tb25qcyBwYWNrYWdlIG1hbmFnZXIgc3VwcG9ydCAoZWcgY29tcG9uZW50anMpICovXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyA9PT0gZXhwb3J0cyl7XG4gIG1vZHVsZS5leHBvcnRzID0gJ3VpLnJvdXRlcic7XG59XG5cbihmdW5jdGlvbiAod2luZG93LCBhbmd1bGFyLCB1bmRlZmluZWQpIHtcbi8qanNoaW50IGdsb2JhbHN0cmljdDp0cnVlKi9cbi8qZ2xvYmFsIGFuZ3VsYXI6ZmFsc2UqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNEZWZpbmVkID0gYW5ndWxhci5pc0RlZmluZWQsXG4gICAgaXNGdW5jdGlvbiA9IGFuZ3VsYXIuaXNGdW5jdGlvbixcbiAgICBpc1N0cmluZyA9IGFuZ3VsYXIuaXNTdHJpbmcsXG4gICAgaXNPYmplY3QgPSBhbmd1bGFyLmlzT2JqZWN0LFxuICAgIGlzQXJyYXkgPSBhbmd1bGFyLmlzQXJyYXksXG4gICAgZm9yRWFjaCA9IGFuZ3VsYXIuZm9yRWFjaCxcbiAgICBleHRlbmQgPSBhbmd1bGFyLmV4dGVuZCxcbiAgICBjb3B5ID0gYW5ndWxhci5jb3B5LFxuICAgIHRvSnNvbiA9IGFuZ3VsYXIudG9Kc29uO1xuXG5mdW5jdGlvbiBpbmhlcml0KHBhcmVudCwgZXh0cmEpIHtcbiAgcmV0dXJuIGV4dGVuZChuZXcgKGV4dGVuZChmdW5jdGlvbigpIHt9LCB7IHByb3RvdHlwZTogcGFyZW50IH0pKSgpLCBleHRyYSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlKGRzdCkge1xuICBmb3JFYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gZHN0KSB7XG4gICAgICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoIWRzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBkc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgY29tbW9uIGFuY2VzdG9yIHBhdGggYmV0d2VlbiB0d28gc3RhdGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaXJzdCBUaGUgZmlyc3Qgc3RhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vjb25kIFRoZSBzZWNvbmQgc3RhdGUuXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZSBuYW1lcyBpbiBkZXNjZW5kaW5nIG9yZGVyLCBub3QgaW5jbHVkaW5nIHRoZSByb290LlxuICovXG5mdW5jdGlvbiBhbmNlc3RvcnMoZmlyc3QsIHNlY29uZCkge1xuICB2YXIgcGF0aCA9IFtdO1xuXG4gIGZvciAodmFyIG4gaW4gZmlyc3QucGF0aCkge1xuICAgIGlmIChmaXJzdC5wYXRoW25dICE9PSBzZWNvbmQucGF0aFtuXSkgYnJlYWs7XG4gICAgcGF0aC5wdXNoKGZpcnN0LnBhdGhbbl0pO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG4vKipcbiAqIElFOC1zYWZlIHdyYXBwZXIgZm9yIGBPYmplY3Qua2V5cygpYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IEEgSmF2YVNjcmlwdCBvYmplY3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyB0aGUga2V5cyBvZiB0aGUgb2JqZWN0IGFzIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yRWFjaChvYmplY3QsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSUU4LXNhZmUgd3JhcHBlciBmb3IgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mKClgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEEgSmF2YVNjcmlwdCBhcnJheS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQSB2YWx1ZSB0byBzZWFyY2ggdGhlIGFycmF5IGZvci5cbiAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgYXJyYXkgaW5kZXggdmFsdWUgb2YgYHZhbHVlYCwgb3IgYC0xYCBpZiBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUsIE51bWJlcihhcmd1bWVudHNbMl0pIHx8IDApO1xuICB9XG4gIHZhciBsZW4gPSBhcnJheS5sZW5ndGggPj4+IDAsIGZyb20gPSBOdW1iZXIoYXJndW1lbnRzWzJdKSB8fCAwO1xuICBmcm9tID0gKGZyb20gPCAwKSA/IE1hdGguY2VpbChmcm9tKSA6IE1hdGguZmxvb3IoZnJvbSk7XG5cbiAgaWYgKGZyb20gPCAwKSBmcm9tICs9IGxlbjtcblxuICBmb3IgKDsgZnJvbSA8IGxlbjsgZnJvbSsrKSB7XG4gICAgaWYgKGZyb20gaW4gYXJyYXkgJiYgYXJyYXlbZnJvbV0gPT09IHZhbHVlKSByZXR1cm4gZnJvbTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogTWVyZ2VzIGEgc2V0IG9mIHBhcmFtZXRlcnMgd2l0aCBhbGwgcGFyYW1ldGVycyBpbmhlcml0ZWQgYmV0d2VlbiB0aGUgY29tbW9uIHBhcmVudHMgb2YgdGhlXG4gKiBjdXJyZW50IHN0YXRlIGFuZCBhIGdpdmVuIGRlc3RpbmF0aW9uIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50UGFyYW1zIFRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBzdGF0ZSBwYXJhbWV0ZXJzICgkc3RhdGVQYXJhbXMpLlxuICogQHBhcmFtIHtPYmplY3R9IG5ld1BhcmFtcyBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2hpY2ggd2lsbCBiZSBjb21wb3NpdGVkIHdpdGggaW5oZXJpdGVkIHBhcmFtcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSAkY3VycmVudCBJbnRlcm5hbCBkZWZpbml0aW9uIG9mIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gJHRvIEludGVybmFsIGRlZmluaXRpb24gb2Ygb2JqZWN0IHJlcHJlc2VudGluZyBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLlxuICovXG5mdW5jdGlvbiBpbmhlcml0UGFyYW1zKGN1cnJlbnRQYXJhbXMsIG5ld1BhcmFtcywgJGN1cnJlbnQsICR0bykge1xuICB2YXIgcGFyZW50cyA9IGFuY2VzdG9ycygkY3VycmVudCwgJHRvKSwgcGFyZW50UGFyYW1zLCBpbmhlcml0ZWQgPSB7fSwgaW5oZXJpdExpc3QgPSBbXTtcblxuICBmb3IgKHZhciBpIGluIHBhcmVudHMpIHtcbiAgICBpZiAoIXBhcmVudHNbaV0gfHwgIXBhcmVudHNbaV0ucGFyYW1zKSBjb250aW51ZTtcbiAgICBwYXJlbnRQYXJhbXMgPSBvYmplY3RLZXlzKHBhcmVudHNbaV0ucGFyYW1zKTtcbiAgICBpZiAoIXBhcmVudFBhcmFtcy5sZW5ndGgpIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgaiBpbiBwYXJlbnRQYXJhbXMpIHtcbiAgICAgIGlmIChpbmRleE9mKGluaGVyaXRMaXN0LCBwYXJlbnRQYXJhbXNbal0pID49IDApIGNvbnRpbnVlO1xuICAgICAgaW5oZXJpdExpc3QucHVzaChwYXJlbnRQYXJhbXNbal0pO1xuICAgICAgaW5oZXJpdGVkW3BhcmVudFBhcmFtc1tqXV0gPSBjdXJyZW50UGFyYW1zW3BhcmVudFBhcmFtc1tqXV07XG4gICAgfVxuICB9XG4gIHJldHVybiBleHRlbmQoe30sIGluaGVyaXRlZCwgbmV3UGFyYW1zKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIG5vbi1zdHJpY3QgY29tcGFyaXNvbiBvZiB0aGUgc3Vic2V0IG9mIHR3byBvYmplY3RzLCBkZWZpbmVkIGJ5IGEgbGlzdCBvZiBrZXlzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBmaXJzdCBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgc2Vjb25kIG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGtleXMgVGhlIGxpc3Qgb2Yga2V5cyB3aXRoaW4gZWFjaCBvYmplY3QgdG8gY29tcGFyZS4gSWYgdGhlIGxpc3QgaXMgZW1wdHkgb3Igbm90IHNwZWNpZmllZCxcbiAqICAgICAgICAgICAgICAgICAgICAgaXQgZGVmYXVsdHMgdG8gdGhlIGxpc3Qgb2Yga2V5cyBpbiBgYWAuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsRm9yS2V5cyhhLCBiLCBrZXlzKSB7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBuIGluIGEpIGtleXMucHVzaChuKTsgLy8gVXNlZCBpbnN0ZWFkIG9mIE9iamVjdC5rZXlzKCkgZm9yIElFOCBjb21wYXRpYmlsaXR5XG4gIH1cblxuICBmb3IgKHZhciBpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrID0ga2V5c1tpXTtcbiAgICBpZiAoYVtrXSAhPSBiW2tdKSByZXR1cm4gZmFsc2U7IC8vIE5vdCAnPT09JywgdmFsdWVzIGFyZW4ndCBuZWNlc3NhcmlseSBub3JtYWxpemVkXG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3Vic2V0IG9mIGFuIG9iamVjdCwgYmFzZWQgb24gYSBsaXN0IG9mIGtleXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0ga2V5c1xuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlc1xuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBhIHN1YnNldCBvZiBgdmFsdWVzYC5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyQnlLZXlzKGtleXMsIHZhbHVlcykge1xuICB2YXIgZmlsdGVyZWQgPSB7fTtcblxuICBmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZmlsdGVyZWRbbmFtZV0gPSB2YWx1ZXNbbmFtZV07XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5cbi8vIGxpa2UgXy5pbmRleEJ5XG4vLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUsIG9yIHlvdSB3YW50IGxhc3Qtb25lLWluIHRvIHdpblxuZnVuY3Rpb24gaW5kZXhCeShhcnJheSwgcHJvcE5hbWUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3JFYWNoKGFycmF5LCBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmVzdWx0W2l0ZW1bcHJvcE5hbWVdXSA9IGl0ZW07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBleHRyYWN0ZWQgZnJvbSB1bmRlcnNjb3JlLmpzXG4vLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuZnVuY3Rpb24gcGljayhvYmopIHtcbiAgdmFyIGNvcHkgPSB7fTtcbiAgdmFyIGtleXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KEFycmF5LnByb3RvdHlwZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIGZvckVhY2goa2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmopIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICB9KTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIGV4dHJhY3RlZCBmcm9tIHVuZGVyc2NvcmUuanNcbi8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbWl0dGluZyB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbmZ1bmN0aW9uIG9taXQob2JqKSB7XG4gIHZhciBjb3B5ID0ge307XG4gIHZhciBrZXlzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShBcnJheS5wcm90b3R5cGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGluZGV4T2Yoa2V5cywga2V5KSA9PSAtMSkgY29weVtrZXldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb24sIGtleSkge1xuICB2YXIgcmVzdWx0ID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IFtdIDoge307XG5cbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWwsIGkpIHtcbiAgICByZXN1bHRbaV0gPSBpc0Z1bmN0aW9uKGtleSkgPyBrZXkodmFsKSA6IHZhbFtrZXldO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gIHZhciBhcnJheSA9IGlzQXJyYXkoY29sbGVjdGlvbik7XG4gIHZhciByZXN1bHQgPSBhcnJheSA/IFtdIDoge307XG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsLCBpKSB7XG4gICAgaWYgKGNhbGxiYWNrKHZhbCwgaSkpIHtcbiAgICAgIHJlc3VsdFthcnJheSA/IHJlc3VsdC5sZW5ndGggOiBpXSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBbXSA6IHt9O1xuXG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsLCBpKSB7XG4gICAgcmVzdWx0W2ldID0gY2FsbGJhY2sodmFsLCBpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGlzc3VlICMyNjc2ICMyODg5XG5mdW5jdGlvbiBzaWxlbmNlVW5jYXVnaHRJblByb21pc2UgKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uKCkge30pICYmIHByb21pc2U7XG59XG5cbi8qKlxuICogQG5nZG9jIG92ZXJ2aWV3XG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogIyB1aS5yb3V0ZXIudXRpbCBzdWItbW9kdWxlXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgYSBkZXBlbmRlbmN5IG9mIG90aGVyIHN1Yi1tb2R1bGVzLiBEbyBub3QgaW5jbHVkZSB0aGlzIG1vZHVsZSBhcyBhIGRlcGVuZGVuY3lcbiAqIGluIHlvdXIgYW5ndWxhciBhcHAgKHVzZSB7QGxpbmsgdWkucm91dGVyfSBtb2R1bGUgaW5zdGVhZCkuXG4gKlxuICovXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnV0aWwnLCBbJ25nJ10pO1xuXG4vKipcbiAqIEBuZ2RvYyBvdmVydmlld1xuICogQG5hbWUgdWkucm91dGVyLnJvdXRlclxuICogXG4gKiBAcmVxdWlyZXMgdWkucm91dGVyLnV0aWxcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICMgdWkucm91dGVyLnJvdXRlciBzdWItbW9kdWxlXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgYSBkZXBlbmRlbmN5IG9mIG90aGVyIHN1Yi1tb2R1bGVzLiBEbyBub3QgaW5jbHVkZSB0aGlzIG1vZHVsZSBhcyBhIGRlcGVuZGVuY3lcbiAqIGluIHlvdXIgYW5ndWxhciBhcHAgKHVzZSB7QGxpbmsgdWkucm91dGVyfSBtb2R1bGUgaW5zdGVhZCkuXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIucm91dGVyJywgWyd1aS5yb3V0ZXIudXRpbCddKTtcblxuLyoqXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZVxuICogXG4gKiBAcmVxdWlyZXMgdWkucm91dGVyLnJvdXRlclxuICogQHJlcXVpcmVzIHVpLnJvdXRlci51dGlsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAjIHVpLnJvdXRlci5zdGF0ZSBzdWItbW9kdWxlXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgYSBkZXBlbmRlbmN5IG9mIHRoZSBtYWluIHVpLnJvdXRlciBtb2R1bGUuIERvIG5vdCBpbmNsdWRlIHRoaXMgbW9kdWxlIGFzIGEgZGVwZW5kZW5jeVxuICogaW4geW91ciBhbmd1bGFyIGFwcCAodXNlIHtAbGluayB1aS5yb3V0ZXJ9IG1vZHVsZSBpbnN0ZWFkKS5cbiAqIFxuICovXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJywgWyd1aS5yb3V0ZXIucm91dGVyJywgJ3VpLnJvdXRlci51dGlsJ10pO1xuXG4vKipcbiAqIEBuZ2RvYyBvdmVydmlld1xuICogQG5hbWUgdWkucm91dGVyXG4gKlxuICogQHJlcXVpcmVzIHVpLnJvdXRlci5zdGF0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogIyB1aS5yb3V0ZXJcbiAqIFxuICogIyMgVGhlIG1haW4gbW9kdWxlIGZvciB1aS5yb3V0ZXIgXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBzdWItbW9kdWxlcyBpbmNsdWRlZCB3aXRoIHRoZSB1aS5yb3V0ZXIgbW9kdWxlLCBob3dldmVyIG9ubHkgdGhpcyBtb2R1bGUgaXMgbmVlZGVkXG4gKiBhcyBhIGRlcGVuZGVuY3kgd2l0aGluIHlvdXIgYW5ndWxhciBhcHAuIFRoZSBvdGhlciBtb2R1bGVzIGFyZSBmb3Igb3JnYW5pemF0aW9uIHB1cnBvc2VzLiBcbiAqXG4gKiBUaGUgbW9kdWxlcyBhcmU6XG4gKiAqIHVpLnJvdXRlciAtIHRoZSBtYWluIFwidW1icmVsbGFcIiBtb2R1bGVcbiAqICogdWkucm91dGVyLnJvdXRlciAtIFxuICogXG4gKiAqWW91J2xsIG5lZWQgdG8gaW5jbHVkZSAqKm9ubHkqKiB0aGlzIG1vZHVsZSBhcyB0aGUgZGVwZW5kZW5jeSB3aXRoaW4geW91ciBhbmd1bGFyIGFwcC4qXG4gKiBcbiAqIDxwcmU+XG4gKiA8IWRvY3R5cGUgaHRtbD5cbiAqIDxodG1sIG5nLWFwcD1cIm15QXBwXCI+XG4gKiA8aGVhZD5cbiAqICAgPHNjcmlwdCBzcmM9XCJqcy9hbmd1bGFyLmpzXCI+PC9zY3JpcHQ+XG4gKiAgIDwhLS0gSW5jbHVkZSB0aGUgdWktcm91dGVyIHNjcmlwdCAtLT5cbiAqICAgPHNjcmlwdCBzcmM9XCJqcy9hbmd1bGFyLXVpLXJvdXRlci5taW4uanNcIj48L3NjcmlwdD5cbiAqICAgPHNjcmlwdD5cbiAqICAgICAvLyAuLi5hbmQgYWRkICd1aS5yb3V0ZXInIGFzIGEgZGVwZW5kZW5jeVxuICogICAgIHZhciBteUFwcCA9IGFuZ3VsYXIubW9kdWxlKCdteUFwcCcsIFsndWkucm91dGVyJ10pO1xuICogICA8L3NjcmlwdD5cbiAqIDwvaGVhZD5cbiAqIDxib2R5PlxuICogPC9ib2R5PlxuICogPC9odG1sPlxuICogPC9wcmU+XG4gKi9cbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXInLCBbJ3VpLnJvdXRlci5zdGF0ZSddKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5jb21wYXQnLCBbJ3VpLnJvdXRlciddKTtcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kcmVzb2x2ZVxuICpcbiAqIEByZXF1aXJlcyAkcVxuICogQHJlcXVpcmVzICRpbmplY3RvclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTWFuYWdlcyByZXNvbHV0aW9uIG9mIChhY3ljbGljKSBncmFwaHMgb2YgcHJvbWlzZXMuXG4gKi9cbiRSZXNvbHZlLiRpbmplY3QgPSBbJyRxJywgJyRpbmplY3RvciddO1xuZnVuY3Rpb24gJFJlc29sdmUoICAkcSwgICAgJGluamVjdG9yKSB7XG4gIFxuICB2YXIgVklTSVRfSU5fUFJPR1JFU1MgPSAxLFxuICAgICAgVklTSVRfRE9ORSA9IDIsXG4gICAgICBOT1RISU5HID0ge30sXG4gICAgICBOT19ERVBFTkRFTkNJRVMgPSBbXSxcbiAgICAgIE5PX0xPQ0FMUyA9IE5PVEhJTkcsXG4gICAgICBOT19QQVJFTlQgPSBleHRlbmQoJHEud2hlbihOT1RISU5HKSwgeyAkJHByb21pc2VzOiBOT1RISU5HLCAkJHZhbHVlczogTk9USElORyB9KTtcbiAgXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kcmVzb2x2ZSNzdHVkeVxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHJlc29sdmVcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFN0dWRpZXMgYSBzZXQgb2YgaW52b2NhYmxlcyB0aGF0IGFyZSBsaWtlbHkgdG8gYmUgdXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICogPHByZT5cbiAgICogJHJlc29sdmUuc3R1ZHkoaW52b2NhYmxlcykobG9jYWxzLCBwYXJlbnQsIHNlbGYpXG4gICAqIDwvcHJlPlxuICAgKiBpcyBlcXVpdmFsZW50IHRvXG4gICAqIDxwcmU+XG4gICAqICRyZXNvbHZlLnJlc29sdmUoaW52b2NhYmxlcywgbG9jYWxzLCBwYXJlbnQsIHNlbGYpXG4gICAqIDwvcHJlPlxuICAgKiBidXQgdGhlIGZvcm1lciBpcyBtb3JlIGVmZmljaWVudCAoaW4gZmFjdCBgcmVzb2x2ZWAganVzdCBjYWxscyBgc3R1ZHlgIFxuICAgKiBpbnRlcm5hbGx5KS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGludm9jYWJsZXMgSW52b2NhYmxlIG9iamVjdHNcbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGEgZnVuY3Rpb24gdG8gcGFzcyBpbiBsb2NhbHMsIHBhcmVudCBhbmQgc2VsZlxuICAgKi9cbiAgdGhpcy5zdHVkeSA9IGZ1bmN0aW9uIChpbnZvY2FibGVzKSB7XG4gICAgaWYgKCFpc09iamVjdChpbnZvY2FibGVzKSkgdGhyb3cgbmV3IEVycm9yKFwiJ2ludm9jYWJsZXMnIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgIHZhciBpbnZvY2FibGVLZXlzID0gb2JqZWN0S2V5cyhpbnZvY2FibGVzIHx8IHt9KTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIGEgdG9wb2xvZ2ljYWwgc29ydCBvZiBpbnZvY2FibGVzIHRvIGJ1aWxkIGFuIG9yZGVyZWQgcGxhblxuICAgIHZhciBwbGFuID0gW10sIGN5Y2xlID0gW10sIHZpc2l0ZWQgPSB7fTtcbiAgICBmdW5jdGlvbiB2aXNpdCh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmlzaXRlZFtrZXldID09PSBWSVNJVF9ET05FKSByZXR1cm47XG4gICAgICBcbiAgICAgIGN5Y2xlLnB1c2goa2V5KTtcbiAgICAgIGlmICh2aXNpdGVkW2tleV0gPT09IFZJU0lUX0lOX1BST0dSRVNTKSB7XG4gICAgICAgIGN5Y2xlLnNwbGljZSgwLCBpbmRleE9mKGN5Y2xlLCBrZXkpKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3k6IFwiICsgY3ljbGUuam9pbihcIiAtPiBcIikpO1xuICAgICAgfVxuICAgICAgdmlzaXRlZFtrZXldID0gVklTSVRfSU5fUFJPR1JFU1M7XG4gICAgICBcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcGxhbi5wdXNoKGtleSwgWyBmdW5jdGlvbigpIHsgcmV0dXJuICRpbmplY3Rvci5nZXQodmFsdWUpOyB9XSwgTk9fREVQRU5ERU5DSUVTKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSAkaW5qZWN0b3IuYW5ub3RhdGUodmFsdWUpO1xuICAgICAgICBmb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgaWYgKHBhcmFtICE9PSBrZXkgJiYgaW52b2NhYmxlcy5oYXNPd25Qcm9wZXJ0eShwYXJhbSkpIHZpc2l0KGludm9jYWJsZXNbcGFyYW1dLCBwYXJhbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwbGFuLnB1c2goa2V5LCB2YWx1ZSwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY3ljbGUucG9wKCk7XG4gICAgICB2aXNpdGVkW2tleV0gPSBWSVNJVF9ET05FO1xuICAgIH1cbiAgICBmb3JFYWNoKGludm9jYWJsZXMsIHZpc2l0KTtcbiAgICBpbnZvY2FibGVzID0gY3ljbGUgPSB2aXNpdGVkID0gbnVsbDsgLy8gcGxhbiBpcyBhbGwgdGhhdCdzIHJlcXVpcmVkXG4gICAgXG4gICAgZnVuY3Rpb24gaXNSZXNvbHZlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLnRoZW4gJiYgdmFsdWUuJCRwcm9taXNlcztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsb2NhbHMsIHBhcmVudCwgc2VsZikge1xuICAgICAgaWYgKGlzUmVzb2x2ZShsb2NhbHMpICYmIHNlbGYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmID0gcGFyZW50OyBwYXJlbnQgPSBsb2NhbHM7IGxvY2FscyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWxvY2FscykgbG9jYWxzID0gTk9fTE9DQUxTO1xuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KGxvY2FscykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2xvY2FscycgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICB9ICAgICAgIFxuICAgICAgaWYgKCFwYXJlbnQpIHBhcmVudCA9IE5PX1BBUkVOVDtcbiAgICAgIGVsc2UgaWYgKCFpc1Jlc29sdmUocGFyZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIncGFyZW50JyBtdXN0IGJlIGEgcHJvbWlzZSByZXR1cm5lZCBieSAkcmVzb2x2ZS5yZXNvbHZlKClcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRvIGNvbXBsZXRlIHRoZSBvdmVyYWxsIHJlc29sdXRpb24sIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhlIHBhcmVudFxuICAgICAgLy8gcHJvbWlzZSBhbmQgZm9yIHRoZSBwcm9taXNlIGZvciBlYWNoIGludm9rYWJsZSBpbiBvdXIgcGxhbi5cbiAgICAgIHZhciByZXNvbHV0aW9uID0gJHEuZGVmZXIoKSxcbiAgICAgICAgICByZXN1bHQgPSByZXNvbHV0aW9uLnByb21pc2UsXG4gICAgICAgICAgcHJvbWlzZXMgPSByZXN1bHQuJCRwcm9taXNlcyA9IHt9LFxuICAgICAgICAgIHZhbHVlcyA9IGV4dGVuZCh7fSwgbG9jYWxzKSxcbiAgICAgICAgICB3YWl0ID0gMSArIHBsYW4ubGVuZ3RoLzMsXG4gICAgICAgICAgbWVyZ2VkID0gZmFsc2U7XG4gICAgICAgICAgXG4gICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAvLyBNZXJnZSBwYXJlbnQgdmFsdWVzIHdlIGhhdmVuJ3QgZ290IHlldCBhbmQgcHVibGlzaCBvdXIgb3duICQkdmFsdWVzXG4gICAgICAgIGlmICghLS13YWl0KSB7XG4gICAgICAgICAgaWYgKCFtZXJnZWQpIG1lcmdlKHZhbHVlcywgcGFyZW50LiQkdmFsdWVzKTsgXG4gICAgICAgICAgcmVzdWx0LiQkdmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgIHJlc3VsdC4kJHByb21pc2VzID0gcmVzdWx0LiQkcHJvbWlzZXMgfHwgdHJ1ZTsgLy8ga2VlcCBmb3IgaXNSZXNvbHZlKClcbiAgICAgICAgICBkZWxldGUgcmVzdWx0LiQkaW5oZXJpdGVkVmFsdWVzO1xuICAgICAgICAgIHJlc29sdXRpb24ucmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XG4gICAgICAgIHJlc3VsdC4kJGZhaWx1cmUgPSByZWFzb247XG4gICAgICAgIHJlc29sdXRpb24ucmVqZWN0KHJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgcGFyZW50IGhhcyBhbHJlYWR5IGZhaWxlZFxuICAgICAgaWYgKGlzRGVmaW5lZChwYXJlbnQuJCRmYWlsdXJlKSkge1xuICAgICAgICBmYWlsKHBhcmVudC4kJGZhaWx1cmUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocGFyZW50LiQkaW5oZXJpdGVkVmFsdWVzKSB7XG4gICAgICAgIG1lcmdlKHZhbHVlcywgb21pdChwYXJlbnQuJCRpbmhlcml0ZWRWYWx1ZXMsIGludm9jYWJsZUtleXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVyZ2UgcGFyZW50IHZhbHVlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IHJlc29sdmVkLCBvciBtZXJnZVxuICAgICAgLy8gcGFyZW50IHByb21pc2VzIGFuZCB3YWl0IGlmIHRoZSBwYXJlbnQgcmVzb2x2ZSBpcyBzdGlsbCBpbiBwcm9ncmVzcy5cbiAgICAgIGV4dGVuZChwcm9taXNlcywgcGFyZW50LiQkcHJvbWlzZXMpO1xuICAgICAgaWYgKHBhcmVudC4kJHZhbHVlcykge1xuICAgICAgICBtZXJnZWQgPSBtZXJnZSh2YWx1ZXMsIG9taXQocGFyZW50LiQkdmFsdWVzLCBpbnZvY2FibGVLZXlzKSk7XG4gICAgICAgIHJlc3VsdC4kJGluaGVyaXRlZFZhbHVlcyA9IG9taXQocGFyZW50LiQkdmFsdWVzLCBpbnZvY2FibGVLZXlzKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudC4kJGluaGVyaXRlZFZhbHVlcykge1xuICAgICAgICAgIHJlc3VsdC4kJGluaGVyaXRlZFZhbHVlcyA9IG9taXQocGFyZW50LiQkaW5oZXJpdGVkVmFsdWVzLCBpbnZvY2FibGVLZXlzKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgICAgIHBhcmVudC50aGVuKGRvbmUsIGZhaWwpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggaW52b2NhYmxlIGluIHRoZSBwbGFuLCBidXQgaWdub3JlIGFueSB3aGVyZSBhIGxvY2FsIG9mIHRoZSBzYW1lIG5hbWUgZXhpc3RzLlxuICAgICAgZm9yICh2YXIgaT0wLCBpaT1wbGFuLmxlbmd0aDsgaTxpaTsgaSs9Mykge1xuICAgICAgICBpZiAobG9jYWxzLmhhc093blByb3BlcnR5KHBsYW5baV0pKSBkb25lKCk7XG4gICAgICAgIGVsc2UgaW52b2tlKHBsYW5baV0sIHBsYW5baSsxXSwgcGxhbltpKzJdKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gaW52b2tlKGtleSwgaW52b2NhYmxlLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgZm9yIHRoaXMgaW52b2NhdGlvbi4gRmFpbHVyZXMgd2lsbCBwcm9wYWdhdGUgdG8gdGhlIHJlc29sdXRpb24gYXMgd2VsbC5cbiAgICAgICAgdmFyIGludm9jYXRpb24gPSAkcS5kZWZlcigpLCB3YWl0UGFyYW1zID0gMDtcbiAgICAgICAgZnVuY3Rpb24gb25mYWlsdXJlKHJlYXNvbikge1xuICAgICAgICAgIGludm9jYXRpb24ucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgZmFpbChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgZm9yIGFueSBwYXJhbWV0ZXIgdGhhdCB3ZSBoYXZlIGEgcHJvbWlzZSBmb3IgKGVpdGhlciBmcm9tIHBhcmVudCBvciBmcm9tIHRoaXNcbiAgICAgICAgLy8gcmVzb2x2ZTsgaW4gdGhhdCBjYXNlIHN0dWR5KCkgd2lsbCBoYXZlIG1hZGUgc3VyZSBpdCdzIG9yZGVyZWQgYmVmb3JlIHVzIGluIHRoZSBwbGFuKS5cbiAgICAgICAgZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICBpZiAocHJvbWlzZXMuaGFzT3duUHJvcGVydHkoZGVwKSAmJiAhbG9jYWxzLmhhc093blByb3BlcnR5KGRlcCkpIHtcbiAgICAgICAgICAgIHdhaXRQYXJhbXMrKztcbiAgICAgICAgICAgIHByb21pc2VzW2RlcF0udGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHZhbHVlc1tkZXBdID0gcmVzdWx0O1xuICAgICAgICAgICAgICBpZiAoISgtLXdhaXRQYXJhbXMpKSBwcm9jZWVkKCk7XG4gICAgICAgICAgICB9LCBvbmZhaWx1cmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghd2FpdFBhcmFtcykgcHJvY2VlZCgpO1xuICAgICAgICBmdW5jdGlvbiBwcm9jZWVkKCkge1xuICAgICAgICAgIGlmIChpc0RlZmluZWQocmVzdWx0LiQkZmFpbHVyZSkpIHJldHVybjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW52b2NhdGlvbi5yZXNvbHZlKCRpbmplY3Rvci5pbnZva2UoaW52b2NhYmxlLCBzZWxmLCB2YWx1ZXMpKTtcbiAgICAgICAgICAgIGludm9jYXRpb24ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0sIG9uZmFpbHVyZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb25mYWlsdXJlKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQdWJsaXNoIHByb21pc2Ugc3luY2hyb25vdXNseTsgaW52b2NhdGlvbnMgZnVydGhlciBkb3duIGluIHRoZSBwbGFuIG1heSBkZXBlbmQgb24gaXQuXG4gICAgICAgIHByb21pc2VzW2tleV0gPSBpbnZvY2F0aW9uLnByb21pc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdWkucm91dGVyLnV0aWwuJHJlc29sdmUjcmVzb2x2ZVxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHJlc29sdmVcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJlc29sdmVzIGEgc2V0IG9mIGludm9jYWJsZXMuIEFuIGludm9jYWJsZSBpcyBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgdmlhIFxuICAgKiBgJGluamVjdG9yLmludm9rZSgpYCwgYW5kIGNhbiBoYXZlIGFuIGFyYml0cmFyeSBudW1iZXIgb2YgZGVwZW5kZW5jaWVzLiBcbiAgICogQW4gaW52b2NhYmxlIGNhbiBlaXRoZXIgcmV0dXJuIGEgdmFsdWUgZGlyZWN0bHksXG4gICAqIG9yIGEgYCRxYCBwcm9taXNlLiBJZiBhIHByb21pc2UgaXMgcmV0dXJuZWQgaXQgd2lsbCBiZSByZXNvbHZlZCBhbmQgdGhlIFxuICAgKiByZXN1bHRpbmcgdmFsdWUgd2lsbCBiZSB1c2VkIGluc3RlYWQuIERlcGVuZGVuY2llcyBvZiBpbnZvY2FibGVzIGFyZSByZXNvbHZlZCBcbiAgICogKGluIHRoaXMgb3JkZXIgb2YgcHJlY2VkZW5jZSlcbiAgICpcbiAgICogLSBmcm9tIHRoZSBzcGVjaWZpZWQgYGxvY2Fsc2BcbiAgICogLSBmcm9tIGFub3RoZXIgaW52b2NhYmxlIHRoYXQgaXMgcGFydCBvZiB0aGlzIGAkcmVzb2x2ZWAgY2FsbFxuICAgKiAtIGZyb20gYW4gaW52b2NhYmxlIHRoYXQgaXMgaW5oZXJpdGVkIGZyb20gYSBgcGFyZW50YCBjYWxsIHRvIGAkcmVzb2x2ZWAgXG4gICAqICAgKG9yIHJlY3Vyc2l2ZWx5XG4gICAqIC0gZnJvbSBhbnkgYW5jZXN0b3IgYCRyZXNvbHZlYCBvZiB0aGF0IHBhcmVudCkuXG4gICAqXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgb2YgYCRyZXNvbHZlYCBpcyBhIHByb21pc2UgZm9yIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIFxuICAgKiAoaW4gdGhpcyBvcmRlciBvZiBwcmVjZWRlbmNlKVxuICAgKlxuICAgKiAtIGFueSBgbG9jYWxzYCAoaWYgc3BlY2lmaWVkKVxuICAgKiAtIHRoZSByZXNvbHZlZCByZXR1cm4gdmFsdWVzIG9mIGFsbCBpbmplY3RhYmxlc1xuICAgKiAtIGFueSB2YWx1ZXMgaW5oZXJpdGVkIGZyb20gYSBgcGFyZW50YCBjYWxsIHRvIGAkcmVzb2x2ZWAgKGlmIHNwZWNpZmllZClcbiAgICpcbiAgICogVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlIGFmdGVyIHRoZSBgcGFyZW50YCBwcm9taXNlIChpZiBhbnkpIGFuZCBhbGwgcHJvbWlzZXMgXG4gICAqIHJldHVybmVkIGJ5IGluamVjdGFibGVzIGhhdmUgYmVlbiByZXNvbHZlZC4gSWYgYW55IGludm9jYWJsZSBcbiAgICogKG9yIGAkaW5qZWN0b3IuaW52b2tlYCkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgb3IgaWYgYSBwcm9taXNlIHJldHVybmVkIGJ5IGFuIFxuICAgKiBpbnZvY2FibGUgaXMgcmVqZWN0ZWQsIHRoZSBgJHJlc29sdmVgIHByb21pc2UgaXMgaW1tZWRpYXRlbHkgcmVqZWN0ZWQgd2l0aCB0aGUgXG4gICAqIHNhbWUgZXJyb3IuIEEgcmVqZWN0aW9uIG9mIGEgYHBhcmVudGAgcHJvbWlzZSAoaWYgc3BlY2lmaWVkKSB3aWxsIGxpa2V3aXNlIGJlIFxuICAgKiBwcm9wYWdhdGVkIGltbWVkaWF0ZWx5LiBPbmNlIHRoZSBgJHJlc29sdmVgIHByb21pc2UgaGFzIGJlZW4gcmVqZWN0ZWQsIG5vIFxuICAgKiBmdXJ0aGVyIGludm9jYWJsZXMgd2lsbCBiZSBjYWxsZWQuXG4gICAqIFxuICAgKiBDeWNsaWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gaW52b2NhYmxlcyBhcmUgbm90IHBlcm1pdHRlZCBhbmQgd2lsbCBjYXVzZSBgJHJlc29sdmVgXG4gICAqIHRvIHRocm93IGFuIGVycm9yLiBBcyBhIHNwZWNpYWwgY2FzZSwgYW4gaW5qZWN0YWJsZSBjYW4gZGVwZW5kIG9uIGEgcGFyYW1ldGVyIFxuICAgKiB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGluamVjdGFibGUsIHdoaWNoIHdpbGwgYmUgZnVsZmlsbGVkIGZyb20gdGhlIGBwYXJlbnRgIFxuICAgKiBpbmplY3RhYmxlIG9mIHRoZSBzYW1lIG5hbWUuIFRoaXMgYWxsb3dzIGluaGVyaXRlZCB2YWx1ZXMgdG8gYmUgZGVjb3JhdGVkLiBcbiAgICogTm90ZSB0aGF0IGluIHRoaXMgY2FzZSBhbnkgb3RoZXIgaW5qZWN0YWJsZSBpbiB0aGUgc2FtZSBgJHJlc29sdmVgIHdpdGggdGhlIHNhbWVcbiAgICogZGVwZW5kZW5jeSB3b3VsZCBzZWUgdGhlIGRlY29yYXRlZCB2YWx1ZSwgbm90IHRoZSBpbmhlcml0ZWQgdmFsdWUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBtaXNzaW5nIGRlcGVuZGVuY2llcyAtLSB1bmxpa2UgY3ljbGljIGRlcGVuZGVuY2llcyAtLSB3aWxsIGNhdXNlIGFuIFxuICAgKiAoYXN5bmNocm9ub3VzKSByZWplY3Rpb24gb2YgdGhlIGAkcmVzb2x2ZWAgcHJvbWlzZSByYXRoZXIgdGhhbiBhIChzeW5jaHJvbm91cykgXG4gICAqIGV4Y2VwdGlvbi5cbiAgICpcbiAgICogSW52b2NhYmxlcyBhcmUgaW52b2tlZCBlYWdlcmx5IGFzIHNvb24gYXMgYWxsIGRlcGVuZGVuY2llcyBhcmUgYXZhaWxhYmxlLiBcbiAgICogVGhpcyBpcyB0cnVlIGV2ZW4gZm9yIGRlcGVuZGVuY2llcyBpbmhlcml0ZWQgZnJvbSBhIGBwYXJlbnRgIGNhbGwgdG8gYCRyZXNvbHZlYC5cbiAgICpcbiAgICogQXMgYSBzcGVjaWFsIGNhc2UsIGFuIGludm9jYWJsZSBjYW4gYmUgYSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgaXQgaXMgdGFrZW4gdG8gXG4gICAqIGJlIGEgc2VydmljZSBuYW1lIHRvIGJlIHBhc3NlZCB0byBgJGluamVjdG9yLmdldCgpYC4gVGhpcyBpcyBzdXBwb3J0ZWQgcHJpbWFyaWx5IFxuICAgKiBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCB0aGUgYHJlc29sdmVgIHByb3BlcnR5IG9mIGAkcm91dGVQcm92aWRlcmAgXG4gICAqIHJvdXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGludm9jYWJsZXMgZnVuY3Rpb25zIHRvIGludm9rZSBvciBcbiAgICogYCRpbmplY3RvcmAgc2VydmljZXMgdG8gZmV0Y2guXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsb2NhbHMgIHZhbHVlcyB0byBtYWtlIGF2YWlsYWJsZSB0byB0aGUgaW5qZWN0YWJsZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudCAgYSBwcm9taXNlIHJldHVybmVkIGJ5IGFub3RoZXIgY2FsbCB0byBgJHJlc29sdmVgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2VsZiAgdGhlIGB0aGlzYCBmb3IgdGhlIGludm9rZWQgbWV0aG9kc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9IFByb21pc2UgZm9yIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSByZXNvbHZlZCByZXR1cm4gdmFsdWVcbiAgICogb2YgYWxsIGludm9jYWJsZXMsIGFzIHdlbGwgYXMgYW55IGluaGVyaXRlZCBhbmQgbG9jYWwgdmFsdWVzLlxuICAgKi9cbiAgdGhpcy5yZXNvbHZlID0gZnVuY3Rpb24gKGludm9jYWJsZXMsIGxvY2FscywgcGFyZW50LCBzZWxmKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R1ZHkoaW52b2NhYmxlcykobG9jYWxzLCBwYXJlbnQsIHNlbGYpO1xuICB9O1xufVxuXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnV0aWwnKS5zZXJ2aWNlKCckcmVzb2x2ZScsICRSZXNvbHZlKTtcblxuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR0ZW1wbGF0ZUZhY3RvcnlcbiAqXG4gKiBAcmVxdWlyZXMgJGh0dHBcbiAqIEByZXF1aXJlcyAkdGVtcGxhdGVDYWNoZVxuICogQHJlcXVpcmVzICRpbmplY3RvclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2VydmljZS4gTWFuYWdlcyBsb2FkaW5nIG9mIHRlbXBsYXRlcy5cbiAqL1xuJFRlbXBsYXRlRmFjdG9yeS4kaW5qZWN0ID0gWyckaHR0cCcsICckdGVtcGxhdGVDYWNoZScsICckaW5qZWN0b3InXTtcbmZ1bmN0aW9uICRUZW1wbGF0ZUZhY3RvcnkoICAkaHR0cCwgICAkdGVtcGxhdGVDYWNoZSwgICAkaW5qZWN0b3IpIHtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR0ZW1wbGF0ZUZhY3RvcnkjZnJvbUNvbmZpZ1xuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHRlbXBsYXRlRmFjdG9yeVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBjb25maWd1cmF0aW9uIG9iamVjdC4gXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHdoaWNoIHRvIGxvYWQgYSB0ZW1wbGF0ZS4gXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgc2VhcmNoIGluIHRoZSBzcGVjaWZpZWQgb3JkZXIsIGFuZCB0aGUgZmlyc3Qgb25lIFxuICAgKiB0aGF0IGlzIGRlZmluZWQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHRlbXBsYXRlOlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGNvbmZpZy50ZW1wbGF0ZSBodG1sIHN0cmluZyB0ZW1wbGF0ZSBvciBmdW5jdGlvbiB0byBcbiAgICogbG9hZCB2aWEge0BsaW5rIHVpLnJvdXRlci51dGlsLiR0ZW1wbGF0ZUZhY3RvcnkjZnJvbVN0cmluZyBmcm9tU3RyaW5nfS5cbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBjb25maWcudGVtcGxhdGVVcmwgdXJsIHRvIGxvYWQgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgXG4gICAqIHRoZSB1cmwgdG8gbG9hZCB2aWEge0BsaW5rIHVpLnJvdXRlci51dGlsLiR0ZW1wbGF0ZUZhY3RvcnkjZnJvbVVybCBmcm9tVXJsfS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIgZnVuY3Rpb24gdG8gaW52b2tlIHZpYSBcbiAgICoge0BsaW5rIHVpLnJvdXRlci51dGlsLiR0ZW1wbGF0ZUZhY3RvcnkjZnJvbVByb3ZpZGVyIGZyb21Qcm92aWRlcn0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsb2NhbHMgTG9jYWxzIHRvIHBhc3MgdG8gYGludm9rZWAgaWYgdGhlIHRlbXBsYXRlIGlzIGxvYWRlZCBcbiAgICogdmlhIGEgYHRlbXBsYXRlUHJvdmlkZXJgLiBEZWZhdWx0cyB0byBgeyBwYXJhbXM6IHBhcmFtcyB9YC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfG9iamVjdH0gIFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2UgZm9yIFxuICAgKiB0aGF0IHN0cmluZyxvciBgbnVsbGAgaWYgbm8gdGVtcGxhdGUgaXMgY29uZmlndXJlZC5cbiAgICovXG4gIHRoaXMuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcsIHBhcmFtcywgbG9jYWxzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGlzRGVmaW5lZChjb25maWcudGVtcGxhdGUpID8gdGhpcy5mcm9tU3RyaW5nKGNvbmZpZy50ZW1wbGF0ZSwgcGFyYW1zKSA6XG4gICAgICBpc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlVXJsKSA/IHRoaXMuZnJvbVVybChjb25maWcudGVtcGxhdGVVcmwsIHBhcmFtcykgOlxuICAgICAgaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyKSA/IHRoaXMuZnJvbVByb3ZpZGVyKGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyLCBwYXJhbXMsIGxvY2FscykgOlxuICAgICAgbnVsbFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5I2Zyb21TdHJpbmdcbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLiR0ZW1wbGF0ZUZhY3RvcnlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHRlbXBsYXRlIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgb3IgZnVuY3Rpb24gdGhhdCBcbiAgICogcmV0dXJucyBhbiBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xvYmplY3R9IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2UgZm9yIHRoYXQgXG4gICAqIHN0cmluZy5cbiAgICovXG4gIHRoaXMuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odGVtcGxhdGUpID8gdGVtcGxhdGUocGFyYW1zKSA6IHRlbXBsYXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdWkucm91dGVyLnV0aWwuJHRlbXBsYXRlRmFjdG9yeSNmcm9tVXJsXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5XG4gICAqIFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogTG9hZHMgYSB0ZW1wbGF0ZSBmcm9tIHRoZSBhIFVSTCB2aWEgYCRodHRwYCBhbmQgYCR0ZW1wbGF0ZUNhY2hlYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHVybCB1cmwgb2YgdGhlIHRlbXBsYXRlIHRvIGxvYWQsIG9yIGEgZnVuY3Rpb24gXG4gICAqIHRoYXQgcmV0dXJucyBhIHVybC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHVybCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2UgXG4gICAqIGZvciB0aGF0IHN0cmluZy5cbiAgICovXG4gIHRoaXMuZnJvbVVybCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcykge1xuICAgIGlmIChpc0Z1bmN0aW9uKHVybCkpIHVybCA9IHVybChwYXJhbXMpO1xuICAgIGlmICh1cmwgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgZWxzZSByZXR1cm4gJGh0dHBcbiAgICAgICAgLmdldCh1cmwsIHsgY2FjaGU6ICR0ZW1wbGF0ZUNhY2hlLCBoZWFkZXJzOiB7IEFjY2VwdDogJ3RleHQvaHRtbCcgfX0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZS5kYXRhOyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR0ZW1wbGF0ZUZhY3RvcnkjZnJvbVByb3ZpZGVyXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgYnkgaW52b2tpbmcgYW4gaW5qZWN0YWJsZSBwcm92aWRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvdmlkZXIgRnVuY3Rpb24gdG8gaW52b2tlIHZpYSBgJGluamVjdG9yLmludm9rZWBcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIGZvciB0aGUgdGVtcGxhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbHMgTG9jYWxzIHRvIHBhc3MgdG8gYGludm9rZWAuIERlZmF1bHRzIHRvIFxuICAgKiBgeyBwYXJhbXM6IHBhcmFtcyB9YC5cbiAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2UgXG4gICAqIGZvciB0aGF0IHN0cmluZy5cbiAgICovXG4gIHRoaXMuZnJvbVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBwYXJhbXMsIGxvY2Fscykge1xuICAgIHJldHVybiAkaW5qZWN0b3IuaW52b2tlKHByb3ZpZGVyLCBudWxsLCBsb2NhbHMgfHwgeyBwYXJhbXM6IHBhcmFtcyB9KTtcbiAgfTtcbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJykuc2VydmljZSgnJHRlbXBsYXRlRmFjdG9yeScsICRUZW1wbGF0ZUZhY3RvcnkpO1xuXG52YXIgJCRVTUZQOyAvLyByZWZlcmVuY2UgdG8gJFVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXJcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1hdGNoZXMgVVJMcyBhZ2FpbnN0IHBhdHRlcm5zIGFuZCBleHRyYWN0cyBuYW1lZCBwYXJhbWV0ZXJzIGZyb20gdGhlIHBhdGggb3IgdGhlIHNlYXJjaFxuICogcGFydCBvZiB0aGUgVVJMLiBBIFVSTCBwYXR0ZXJuIGNvbnNpc3RzIG9mIGEgcGF0aCBwYXR0ZXJuLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5ICc/JyBhbmQgYSBsaXN0XG4gKiBvZiBzZWFyY2ggcGFyYW1ldGVycy4gTXVsdGlwbGUgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhcmUgc2VwYXJhdGVkIGJ5ICcmJy4gU2VhcmNoIHBhcmFtZXRlcnNcbiAqIGRvIG5vdCBpbmZsdWVuY2Ugd2hldGhlciBvciBub3QgYSBVUkwgaXMgbWF0Y2hlZCwgYnV0IHRoZWlyIHZhbHVlcyBhcmUgcGFzc2VkIHRocm91Z2ggaW50b1xuICogdGhlIG1hdGNoZWQgcGFyYW1ldGVycyByZXR1cm5lZCBieSB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyI21ldGhvZHNfZXhlYyBleGVjfS5cbiAqXG4gKiBQYXRoIHBhcmFtZXRlciBwbGFjZWhvbGRlcnMgY2FuIGJlIHNwZWNpZmllZCB1c2luZyBzaW1wbGUgY29sb24vY2F0Y2gtYWxsIHN5bnRheCBvciBjdXJseSBicmFjZVxuICogc3ludGF4LCB3aGljaCBvcHRpb25hbGx5IGFsbG93cyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdGhlIHBhcmFtZXRlciB0byBiZSBzcGVjaWZpZWQ6XG4gKlxuICogKiBgJzonYCBuYW1lIC0gY29sb24gcGxhY2Vob2xkZXJcbiAqICogYCcqJ2AgbmFtZSAtIGNhdGNoLWFsbCBwbGFjZWhvbGRlclxuICogKiBgJ3snIG5hbWUgJ30nYCAtIGN1cmx5IHBsYWNlaG9sZGVyXG4gKiAqIGAneycgbmFtZSAnOicgcmVnZXhwfHR5cGUgJ30nYCAtIGN1cmx5IHBsYWNlaG9sZGVyIHdpdGggcmVnZXhwIG9yIHR5cGUgbmFtZS4gU2hvdWxkIHRoZVxuICogICByZWdleHAgaXRzZWxmIGNvbnRhaW4gY3VybHkgYnJhY2VzLCB0aGV5IG11c3QgYmUgaW4gbWF0Y2hlZCBwYWlycyBvciBlc2NhcGVkIHdpdGggYSBiYWNrc2xhc2guXG4gKlxuICogUGFyYW1ldGVyIG5hbWVzIG1heSBjb250YWluIG9ubHkgd29yZCBjaGFyYWN0ZXJzIChsYXRpbiBsZXR0ZXJzLCBkaWdpdHMsIGFuZCB1bmRlcnNjb3JlKSBhbmRcbiAqIG11c3QgYmUgdW5pcXVlIHdpdGhpbiB0aGUgcGF0dGVybiAoYWNyb3NzIGJvdGggcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMpLiBGb3IgY29sb25cbiAqIHBsYWNlaG9sZGVycyBvciBjdXJseSBwbGFjZWhvbGRlcnMgd2l0aG91dCBhbiBleHBsaWNpdCByZWdleHAsIGEgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnlcbiAqIG51bWJlciBvZiBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gJy8nLiBGb3IgY2F0Y2gtYWxsIHBsYWNlaG9sZGVycyB0aGUgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlc1xuICogYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICogYCcvaGVsbG8vJ2AgLSBNYXRjaGVzIG9ubHkgaWYgdGhlIHBhdGggaXMgZXhhY3RseSAnL2hlbGxvLycuIFRoZXJlIGlzIG5vIHNwZWNpYWwgdHJlYXRtZW50IGZvclxuICogICB0cmFpbGluZyBzbGFzaGVzLCBhbmQgcGF0dGVybnMgaGF2ZSB0byBtYXRjaCB0aGUgZW50aXJlIHBhdGgsIG5vdCBqdXN0IGEgcHJlZml4LlxuICogKiBgJy91c2VyLzppZCdgIC0gTWF0Y2hlcyAnL3VzZXIvYm9iJyBvciAnL3VzZXIvMTIzNCEhIScgb3IgZXZlbiAnL3VzZXIvJyBidXQgbm90ICcvdXNlcicgb3JcbiAqICAgJy91c2VyL2JvYi9kZXRhaWxzJy4gVGhlIHNlY29uZCBwYXRoIHNlZ21lbnQgd2lsbCBiZSBjYXB0dXJlZCBhcyB0aGUgcGFyYW1ldGVyICdpZCcuXG4gKiAqIGAnL3VzZXIve2lkfSdgIC0gU2FtZSBhcyB0aGUgcHJldmlvdXMgZXhhbXBsZSwgYnV0IHVzaW5nIGN1cmx5IGJyYWNlIHN5bnRheC5cbiAqICogYCcvdXNlci97aWQ6W14vXSp9J2AgLSBTYW1lIGFzIHRoZSBwcmV2aW91cyBleGFtcGxlLlxuICogKiBgJy91c2VyL3tpZDpbMC05YS1mQS1GXXsxLDh9fSdgIC0gU2ltaWxhciB0byB0aGUgcHJldmlvdXMgZXhhbXBsZSwgYnV0IG9ubHkgbWF0Y2hlcyBpZiB0aGUgaWRcbiAqICAgcGFyYW1ldGVyIGNvbnNpc3RzIG9mIDEgdG8gOCBoZXggZGlnaXRzLlxuICogKiBgJy9maWxlcy97cGF0aDouKn0nYCAtIE1hdGNoZXMgYW55IFVSTCBzdGFydGluZyB3aXRoICcvZmlsZXMvJyBhbmQgY2FwdHVyZXMgdGhlIHJlc3Qgb2YgdGhlXG4gKiAgIHBhdGggaW50byB0aGUgcGFyYW1ldGVyICdwYXRoJy5cbiAqICogYCcvZmlsZXMvKnBhdGgnYCAtIGRpdHRvLlxuICogKiBgJy9jYWxlbmRhci97c3RhcnQ6ZGF0ZX0nYCAtIE1hdGNoZXMgXCIvY2FsZW5kYXIvMjAxNC0xMS0xMlwiIChiZWNhdXNlIHRoZSBwYXR0ZXJuIGRlZmluZWRcbiAqICAgaW4gdGhlIGJ1aWx0LWluICBgZGF0ZWAgVHlwZSBtYXRjaGVzIGAyMDE0LTExLTEyYCkgYW5kIHByb3ZpZGVzIGEgRGF0ZSBvYmplY3QgaW4gJHN0YXRlUGFyYW1zLnN0YXJ0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gIFRoZSBwYXR0ZXJuIHRvIGNvbXBpbGUgaW50byBhIG1hdGNoZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGhhc2g6XG4gKiBAcGFyYW0ge09iamVjdD19IHBhcmVudE1hdGNoZXIgVXNlZCB0byBjb25jYXRlbmF0ZSB0aGUgcGF0dGVybi9jb25maWcgb250b1xuICogICBhbiBleGlzdGluZyBVcmxNYXRjaGVyXG4gKlxuICogKiBgY2FzZUluc2Vuc2l0aXZlYCAtIGB0cnVlYCBpZiBVUkwgbWF0Y2hpbmcgc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmUsIG90aGVyd2lzZSBgZmFsc2VgLCB0aGUgZGVmYXVsdCB2YWx1ZSAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpIGlzIGBmYWxzZWAuXG4gKiAqIGBzdHJpY3RgIC0gYGZhbHNlYCBpZiBtYXRjaGluZyBhZ2FpbnN0IGEgVVJMIHdpdGggYSB0cmFpbGluZyBzbGFzaCBzaG91bGQgYmUgdHJlYXRlZCBhcyBlcXVpdmFsZW50IHRvIGEgVVJMIHdpdGhvdXQgYSB0cmFpbGluZyBzbGFzaCwgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcmVmaXggIEEgc3RhdGljIHByZWZpeCBvZiB0aGlzIHBhdHRlcm4uIFRoZSBtYXRjaGVyIGd1YXJhbnRlZXMgdGhhdCBhbnlcbiAqICAgVVJMIG1hdGNoaW5nIHRoaXMgbWF0Y2hlciAoaS5lLiBhbnkgc3RyaW5nIGZvciB3aGljaCB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyI21ldGhvZHNfZXhlYyBleGVjKCl9IHJldHVybnNcbiAqICAgbm9uLW51bGwpIHdpbGwgc3RhcnQgd2l0aCB0aGlzIHByZWZpeC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlICBUaGUgcGF0dGVybiB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3JcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlUGF0aCAgVGhlIHBhdGggcG9ydGlvbiBvZiB0aGUgc291cmNlIHByb3BlcnR5XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZVNlYXJjaCAgVGhlIHNlYXJjaCBwb3J0aW9uIG9mIHRoZSBzb3VyY2UgcHJvcGVydHlcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVnZXggIFRoZSBjb25zdHJ1Y3RlZCByZWdleCB0aGF0IHdpbGwgYmUgdXNlZCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB1cmwgd2hlblxuICogICBpdCBpcyB0aW1lIHRvIGRldGVybWluZSB3aGljaCB1cmwgd2lsbCBtYXRjaC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAgTmV3IGBVcmxNYXRjaGVyYCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gVXJsTWF0Y2hlcihwYXR0ZXJuLCBjb25maWcsIHBhcmVudE1hdGNoZXIpIHtcbiAgY29uZmlnID0gZXh0ZW5kKHsgcGFyYW1zOiB7fSB9LCBpc09iamVjdChjb25maWcpID8gY29uZmlnIDoge30pO1xuXG4gIC8vIEZpbmQgYWxsIHBsYWNlaG9sZGVycyBhbmQgY3JlYXRlIGEgY29tcGlsZWQgcGF0dGVybiwgdXNpbmcgZWl0aGVyIGNsYXNzaWMgb3IgY3VybHkgc3ludGF4OlxuICAvLyAgICcqJyBuYW1lXG4gIC8vICAgJzonIG5hbWVcbiAgLy8gICAneycgbmFtZSAnfSdcbiAgLy8gICAneycgbmFtZSAnOicgcmVnZXhwICd9J1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGlzIHNvbWV3aGF0IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGUgbmVlZCB0byBhbGxvdyBjdXJseSBicmFjZXNcbiAgLy8gaW5zaWRlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uIFRoZSBwbGFjZWhvbGRlciByZWdleHAgYnJlYWtzIGRvd24gYXMgZm9sbG93czpcbiAgLy8gICAgKFs6Kl0pKFtcXHdcXFtcXF1dKykgICAgICAgICAgICAgIC0gY2xhc3NpYyBwbGFjZWhvbGRlciAoJDEgLyAkMikgKHNlYXJjaCB2ZXJzaW9uIGhhcyAtIGZvciBzbmFrZS1jYXNlKVxuICAvLyAgICBcXHsoW1xcd1xcW1xcXV0rKSg/OlxcOlxccyooIC4uLiApKT9cXH0gIC0gY3VybHkgYnJhY2UgcGxhY2Vob2xkZXIgKCQzKSB3aXRoIG9wdGlvbmFsIHJlZ2V4cC90eXBlIC4uLiAoJDQpIChzZWFyY2ggdmVyc2lvbiBoYXMgLSBmb3Igc25ha2UtY2FzZVxuICAvLyAgICAoPzogLi4uIHwgLi4uIHwgLi4uICkrICAgICAgICAgLSB0aGUgcmVnZXhwIGNvbnNpc3RzIG9mIGFueSBudW1iZXIgb2YgYXRvbXMsIGFuIGF0b20gYmVpbmcgZWl0aGVyXG4gIC8vICAgIFtee31cXFxcXSsgICAgICAgICAgICAgICAgICAgICAgIC0gYW55dGhpbmcgb3RoZXIgdGhhbiBjdXJseSBicmFjZXMgb3IgYmFja3NsYXNoXG4gIC8vICAgIFxcXFwuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYSBiYWNrc2xhc2ggZXNjYXBlXG4gIC8vICAgIFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSAgICAgICAgICAtIGEgbWF0Y2hlZCBzZXQgb2YgY3VybHkgYnJhY2VzIGNvbnRhaW5pbmcgb3RoZXIgYXRvbXNcbiAgdmFyIHBsYWNlaG9sZGVyICAgICAgID0gLyhbOipdKShbXFx3XFxbXFxdXSspfFxceyhbXFx3XFxbXFxdXSspKD86XFw6XFxzKigoPzpbXnt9XFxcXF0rfFxcXFwufFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSkrKSk/XFx9L2csXG4gICAgICBzZWFyY2hQbGFjZWhvbGRlciA9IC8oWzpdPykoW1xcd1xcW1xcXS4tXSspfFxceyhbXFx3XFxbXFxdLi1dKykoPzpcXDpcXHMqKCg/Oltee31cXFxcXSt8XFxcXC58XFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9KSspKT9cXH0vZyxcbiAgICAgIGNvbXBpbGVkID0gJ14nLCBsYXN0ID0gMCwgbSxcbiAgICAgIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cyA9IFtdLFxuICAgICAgcGFyZW50UGFyYW1zID0gcGFyZW50TWF0Y2hlciA/IHBhcmVudE1hdGNoZXIucGFyYW1zIDoge30sXG4gICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcyA9IHBhcmVudE1hdGNoZXIgPyBwYXJlbnRNYXRjaGVyLnBhcmFtcy4kJG5ldygpIDogbmV3ICQkVU1GUC5QYXJhbVNldCgpLFxuICAgICAgcGFyYW1OYW1lcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGFkZFBhcmFtZXRlcihpZCwgdHlwZSwgY29uZmlnLCBsb2NhdGlvbikge1xuICAgIHBhcmFtTmFtZXMucHVzaChpZCk7XG4gICAgaWYgKHBhcmVudFBhcmFtc1tpZF0pIHJldHVybiBwYXJlbnRQYXJhbXNbaWRdO1xuICAgIGlmICghL15cXHcrKFstLl0rXFx3KykqKD86XFxbXFxdKT8kLy50ZXN0KGlkKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgbmFtZSAnXCIgKyBpZCArIFwiJyBpbiBwYXR0ZXJuICdcIiArIHBhdHRlcm4gKyBcIidcIik7XG4gICAgaWYgKHBhcmFtc1tpZF0pIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZSAnXCIgKyBpZCArIFwiJyBpbiBwYXR0ZXJuICdcIiArIHBhdHRlcm4gKyBcIidcIik7XG4gICAgcGFyYW1zW2lkXSA9IG5ldyAkJFVNRlAuUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgbG9jYXRpb24pO1xuICAgIHJldHVybiBwYXJhbXNbaWRdO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVvdGVSZWdFeHAoc3RyaW5nLCBwYXR0ZXJuLCBzcXVhc2gsIG9wdGlvbmFsKSB7XG4gICAgdmFyIHN1cnJvdW5kUGF0dGVybiA9IFsnJywnJ10sIHJlc3VsdCA9IHN0cmluZy5yZXBsYWNlKC9bXFxcXFxcW1xcXVxcXiQqKz8uKCl8e31dL2csIFwiXFxcXCQmXCIpO1xuICAgIGlmICghcGF0dGVybikgcmV0dXJuIHJlc3VsdDtcbiAgICBzd2l0Y2goc3F1YXNoKSB7XG4gICAgICBjYXNlIGZhbHNlOiBzdXJyb3VuZFBhdHRlcm4gPSBbJygnLCAnKScgKyAob3B0aW9uYWwgPyBcIj9cIiA6IFwiXCIpXTsgYnJlYWs7XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICBzdXJyb3VuZFBhdHRlcm4gPSBbJyg/OlxcLygnLCAnKXxcXC8pPyddO1xuICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAgICBzdXJyb3VuZFBhdHRlcm4gPSBbJygnICsgc3F1YXNoICsgXCJ8XCIsICcpPyddOyBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCArIHN1cnJvdW5kUGF0dGVyblswXSArIHBhdHRlcm4gKyBzdXJyb3VuZFBhdHRlcm5bMV07XG4gIH1cblxuICB0aGlzLnNvdXJjZSA9IHBhdHRlcm47XG5cbiAgLy8gU3BsaXQgaW50byBzdGF0aWMgc2VnbWVudHMgc2VwYXJhdGVkIGJ5IHBhdGggcGFyYW1ldGVyIHBsYWNlaG9sZGVycy5cbiAgLy8gVGhlIG51bWJlciBvZiBzZWdtZW50cyBpcyBhbHdheXMgMSBtb3JlIHRoYW4gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzLlxuICBmdW5jdGlvbiBtYXRjaERldGFpbHMobSwgaXNTZWFyY2gpIHtcbiAgICB2YXIgaWQsIHJlZ2V4cCwgc2VnbWVudCwgdHlwZSwgY2ZnLCBhcnJheU1vZGU7XG4gICAgaWQgICAgICAgICAgPSBtWzJdIHx8IG1bM107IC8vIElFWzc4XSByZXR1cm5zICcnIGZvciB1bm1hdGNoZWQgZ3JvdXBzIGluc3RlYWQgb2YgbnVsbFxuICAgIGNmZyAgICAgICAgID0gY29uZmlnLnBhcmFtc1tpZF07XG4gICAgc2VnbWVudCAgICAgPSBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0LCBtLmluZGV4KTtcbiAgICByZWdleHAgICAgICA9IGlzU2VhcmNoID8gbVs0XSA6IG1bNF0gfHwgKG1bMV0gPT0gJyonID8gJy4qJyA6IG51bGwpO1xuXG4gICAgaWYgKHJlZ2V4cCkge1xuICAgICAgdHlwZSAgICAgID0gJCRVTUZQLnR5cGUocmVnZXhwKSB8fCBpbmhlcml0KCQkVU1GUC50eXBlKFwic3RyaW5nXCIpLCB7IHBhdHRlcm46IG5ldyBSZWdFeHAocmVnZXhwLCBjb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkKSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGlkLCByZWdleHA6IHJlZ2V4cCwgc2VnbWVudDogc2VnbWVudCwgdHlwZTogdHlwZSwgY2ZnOiBjZmdcbiAgICB9O1xuICB9XG5cbiAgdmFyIHAsIHBhcmFtLCBzZWdtZW50O1xuICB3aGlsZSAoKG0gPSBwbGFjZWhvbGRlci5leGVjKHBhdHRlcm4pKSkge1xuICAgIHAgPSBtYXRjaERldGFpbHMobSwgZmFsc2UpO1xuICAgIGlmIChwLnNlZ21lbnQuaW5kZXhPZignPycpID49IDApIGJyZWFrOyAvLyB3ZSdyZSBpbnRvIHRoZSBzZWFyY2ggcGFydFxuXG4gICAgcGFyYW0gPSBhZGRQYXJhbWV0ZXIocC5pZCwgcC50eXBlLCBwLmNmZywgXCJwYXRoXCIpO1xuICAgIGNvbXBpbGVkICs9IHF1b3RlUmVnRXhwKHAuc2VnbWVudCwgcGFyYW0udHlwZS5wYXR0ZXJuLnNvdXJjZSwgcGFyYW0uc3F1YXNoLCBwYXJhbS5pc09wdGlvbmFsKTtcbiAgICBzZWdtZW50cy5wdXNoKHAuc2VnbWVudCk7XG4gICAgbGFzdCA9IHBsYWNlaG9sZGVyLmxhc3RJbmRleDtcbiAgfVxuICBzZWdtZW50ID0gcGF0dGVybi5zdWJzdHJpbmcobGFzdCk7XG5cbiAgLy8gRmluZCBhbnkgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbGFzdCBzZWdtZW50XG4gIHZhciBpID0gc2VnbWVudC5pbmRleE9mKCc/Jyk7XG5cbiAgaWYgKGkgPj0gMCkge1xuICAgIHZhciBzZWFyY2ggPSB0aGlzLnNvdXJjZVNlYXJjaCA9IHNlZ21lbnQuc3Vic3RyaW5nKGkpO1xuICAgIHNlZ21lbnQgPSBzZWdtZW50LnN1YnN0cmluZygwLCBpKTtcbiAgICB0aGlzLnNvdXJjZVBhdGggPSBwYXR0ZXJuLnN1YnN0cmluZygwLCBsYXN0ICsgaSk7XG5cbiAgICBpZiAoc2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICAgIGxhc3QgPSAwO1xuICAgICAgd2hpbGUgKChtID0gc2VhcmNoUGxhY2Vob2xkZXIuZXhlYyhzZWFyY2gpKSkge1xuICAgICAgICBwID0gbWF0Y2hEZXRhaWxzKG0sIHRydWUpO1xuICAgICAgICBwYXJhbSA9IGFkZFBhcmFtZXRlcihwLmlkLCBwLnR5cGUsIHAuY2ZnLCBcInNlYXJjaFwiKTtcbiAgICAgICAgbGFzdCA9IHBsYWNlaG9sZGVyLmxhc3RJbmRleDtcbiAgICAgICAgLy8gY2hlY2sgaWYgPyZcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zb3VyY2VQYXRoID0gcGF0dGVybjtcbiAgICB0aGlzLnNvdXJjZVNlYXJjaCA9ICcnO1xuICB9XG5cbiAgY29tcGlsZWQgKz0gcXVvdGVSZWdFeHAoc2VnbWVudCkgKyAoY29uZmlnLnN0cmljdCA9PT0gZmFsc2UgPyAnXFwvPycgOiAnJykgKyAnJCc7XG4gIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cbiAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKGNvbXBpbGVkLCBjb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkKTtcbiAgdGhpcy5wcmVmaXggPSBzZWdtZW50c1swXTtcbiAgdGhpcy4kJHBhcmFtTmFtZXMgPSBwYXJhbU5hbWVzO1xufVxuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyI2NvbmNhdFxuICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJucyBhIG5ldyBtYXRjaGVyIGZvciBhIHBhdHRlcm4gY29uc3RydWN0ZWQgYnkgYXBwZW5kaW5nIHRoZSBwYXRoIHBhcnQgYW5kIGFkZGluZyB0aGVcbiAqIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoZSBzcGVjaWZpZWQgcGF0dGVybiB0byB0aGlzIHBhdHRlcm4uIFRoZSBjdXJyZW50IHBhdHRlcm4gaXMgbm90XG4gKiBtb2RpZmllZC4gVGhpcyBjYW4gYmUgdW5kZXJzdG9vZCBhcyBjcmVhdGluZyBhIHBhdHRlcm4gZm9yIFVSTHMgdGhhdCBhcmUgcmVsYXRpdmUgdG8gKG9yXG4gKiBzdWZmaXhlcyBvZikgdGhlIGN1cnJlbnQgcGF0dGVybi5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGZvbGxvd2luZyB0d28gbWF0Y2hlcnMgYXJlIGVxdWl2YWxlbnQ6XG4gKiA8cHJlPlxuICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cScpLmNvbmNhdCgnL2RldGFpbHM/ZGF0ZScpO1xuICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0vZGV0YWlscz9xJmRhdGUnKTtcbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuICBUaGUgcGF0dGVybiB0byBhcHBlbmQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICBBbiBvYmplY3QgaGFzaCBvZiB0aGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIG1hdGNoZXIuXG4gKiBAcmV0dXJucyB7VXJsTWF0Y2hlcn0gIEEgbWF0Y2hlciBmb3IgdGhlIGNvbmNhdGVuYXRlZCBwYXR0ZXJuLlxuICovXG5VcmxNYXRjaGVyLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAocGF0dGVybiwgY29uZmlnKSB7XG4gIC8vIEJlY2F1c2Ugb3JkZXIgb2Ygc2VhcmNoIHBhcmFtZXRlcnMgaXMgaXJyZWxldmFudCwgd2UgY2FuIGFkZCBvdXIgb3duIHNlYXJjaFxuICAvLyBwYXJhbWV0ZXJzIHRvIHRoZSBlbmQgb2YgdGhlIG5ldyBwYXR0ZXJuLiBQYXJzZSB0aGUgbmV3IHBhdHRlcm4gYnkgaXRzZWxmXG4gIC8vIGFuZCB0aGVuIGpvaW4gdGhlIGJpdHMgdG9nZXRoZXIsIGJ1dCBpdCdzIG11Y2ggZWFzaWVyIHRvIGRvIHRoaXMgb24gYSBzdHJpbmcgbGV2ZWwuXG4gIHZhciBkZWZhdWx0Q29uZmlnID0ge1xuICAgIGNhc2VJbnNlbnNpdGl2ZTogJCRVTUZQLmNhc2VJbnNlbnNpdGl2ZSgpLFxuICAgIHN0cmljdDogJCRVTUZQLnN0cmljdE1vZGUoKSxcbiAgICBzcXVhc2g6ICQkVU1GUC5kZWZhdWx0U3F1YXNoUG9saWN5KClcbiAgfTtcbiAgcmV0dXJuIG5ldyBVcmxNYXRjaGVyKHRoaXMuc291cmNlUGF0aCArIHBhdHRlcm4gKyB0aGlzLnNvdXJjZVNlYXJjaCwgZXh0ZW5kKGRlZmF1bHRDb25maWcsIGNvbmZpZyksIHRoaXMpO1xufTtcblxuVXJsTWF0Y2hlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZTtcbn07XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIjZXhlY1xuICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGVzdHMgdGhlIHNwZWNpZmllZCBwYXRoIGFnYWluc3QgdGhpcyBtYXRjaGVyLCBhbmQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2FwdHVyZWRcbiAqIHBhcmFtZXRlciB2YWx1ZXMsIG9yIG51bGwgaWYgdGhlIHBhdGggZG9lcyBub3QgbWF0Y2guIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIHZhbHVlc1xuICogb2YgYW55IHNlYXJjaCBwYXJhbWV0ZXJzIHRoYXQgYXJlIG1lbnRpb25lZCBpbiB0aGUgcGF0dGVybiwgYnV0IHRoZWlyIHZhbHVlIG1heSBiZSBudWxsIGlmXG4gKiB0aGV5IGFyZSBub3QgcHJlc2VudCBpbiBgc2VhcmNoUGFyYW1zYC4gVGhpcyBtZWFucyB0aGF0IHNlYXJjaCBwYXJhbWV0ZXJzIGFyZSBhbHdheXMgdHJlYXRlZFxuICogYXMgb3B0aW9uYWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxwcmU+XG4gKiBuZXcgVXJsTWF0Y2hlcignL3VzZXIve2lkfT9xJnInKS5leGVjKCcvdXNlci9ib2InLCB7XG4gKiAgIHg6ICcxJywgcTogJ2hlbGxvJ1xuICogfSk7XG4gKiAvLyByZXR1cm5zIHsgaWQ6ICdib2InLCBxOiAnaGVsbG8nLCByOiBudWxsIH1cbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICBUaGUgVVJMIHBhdGggdG8gbWF0Y2gsIGUuZy4gYCRsb2NhdGlvbi5wYXRoKClgLlxuICogQHBhcmFtIHtPYmplY3R9IHNlYXJjaFBhcmFtcyAgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzLCBlLmcuIGAkbG9jYXRpb24uc2VhcmNoKClgLlxuICogQHJldHVybnMge09iamVjdH0gIFRoZSBjYXB0dXJlZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICovXG5VcmxNYXRjaGVyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKHBhdGgsIHNlYXJjaFBhcmFtcykge1xuICB2YXIgbSA9IHRoaXMucmVnZXhwLmV4ZWMocGF0aCk7XG4gIGlmICghbSkgcmV0dXJuIG51bGw7XG4gIHNlYXJjaFBhcmFtcyA9IHNlYXJjaFBhcmFtcyB8fCB7fTtcblxuICB2YXIgcGFyYW1OYW1lcyA9IHRoaXMucGFyYW1ldGVycygpLCBuVG90YWwgPSBwYXJhbU5hbWVzLmxlbmd0aCxcbiAgICBuUGF0aCA9IHRoaXMuc2VnbWVudHMubGVuZ3RoIC0gMSxcbiAgICB2YWx1ZXMgPSB7fSwgaSwgaiwgY2ZnLCBwYXJhbU5hbWU7XG5cbiAgaWYgKG5QYXRoICE9PSBtLmxlbmd0aCAtIDEpIHRocm93IG5ldyBFcnJvcihcIlVuYmFsYW5jZWQgY2FwdHVyZSBncm91cCBpbiByb3V0ZSAnXCIgKyB0aGlzLnNvdXJjZSArIFwiJ1wiKTtcblxuICBmdW5jdGlvbiBkZWNvZGVQYXRoQXJyYXkoc3RyaW5nKSB7XG4gICAgZnVuY3Rpb24gcmV2ZXJzZVN0cmluZyhzdHIpIHsgcmV0dXJuIHN0ci5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTsgfVxuICAgIGZ1bmN0aW9uIHVucXVvdGVEYXNoZXMoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC0vZywgXCItXCIpOyB9XG5cbiAgICB2YXIgc3BsaXQgPSByZXZlcnNlU3RyaW5nKHN0cmluZykuc3BsaXQoLy0oPyFcXFxcKS8pO1xuICAgIHZhciBhbGxSZXZlcnNlZCA9IG1hcChzcGxpdCwgcmV2ZXJzZVN0cmluZyk7XG4gICAgcmV0dXJuIG1hcChhbGxSZXZlcnNlZCwgdW5xdW90ZURhc2hlcykucmV2ZXJzZSgpO1xuICB9XG5cbiAgdmFyIHBhcmFtLCBwYXJhbVZhbDtcbiAgZm9yIChpID0gMDsgaSA8IG5QYXRoOyBpKyspIHtcbiAgICBwYXJhbU5hbWUgPSBwYXJhbU5hbWVzW2ldO1xuICAgIHBhcmFtID0gdGhpcy5wYXJhbXNbcGFyYW1OYW1lXTtcbiAgICBwYXJhbVZhbCA9IG1baSsxXTtcbiAgICAvLyBpZiB0aGUgcGFyYW0gdmFsdWUgbWF0Y2hlcyBhIHByZS1yZXBsYWNlIHBhaXIsIHJlcGxhY2UgdGhlIHZhbHVlIGJlZm9yZSBkZWNvZGluZy5cbiAgICBmb3IgKGogPSAwOyBqIDwgcGFyYW0ucmVwbGFjZS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHBhcmFtLnJlcGxhY2Vbal0uZnJvbSA9PT0gcGFyYW1WYWwpIHBhcmFtVmFsID0gcGFyYW0ucmVwbGFjZVtqXS50bztcbiAgICB9XG4gICAgaWYgKHBhcmFtVmFsICYmIHBhcmFtLmFycmF5ID09PSB0cnVlKSBwYXJhbVZhbCA9IGRlY29kZVBhdGhBcnJheShwYXJhbVZhbCk7XG4gICAgaWYgKGlzRGVmaW5lZChwYXJhbVZhbCkpIHBhcmFtVmFsID0gcGFyYW0udHlwZS5kZWNvZGUocGFyYW1WYWwpO1xuICAgIHZhbHVlc1twYXJhbU5hbWVdID0gcGFyYW0udmFsdWUocGFyYW1WYWwpO1xuICB9XG4gIGZvciAoLyoqLzsgaSA8IG5Ub3RhbDsgaSsrKSB7XG4gICAgcGFyYW1OYW1lID0gcGFyYW1OYW1lc1tpXTtcbiAgICB2YWx1ZXNbcGFyYW1OYW1lXSA9IHRoaXMucGFyYW1zW3BhcmFtTmFtZV0udmFsdWUoc2VhcmNoUGFyYW1zW3BhcmFtTmFtZV0pO1xuICAgIHBhcmFtID0gdGhpcy5wYXJhbXNbcGFyYW1OYW1lXTtcbiAgICBwYXJhbVZhbCA9IHNlYXJjaFBhcmFtc1twYXJhbU5hbWVdO1xuICAgIGZvciAoaiA9IDA7IGogPCBwYXJhbS5yZXBsYWNlLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAocGFyYW0ucmVwbGFjZVtqXS5mcm9tID09PSBwYXJhbVZhbCkgcGFyYW1WYWwgPSBwYXJhbS5yZXBsYWNlW2pdLnRvO1xuICAgIH1cbiAgICBpZiAoaXNEZWZpbmVkKHBhcmFtVmFsKSkgcGFyYW1WYWwgPSBwYXJhbS50eXBlLmRlY29kZShwYXJhbVZhbCk7XG4gICAgdmFsdWVzW3BhcmFtTmFtZV0gPSBwYXJhbS52YWx1ZShwYXJhbVZhbCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciNwYXJhbWV0ZXJzXG4gKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiBhbGwgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhpcyBwYXR0ZXJuIGluIGFuIHVuc3BlY2lmaWVkIG9yZGVyLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gIEFuIGFycmF5IG9mIHBhcmFtZXRlciBuYW1lcy4gTXVzdCBiZSB0cmVhdGVkIGFzIHJlYWQtb25seS4gSWYgdGhlXG4gKiAgICBwYXR0ZXJuIGhhcyBubyBwYXJhbWV0ZXJzLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAqL1xuVXJsTWF0Y2hlci5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICBpZiAoIWlzRGVmaW5lZChwYXJhbSkpIHJldHVybiB0aGlzLiQkcGFyYW1OYW1lcztcbiAgcmV0dXJuIHRoaXMucGFyYW1zW3BhcmFtXSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciN2YWxpZGF0ZXNcbiAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENoZWNrcyBhbiBvYmplY3QgaGFzaCBvZiBwYXJhbWV0ZXJzIHRvIHZhbGlkYXRlIHRoZWlyIGNvcnJlY3RuZXNzIGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVyXG4gKiB0eXBlcyBvZiB0aGlzIGBVcmxNYXRjaGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBvYmplY3QgaGFzaCBvZiBwYXJhbWV0ZXJzIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXJhbXNgIHZhbGlkYXRlcywgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKi9cblVybE1hdGNoZXIucHJvdG90eXBlLnZhbGlkYXRlcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgcmV0dXJuIHRoaXMucGFyYW1zLiQkdmFsaWRhdGVzKHBhcmFtcyk7XG59O1xuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyI2Zvcm1hdFxuICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIFVSTCB0aGF0IG1hdGNoZXMgdGhpcyBwYXR0ZXJuIGJ5IHN1YnN0aXR1dGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICogZm9yIHRoZSBwYXRoIGFuZCBzZWFyY2ggcGFyYW1ldGVycy4gTnVsbCB2YWx1ZXMgZm9yIHBhdGggcGFyYW1ldGVycyBhcmVcbiAqIHRyZWF0ZWQgYXMgZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAZXhhbXBsZVxuICogPHByZT5cbiAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EnKS5mb3JtYXQoeyBpZDonYm9iJywgcToneWVzJyB9KTtcbiAqIC8vIHJldHVybnMgJy91c2VyL2JvYj9xPXllcydcbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgIHRoZSB2YWx1ZXMgdG8gc3Vic3RpdHV0ZSBmb3IgdGhlIHBhcmFtZXRlcnMgaW4gdGhpcyBwYXR0ZXJuLlxuICogQHJldHVybnMge3N0cmluZ30gIHRoZSBmb3JtYXR0ZWQgVVJMIChwYXRoIGFuZCBvcHRpb25hbGx5IHNlYXJjaCBwYXJ0KS5cbiAqL1xuVXJsTWF0Y2hlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMsIHBhcmFtcyA9IHRoaXMucGFyYW1ldGVycygpLCBwYXJhbXNldCA9IHRoaXMucGFyYW1zO1xuICBpZiAoIXRoaXMudmFsaWRhdGVzKHZhbHVlcykpIHJldHVybiBudWxsO1xuXG4gIHZhciBpLCBzZWFyY2ggPSBmYWxzZSwgblBhdGggPSBzZWdtZW50cy5sZW5ndGggLSAxLCBuVG90YWwgPSBwYXJhbXMubGVuZ3RoLCByZXN1bHQgPSBzZWdtZW50c1swXTtcblxuICBmdW5jdGlvbiBlbmNvZGVEYXNoZXMoc3RyKSB7IC8vIFJlcGxhY2UgZGFzaGVzIHdpdGggZW5jb2RlZCBcIlxcLVwiXG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoLy0vZywgZnVuY3Rpb24oYykgeyByZXR1cm4gJyU1QyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9KTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBuVG90YWw7IGkrKykge1xuICAgIHZhciBpc1BhdGhQYXJhbSA9IGkgPCBuUGF0aDtcbiAgICB2YXIgbmFtZSA9IHBhcmFtc1tpXSwgcGFyYW0gPSBwYXJhbXNldFtuYW1lXSwgdmFsdWUgPSBwYXJhbS52YWx1ZSh2YWx1ZXNbbmFtZV0pO1xuICAgIHZhciBpc0RlZmF1bHRWYWx1ZSA9IHBhcmFtLmlzT3B0aW9uYWwgJiYgcGFyYW0udHlwZS5lcXVhbHMocGFyYW0udmFsdWUoKSwgdmFsdWUpO1xuICAgIHZhciBzcXVhc2ggPSBpc0RlZmF1bHRWYWx1ZSA/IHBhcmFtLnNxdWFzaCA6IGZhbHNlO1xuICAgIHZhciBlbmNvZGVkID0gcGFyYW0udHlwZS5lbmNvZGUodmFsdWUpO1xuXG4gICAgaWYgKGlzUGF0aFBhcmFtKSB7XG4gICAgICB2YXIgbmV4dFNlZ21lbnQgPSBzZWdtZW50c1tpICsgMV07XG4gICAgICB2YXIgaXNGaW5hbFBhdGhQYXJhbSA9IGkgKyAxID09PSBuUGF0aDtcblxuICAgICAgaWYgKHNxdWFzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGVuY29kZWQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KGVuY29kZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gbWFwKGVuY29kZWQsIGVuY29kZURhc2hlcykuam9pbihcIi1cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoZW5jb2RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBuZXh0U2VnbWVudDtcbiAgICAgIH0gZWxzZSBpZiAoc3F1YXNoID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBjYXB0dXJlID0gcmVzdWx0Lm1hdGNoKC9cXC8kLykgPyAvXFwvPyguKikvIDogLyguKikvO1xuICAgICAgICByZXN1bHQgKz0gbmV4dFNlZ21lbnQubWF0Y2goY2FwdHVyZSlbMV07XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHNxdWFzaCkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHNxdWFzaCArIG5leHRTZWdtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGaW5hbFBhdGhQYXJhbSAmJiBwYXJhbS5zcXVhc2ggPT09IHRydWUgJiYgcmVzdWx0LnNsaWNlKC0xKSA9PT0gJy8nKSByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZW5jb2RlZCA9PSBudWxsIHx8IChpc0RlZmF1bHRWYWx1ZSAmJiBzcXVhc2ggIT09IGZhbHNlKSkgY29udGludWU7XG4gICAgICBpZiAoIWlzQXJyYXkoZW5jb2RlZCkpIGVuY29kZWQgPSBbIGVuY29kZWQgXTtcbiAgICAgIGlmIChlbmNvZGVkLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICBlbmNvZGVkID0gbWFwKGVuY29kZWQsIGVuY29kZVVSSUNvbXBvbmVudCkuam9pbignJicgKyBuYW1lICsgJz0nKTtcbiAgICAgIHJlc3VsdCArPSAoc2VhcmNoID8gJyYnIDogJz8nKSArIChuYW1lICsgJz0nICsgZW5jb2RlZCk7XG4gICAgICBzZWFyY2ggPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIHVpLnJvdXRlci51dGlsLnR5cGU6VHlwZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSW1wbGVtZW50cyBhbiBpbnRlcmZhY2UgdG8gZGVmaW5lIGN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMgdGhhdCBjYW4gYmUgZGVjb2RlZCBmcm9tIGFuZCBlbmNvZGVkIHRvXG4gKiBzdHJpbmcgcGFyYW1ldGVycyBtYXRjaGVkIGluIGEgVVJMLiBVc2VkIGJ5IHtAbGluayB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIgYFVybE1hdGNoZXJgfVxuICogb2JqZWN0cyB3aGVuIG1hdGNoaW5nIG9yIGZvcm1hdHRpbmcgVVJMcywgb3IgY29tcGFyaW5nIG9yIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiBTZWUge0BsaW5rIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeSNtZXRob2RzX3R5cGUgYCR1cmxNYXRjaGVyRmFjdG9yeSN0eXBlKClgfSBmb3IgbW9yZVxuICogaW5mb3JtYXRpb24gb24gcmVnaXN0ZXJpbmcgY3VzdG9tIHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgIEEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGN1c3RvbSB0eXBlIGRlZmluaXRpb24uICBUaGUgb2JqZWN0J3NcbiAqICAgICAgICBwcm9wZXJ0aWVzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbWV0aG9kcyBhbmQvb3IgcGF0dGVybiBpbiBgVHlwZWAncyBwdWJsaWMgaW50ZXJmYWNlLlxuICogQGV4YW1wbGVcbiAqIDxwcmU+XG4gKiB7XG4gKiAgIGRlY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKTsgfSxcbiAqICAgZW5jb2RlOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHZhbCAmJiB2YWwudG9TdHJpbmcoKTsgfSxcbiAqICAgZXF1YWxzOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLmlzKGEpICYmIGEgPT09IGI7IH0sXG4gKiAgIGlzOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIGFuZ3VsYXIuaXNOdW1iZXIodmFsKSBpc0Zpbml0ZSh2YWwpICYmIHZhbCAlIDEgPT09IDA7IH0sXG4gKiAgIHBhdHRlcm46IC9cXGQrL1xuICogfVxuICogPC9wcmU+XG4gKlxuICogQHByb3BlcnR5IHtSZWdFeHB9IHBhdHRlcm4gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2ggdmFsdWVzIG9mIHRoaXMgdHlwZSB3aGVuXG4gKiAgICAgICAgICAgY29taW5nIGZyb20gYSBzdWJzdHJpbmcgb2YgYSBVUkwuXG4gKlxuICogQHJldHVybnMge09iamVjdH0gIFJldHVybnMgYSBuZXcgYFR5cGVgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gVHlwZShjb25maWcpIHtcbiAgZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG59XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlR5cGUjaXNcbiAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC50eXBlOlR5cGVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERldGVjdHMgd2hldGhlciBhIHZhbHVlIGlzIG9mIGEgcGFydGljdWxhciB0eXBlLiBBY2NlcHRzIGEgbmF0aXZlIChkZWNvZGVkKSB2YWx1ZVxuICogYW5kIGRldGVybWluZXMgd2hldGhlciBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGBUeXBlYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgIE9wdGlvbmFsLiBJZiB0aGUgdHlwZSBjaGVjayBpcyBoYXBwZW5pbmcgaW4gdGhlIGNvbnRleHQgb2YgYSBzcGVjaWZpY1xuICogICAgICAgIHtAbGluayB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIgYFVybE1hdGNoZXJgfSBvYmplY3QsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlXG4gKiAgICAgICAgcGFyYW1ldGVyIGluIHdoaWNoIGB2YWxgIGlzIHN0b3JlZC4gQ2FuIGJlIHVzZWQgZm9yIG1ldGEtcHJvZ3JhbW1pbmcgb2YgYFR5cGVgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gIFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBtYXRjaGVzIHRoZSB0eXBlLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuVHlwZS5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbih2YWwsIGtleSkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlR5cGUjZW5jb2RlXG4gKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBFbmNvZGVzIGEgY3VzdG9tL25hdGl2ZSB0eXBlIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGVtYmVkZGVkIGluIGEgVVJMLiBOb3RlIHRoYXQgdGhlXG4gKiByZXR1cm4gdmFsdWUgZG9lcyAqbm90KiBuZWVkIHRvIGJlIFVSTC1zYWZlIChpLmUuIHBhc3NlZCB0aHJvdWdoIGBlbmNvZGVVUklDb21wb25lbnQoKWApLCBpdFxuICogb25seSBuZWVkcyB0byBiZSBhIHJlcHJlc2VudGF0aW9uIG9mIGB2YWxgIHRoYXQgaGFzIGJlZW4gY29lcmNlZCB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCAgVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gd2hpY2ggYHZhbGAgaXMgc3RvcmVkLiBDYW4gYmUgdXNlZCBmb3JcbiAqICAgICAgICBtZXRhLXByb2dyYW1taW5nIG9mIGBUeXBlYCBvYmplY3RzLlxuICogQHJldHVybnMge3N0cmluZ30gIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHZhbGAgdGhhdCBjYW4gYmUgZW5jb2RlZCBpbiBhIFVSTC5cbiAqL1xuVHlwZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlR5cGUjZGVjb2RlXG4gKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0cyBhIHBhcmFtZXRlciB2YWx1ZSAoZnJvbSBVUkwgc3RyaW5nIG9yIHRyYW5zaXRpb24gcGFyYW0pIHRvIGEgY3VzdG9tL25hdGl2ZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsICBUaGUgVVJMIHBhcmFtZXRlciB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5ICBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHdoaWNoIGB2YWxgIGlzIHN0b3JlZC4gQ2FuIGJlIHVzZWQgZm9yXG4gKiAgICAgICAgbWV0YS1wcm9ncmFtbWluZyBvZiBgVHlwZWAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHsqfSAgUmV0dXJucyBhIGN1c3RvbSByZXByZXNlbnRhdGlvbiBvZiB0aGUgVVJMIHBhcmFtZXRlciB2YWx1ZS5cbiAqL1xuVHlwZS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlR5cGUjZXF1YWxzXG4gKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIGRlY29kZWQgdmFsdWVzIGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gYSAgQSB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gKiBAcGFyYW0geyp9IGIgIEEgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59ICBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50L2VxdWFsLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuVHlwZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9PSBiO1xufTtcblxuVHlwZS5wcm90b3R5cGUuJHN1YlBhdHRlcm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YiA9IHRoaXMucGF0dGVybi50b1N0cmluZygpO1xuICByZXR1cm4gc3ViLnN1YnN0cigxLCBzdWIubGVuZ3RoIC0gMik7XG59O1xuXG5UeXBlLnByb3RvdHlwZS5wYXR0ZXJuID0gLy4qLztcblxuVHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwie1R5cGU6XCIgKyB0aGlzLm5hbWUgKyBcIn1cIjsgfTtcblxuLyoqIEdpdmVuIGFuIGVuY29kZWQgc3RyaW5nLCBvciBhIGRlY29kZWQgb2JqZWN0LCByZXR1cm5zIGEgZGVjb2RlZCBvYmplY3QgKi9cblR5cGUucHJvdG90eXBlLiRub3JtYWxpemUgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRoaXMuaXModmFsKSA/IHZhbCA6IHRoaXMuZGVjb2RlKHZhbCk7XG59O1xuXG4vKlxuICogV3JhcHMgYW4gZXhpc3RpbmcgY3VzdG9tIFR5cGUgYXMgYW4gYXJyYXkgb2YgVHlwZSwgZGVwZW5kaW5nIG9uICdtb2RlJy5cbiAqIGUuZy46XG4gKiAtIHVybG1hdGNoZXIgcGF0dGVybiBcIi9wYXRoP3txdWVyeVBhcmFtW106aW50fVwiXG4gKiAtIHVybDogXCIvcGF0aD9xdWVyeVBhcmFtPTEmcXVlcnlQYXJhbT0yXG4gKiAtICRzdGF0ZVBhcmFtcy5xdWVyeVBhcmFtIHdpbGwgYmUgWzEsIDJdXG4gKiBpZiBgbW9kZWAgaXMgXCJhdXRvXCIsIHRoZW5cbiAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogMVxuICogLSB1cmw6IFwiL3BhdGg/cXVlcnlQYXJhbT0xJnF1ZXJ5UGFyYW09MiB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogWzEsIDJdXG4gKi9cblR5cGUucHJvdG90eXBlLiRhc0FycmF5ID0gZnVuY3Rpb24obW9kZSwgaXNTZWFyY2gpIHtcbiAgaWYgKCFtb2RlKSByZXR1cm4gdGhpcztcbiAgaWYgKG1vZGUgPT09IFwiYXV0b1wiICYmICFpc1NlYXJjaCkgdGhyb3cgbmV3IEVycm9yKFwiJ2F1dG8nIGFycmF5IG1vZGUgaXMgZm9yIHF1ZXJ5IHBhcmFtZXRlcnMgb25seVwiKTtcblxuICBmdW5jdGlvbiBBcnJheVR5cGUodHlwZSwgbW9kZSkge1xuICAgIGZ1bmN0aW9uIGJpbmRUbyh0eXBlLCBjYWxsYmFja05hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVbY2FsbGJhY2tOYW1lXS5hcHBseSh0eXBlLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBXcmFwIG5vbi1hcnJheSB2YWx1ZSBhcyBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5V3JhcCh2YWwpIHsgcmV0dXJuIGlzQXJyYXkodmFsKSA/IHZhbCA6IChpc0RlZmluZWQodmFsKSA/IFsgdmFsIF0gOiBbXSk7IH1cbiAgICAvLyBVbndyYXAgYXJyYXkgdmFsdWUgZm9yIFwiYXV0b1wiIG1vZGUuIFJldHVybiB1bmRlZmluZWQgZm9yIGVtcHR5IGFycmF5LlxuICAgIGZ1bmN0aW9uIGFycmF5VW53cmFwKHZhbCkge1xuICAgICAgc3dpdGNoKHZhbC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBtb2RlID09PSBcImF1dG9cIiA/IHZhbFswXSA6IHZhbDtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmFsc2V5KHZhbCkgeyByZXR1cm4gIXZhbDsgfVxuXG4gICAgLy8gV3JhcHMgdHlwZSAoLmlzLy5lbmNvZGUvLmRlY29kZSkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5SGFuZGxlcihjYWxsYmFjaywgYWxsVHJ1dGh5TW9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbCkge1xuICAgICAgICBpZiAoaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDApIHJldHVybiB2YWw7XG4gICAgICAgIHZhbCA9IGFycmF5V3JhcCh2YWwpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbWFwKHZhbCwgY2FsbGJhY2spO1xuICAgICAgICBpZiAoYWxsVHJ1dGh5TW9kZSA9PT0gdHJ1ZSlcbiAgICAgICAgICByZXR1cm4gZmlsdGVyKHJlc3VsdCwgZmFsc2V5KS5sZW5ndGggPT09IDA7XG4gICAgICAgIHJldHVybiBhcnJheVVud3JhcChyZXN1bHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBXcmFwcyB0eXBlICguZXF1YWxzKSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiBlYWNoIHZhbHVlIG9mIGFuIGFycmF5XG4gICAgZnVuY3Rpb24gYXJyYXlFcXVhbHNIYW5kbGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsMSwgdmFsMikge1xuICAgICAgICB2YXIgbGVmdCA9IGFycmF5V3JhcCh2YWwxKSwgcmlnaHQgPSBhcnJheVdyYXAodmFsMik7XG4gICAgICAgIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghY2FsbGJhY2sobGVmdFtpXSwgcmlnaHRbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuZW5jb2RlID0gYXJyYXlIYW5kbGVyKGJpbmRUbyh0eXBlLCAnZW5jb2RlJykpO1xuICAgIHRoaXMuZGVjb2RlID0gYXJyYXlIYW5kbGVyKGJpbmRUbyh0eXBlLCAnZGVjb2RlJykpO1xuICAgIHRoaXMuaXMgICAgID0gYXJyYXlIYW5kbGVyKGJpbmRUbyh0eXBlLCAnaXMnKSwgdHJ1ZSk7XG4gICAgdGhpcy5lcXVhbHMgPSBhcnJheUVxdWFsc0hhbmRsZXIoYmluZFRvKHR5cGUsICdlcXVhbHMnKSk7XG4gICAgdGhpcy5wYXR0ZXJuID0gdHlwZS5wYXR0ZXJuO1xuICAgIHRoaXMuJG5vcm1hbGl6ZSA9IGFycmF5SGFuZGxlcihiaW5kVG8odHlwZSwgJyRub3JtYWxpemUnKSk7XG4gICAgdGhpcy5uYW1lID0gdHlwZS5uYW1lO1xuICAgIHRoaXMuJGFycmF5TW9kZSA9IG1vZGU7XG4gIH1cblxuICByZXR1cm4gbmV3IEFycmF5VHlwZSh0aGlzLCBtb2RlKTtcbn07XG5cblxuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRmFjdG9yeSBmb3Ige0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBgVXJsTWF0Y2hlcmB9IGluc3RhbmNlcy4gVGhlIGZhY3RvcnlcbiAqIGlzIGFsc28gYXZhaWxhYmxlIHRvIHByb3ZpZGVycyB1bmRlciB0aGUgbmFtZSBgJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXJgLlxuICovXG5mdW5jdGlvbiAkVXJsTWF0Y2hlckZhY3RvcnkoKSB7XG4gICQkVU1GUCA9IHRoaXM7XG5cbiAgdmFyIGlzQ2FzZUluc2Vuc2l0aXZlID0gZmFsc2UsIGlzU3RyaWN0TW9kZSA9IHRydWUsIGRlZmF1bHRTcXVhc2hQb2xpY3kgPSBmYWxzZTtcblxuICAvLyBVc2UgdGlsZGVzIHRvIHByZS1lbmNvZGUgc2xhc2hlcy5cbiAgLy8gSWYgdGhlIHNsYXNoZXMgYXJlIHNpbXBseSBVUkxFbmNvZGVkLCB0aGUgYnJvd3NlciBjYW4gY2hvb3NlIHRvIHByZS1kZWNvZGUgdGhlbSxcbiAgLy8gYW5kIGJpZGlyZWN0aW9uYWwgZW5jb2RpbmcvZGVjb2RpbmcgZmFpbHMuXG4gIC8vIFRpbGRlIHdhcyBjaG9zZW4gYmVjYXVzZSBpdCdzIG5vdCBhIFJGQyAzOTg2IHNlY3Rpb24gMi4yIFJlc2VydmVkIENoYXJhY3RlclxuICBmdW5jdGlvbiB2YWxUb1N0cmluZyh2YWwpIHsgcmV0dXJuIHZhbCAhPSBudWxsID8gdmFsLnRvU3RyaW5nKCkucmVwbGFjZSgvKH58XFwvKS9nLCBmdW5jdGlvbiAobSkgeyByZXR1cm4geyd+Jzonfn4nLCAnLyc6J34yRid9W21dOyB9KSA6IHZhbDsgfVxuICBmdW5jdGlvbiB2YWxGcm9tU3RyaW5nKHZhbCkgeyByZXR1cm4gdmFsICE9IG51bGwgPyB2YWwudG9TdHJpbmcoKS5yZXBsYWNlKC8ofn58fjJGKS9nLCBmdW5jdGlvbiAobSkgeyByZXR1cm4geyd+fic6J34nLCAnfjJGJzonLyd9W21dOyB9KSA6IHZhbDsgfVxuXG4gIHZhciAkdHlwZXMgPSB7fSwgZW5xdWV1ZSA9IHRydWUsIHR5cGVRdWV1ZSA9IFtdLCBpbmplY3RvciwgZGVmYXVsdFR5cGVzID0ge1xuICAgIFwic3RyaW5nXCI6IHtcbiAgICAgIGVuY29kZTogdmFsVG9TdHJpbmcsXG4gICAgICBkZWNvZGU6IHZhbEZyb21TdHJpbmcsXG4gICAgICAvLyBUT0RPOiBpbiAxLjAsIG1ha2Ugc3RyaW5nIC5pcygpIHJldHVybiBmYWxzZSBpZiB2YWx1ZSBpcyB1bmRlZmluZWQvbnVsbCBieSBkZWZhdWx0LlxuICAgICAgLy8gSW4gMC4yLngsIHN0cmluZyBwYXJhbXMgYXJlIG9wdGlvbmFsIGJ5IGRlZmF1bHQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICAgIGlzOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHZhbCA9PSBudWxsIHx8ICFpc0RlZmluZWQodmFsKSB8fCB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiOyB9LFxuICAgICAgcGF0dGVybjogL1teL10qL1xuICAgIH0sXG4gICAgXCJpbnRcIjoge1xuICAgICAgZW5jb2RlOiB2YWxUb1N0cmluZyxcbiAgICAgIGRlY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKTsgfSxcbiAgICAgIGlzOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIGlzRGVmaW5lZCh2YWwpICYmIHRoaXMuZGVjb2RlKHZhbC50b1N0cmluZygpKSA9PT0gdmFsOyB9LFxuICAgICAgcGF0dGVybjogL1xcZCsvXG4gICAgfSxcbiAgICBcImJvb2xcIjoge1xuICAgICAgZW5jb2RlOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHZhbCA/IDEgOiAwOyB9LFxuICAgICAgZGVjb2RlOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApICE9PSAwOyB9LFxuICAgICAgaXM6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2U7IH0sXG4gICAgICBwYXR0ZXJuOiAvMHwxL1xuICAgIH0sXG4gICAgXCJkYXRlXCI6IHtcbiAgICAgIGVuY29kZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAoIXRoaXMuaXModmFsKSlcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gWyB2YWwuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAoJzAnICsgKHZhbC5nZXRNb250aCgpICsgMSkpLnNsaWNlKC0yKSxcbiAgICAgICAgICAoJzAnICsgdmFsLmdldERhdGUoKSkuc2xpY2UoLTIpXG4gICAgICAgIF0uam9pbihcIi1cIik7XG4gICAgICB9LFxuICAgICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzKHZhbCkpIHJldHVybiB2YWw7XG4gICAgICAgIHZhciBtYXRjaCA9IHRoaXMuY2FwdHVyZS5leGVjKHZhbCk7XG4gICAgICAgIHJldHVybiBtYXRjaCA/IG5ldyBEYXRlKG1hdGNoWzFdLCBtYXRjaFsyXSAtIDEsIG1hdGNoWzNdKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBpczogZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWwudmFsdWVPZigpKTsgfSxcbiAgICAgIGVxdWFsczogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHRoaXMuaXMoYSkgJiYgdGhpcy5pcyhiKSAmJiBhLnRvSVNPU3RyaW5nKCkgPT09IGIudG9JU09TdHJpbmcoKTsgfSxcbiAgICAgIHBhdHRlcm46IC9bMC05XXs0fS0oPzowWzEtOV18MVswLTJdKS0oPzowWzEtOV18WzEtMl1bMC05XXwzWzAtMV0pLyxcbiAgICAgIGNhcHR1cmU6IC8oWzAtOV17NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS9cbiAgICB9LFxuICAgIFwianNvblwiOiB7XG4gICAgICBlbmNvZGU6IGFuZ3VsYXIudG9Kc29uLFxuICAgICAgZGVjb2RlOiBhbmd1bGFyLmZyb21Kc29uLFxuICAgICAgaXM6IGFuZ3VsYXIuaXNPYmplY3QsXG4gICAgICBlcXVhbHM6IGFuZ3VsYXIuZXF1YWxzLFxuICAgICAgcGF0dGVybjogL1teL10qL1xuICAgIH0sXG4gICAgXCJhbnlcIjogeyAvLyBkb2VzIG5vdCBlbmNvZGUvZGVjb2RlXG4gICAgICBlbmNvZGU6IGFuZ3VsYXIuaWRlbnRpdHksXG4gICAgICBkZWNvZGU6IGFuZ3VsYXIuaWRlbnRpdHksXG4gICAgICBlcXVhbHM6IGFuZ3VsYXIuZXF1YWxzLFxuICAgICAgcGF0dGVybjogLy4qL1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpY3Q6IGlzU3RyaWN0TW9kZSxcbiAgICAgIGNhc2VJbnNlbnNpdGl2ZTogaXNDYXNlSW5zZW5zaXRpdmVcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJbmplY3RhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCAoaXNBcnJheSh2YWx1ZSkgJiYgaXNGdW5jdGlvbih2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbSW50ZXJuYWxdIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHBhcmFtZXRlciwgd2hpY2ggbWF5IGJlIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXG4gICAqL1xuICAkVXJsTWF0Y2hlckZhY3RvcnkuJCRnZXREZWZhdWx0VmFsdWUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICBpZiAoIWlzSW5qZWN0YWJsZShjb25maWcudmFsdWUpKSByZXR1cm4gY29uZmlnLnZhbHVlO1xuICAgIGlmICghaW5qZWN0b3IpIHRocm93IG5ldyBFcnJvcihcIkluamVjdGFibGUgZnVuY3Rpb25zIGNhbm5vdCBiZSBjYWxsZWQgYXQgY29uZmlndXJhdGlvbiB0aW1lXCIpO1xuICAgIHJldHVybiBpbmplY3Rvci5pbnZva2UoY29uZmlnLnZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeSNjYXNlSW5zZW5zaXRpdmVcbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRGVmaW5lcyB3aGV0aGVyIFVSTCBtYXRjaGluZyBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUgKHRoZSBkZWZhdWx0IGJlaGF2aW9yKSwgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIGBmYWxzZWAgdG8gbWF0Y2ggVVJMIGluIGEgY2FzZSBzZW5zaXRpdmUgbWFubmVyOyBvdGhlcndpc2UgYHRydWVgO1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGhlIGN1cnJlbnQgdmFsdWUgb2YgY2FzZUluc2Vuc2l0aXZlXG4gICAqL1xuICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpXG4gICAgICBpc0Nhc2VJbnNlbnNpdGl2ZSA9IHZhbHVlO1xuICAgIHJldHVybiBpc0Nhc2VJbnNlbnNpdGl2ZTtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeSNzdHJpY3RNb2RlXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgd2hldGhlciBVUkxzIHNob3VsZCBtYXRjaCB0cmFpbGluZyBzbGFzaGVzLCBvciBub3QgKHRoZSBkZWZhdWx0IGJlaGF2aW9yKS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdmFsdWUgYGZhbHNlYCB0byBtYXRjaCB0cmFpbGluZyBzbGFzaGVzIGluIFVSTHMsIG90aGVyd2lzZSBgdHJ1ZWAuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0aGUgY3VycmVudCB2YWx1ZSBvZiBzdHJpY3RNb2RlXG4gICAqL1xuICB0aGlzLnN0cmljdE1vZGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmIChpc0RlZmluZWQodmFsdWUpKVxuICAgICAgaXNTdHJpY3RNb2RlID0gdmFsdWU7XG4gICAgcmV0dXJuIGlzU3RyaWN0TW9kZTtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeSNkZWZhdWx0U3F1YXNoUG9saWN5XG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiBnZW5lcmF0aW5nIG9yIG1hdGNoaW5nIFVSTHMgd2l0aCBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIGRlZmF1bHQgcGFyYW1ldGVyIFVSTCBzcXVhc2hpbmcgYmVoYXZpb3IuXG4gICAqICAgIGBub3NxdWFzaGA6IFdoZW4gZ2VuZXJhdGluZyBhbiBocmVmIHdpdGggYSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSwgZG8gbm90IHNxdWFzaCB0aGUgcGFyYW1ldGVyIHZhbHVlIGZyb20gdGhlIFVSTFxuICAgKiAgICBgc2xhc2hgOiBXaGVuIGdlbmVyYXRpbmcgYW4gaHJlZiB3aXRoIGEgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUsIHNxdWFzaCAocmVtb3ZlKSB0aGUgcGFyYW1ldGVyIHZhbHVlLCBhbmQsIGlmIHRoZVxuICAgKiAgICAgICAgICAgICBwYXJhbWV0ZXIgaXMgc3Vycm91bmRlZCBieSBzbGFzaGVzLCBzcXVhc2ggKHJlbW92ZSkgb25lIHNsYXNoIGZyb20gdGhlIFVSTFxuICAgKiAgICBhbnkgb3RoZXIgc3RyaW5nLCBlLmcuIFwiflwiOiBXaGVuIGdlbmVyYXRpbmcgYW4gaHJlZiB3aXRoIGEgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUsIHNxdWFzaCAocmVtb3ZlKVxuICAgKiAgICAgICAgICAgICB0aGUgcGFyYW1ldGVyIHZhbHVlIGZyb20gdGhlIFVSTCBhbmQgcmVwbGFjZSBpdCB3aXRoIHRoaXMgc3RyaW5nLlxuICAgKi9cbiAgdGhpcy5kZWZhdWx0U3F1YXNoUG9saWN5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHJldHVybiBkZWZhdWx0U3F1YXNoUG9saWN5O1xuICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSAmJiB2YWx1ZSAhPT0gZmFsc2UgJiYgIWlzU3RyaW5nKHZhbHVlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3F1YXNoIHBvbGljeTogXCIgKyB2YWx1ZSArIFwiLiBWYWxpZCBwb2xpY2llczogZmFsc2UsIHRydWUsIGFyYml0cmFyeS1zdHJpbmdcIik7XG4gICAgZGVmYXVsdFNxdWFzaFBvbGljeSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeSNjb21waWxlXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENyZWF0ZXMgYSB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyIGBVcmxNYXRjaGVyYH0gZm9yIHRoZSBzcGVjaWZpZWQgcGF0dGVybi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gIFRoZSBVUkwgcGF0dGVybi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgVGhlIGNvbmZpZyBvYmplY3QgaGFzaC5cbiAgICogQHJldHVybnMge1VybE1hdGNoZXJ9ICBUaGUgVXJsTWF0Y2hlci5cbiAgICovXG4gIHRoaXMuY29tcGlsZSA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IFVybE1hdGNoZXIocGF0dGVybiwgZXh0ZW5kKGdldERlZmF1bHRDb25maWcoKSwgY29uZmlnKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnkjaXNNYXRjaGVyXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIGBVcmxNYXRjaGVyYCwgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICBUaGUgb2JqZWN0IHRvIHBlcmZvcm0gdGhlIHR5cGUgY2hlY2sgYWdhaW5zdC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59ICBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IG1hdGNoZXMgdGhlIGBVcmxNYXRjaGVyYCBpbnRlcmZhY2UsIGJ5XG4gICAqICAgICAgICAgIGltcGxlbWVudGluZyBhbGwgdGhlIHNhbWUgbWV0aG9kcy5cbiAgICovXG4gIHRoaXMuaXNNYXRjaGVyID0gZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KG8pKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG5cbiAgICBmb3JFYWNoKFVybE1hdGNoZXIucHJvdG90eXBlLCBmdW5jdGlvbih2YWwsIG5hbWUpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIChpc0RlZmluZWQob1tuYW1lXSkgJiYgaXNGdW5jdGlvbihvW25hbWVdKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeSN0eXBlXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJlZ2lzdGVycyBhIGN1c3RvbSB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlIGBUeXBlYH0gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG9cbiAgICogZ2VuZXJhdGUgVVJMcyB3aXRoIHR5cGVkIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICBUaGUgdHlwZSBuYW1lLlxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gZGVmaW5pdGlvbiAgIFRoZSB0eXBlIGRlZmluaXRpb24uIFNlZVxuICAgKiAgICAgICAge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VHlwZSBgVHlwZWB9IGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgdmFsdWVzIGFjY2VwdGVkLlxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gZGVmaW5pdGlvbkZuIChvcHRpb25hbCkgQSBmdW5jdGlvbiB0aGF0IGlzIGluamVjdGVkIGJlZm9yZSB0aGUgYXBwXG4gICAqICAgICAgICBydW50aW1lIHN0YXJ0cy4gIFRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbiBpcyBtZXJnZWQgaW50byB0aGUgZXhpc3RpbmcgYGRlZmluaXRpb25gLlxuICAgKiAgICAgICAgU2VlIHtAbGluayB1aS5yb3V0ZXIudXRpbC50eXBlOlR5cGUgYFR5cGVgfSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIHZhbHVlcyBhY2NlcHRlZC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gIFJldHVybnMgYCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogVGhpcyBpcyBhIHNpbXBsZSBleGFtcGxlIG9mIGEgY3VzdG9tIHR5cGUgdGhhdCBlbmNvZGVzIGFuZCBkZWNvZGVzIGl0ZW1zIGZyb20gYW5cbiAgICogYXJyYXksIHVzaW5nIHRoZSBhcnJheSBpbmRleCBhcyB0aGUgVVJMLWVuY29kZWQgdmFsdWU6XG4gICAqXG4gICAqIDxwcmU+XG4gICAqIHZhciBsaXN0ID0gWydKb2huJywgJ1BhdWwnLCAnR2VvcmdlJywgJ1JpbmdvJ107XG4gICAqXG4gICAqICR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLnR5cGUoJ2xpc3RJdGVtJywge1xuICAgKiAgIGVuY29kZTogZnVuY3Rpb24oaXRlbSkge1xuICAgKiAgICAgLy8gUmVwcmVzZW50IHRoZSBsaXN0IGl0ZW0gaW4gdGhlIFVSTCB1c2luZyBpdHMgY29ycmVzcG9uZGluZyBpbmRleFxuICAgKiAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihpdGVtKTtcbiAgICogICB9LFxuICAgKiAgIGRlY29kZTogZnVuY3Rpb24oaXRlbSkge1xuICAgKiAgICAgLy8gTG9vayB1cCB0aGUgbGlzdCBpdGVtIGJ5IGluZGV4XG4gICAqICAgICByZXR1cm4gbGlzdFtwYXJzZUludChpdGVtLCAxMCldO1xuICAgKiAgIH0sXG4gICAqICAgaXM6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICogICAgIC8vIEVuc3VyZSB0aGUgaXRlbSBpcyB2YWxpZCBieSBjaGVja2luZyB0byBzZWUgdGhhdCBpdCBhcHBlYXJzXG4gICAqICAgICAvLyBpbiB0aGUgbGlzdFxuICAgKiAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihpdGVtKSA+IC0xO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKCdsaXN0Jywge1xuICAgKiAgIHVybDogXCIvbGlzdC97aXRlbTpsaXN0SXRlbX1cIixcbiAgICogICBjb250cm9sbGVyOiBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcykge1xuICAgKiAgICAgY29uc29sZS5sb2coJHN0YXRlUGFyYW1zLml0ZW0pO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIC8vIC4uLlxuICAgKlxuICAgKiAvLyBDaGFuZ2VzIFVSTCB0byAnL2xpc3QvMycsIGxvZ3MgXCJSaW5nb1wiIHRvIHRoZSBjb25zb2xlXG4gICAqICRzdGF0ZS5nbygnbGlzdCcsIHsgaXRlbTogXCJSaW5nb1wiIH0pO1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogVGhpcyBpcyBhIG1vcmUgY29tcGxleCBleGFtcGxlIG9mIGEgdHlwZSB0aGF0IHJlbGllcyBvbiBkZXBlbmRlbmN5IGluamVjdGlvbiB0b1xuICAgKiBpbnRlcmFjdCB3aXRoIHNlcnZpY2VzLCBhbmQgdXNlcyB0aGUgcGFyYW1ldGVyIG5hbWUgZnJvbSB0aGUgVVJMIHRvIGluZmVyIGhvdyB0b1xuICAgKiBoYW5kbGUgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHBhcmFtZXRlciB2YWx1ZXM6XG4gICAqXG4gICAqIDxwcmU+XG4gICAqIC8vIERlZmluZXMgYSBjdXN0b20gdHlwZSB0aGF0IGdldHMgYSB2YWx1ZSBmcm9tIGEgc2VydmljZSxcbiAgICogLy8gd2hlcmUgZWFjaCBzZXJ2aWNlIGdldHMgZGlmZmVyZW50IHR5cGVzIG9mIHZhbHVlcyBmcm9tXG4gICAqIC8vIGEgYmFja2VuZCBBUEk6XG4gICAqICR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLnR5cGUoJ2RiT2JqZWN0Jywge30sIGZ1bmN0aW9uKFVzZXJzLCBQb3N0cykge1xuICAgKlxuICAgKiAgIC8vIE1hdGNoZXMgdXAgc2VydmljZXMgdG8gVVJMIHBhcmFtZXRlciBuYW1lc1xuICAgKiAgIHZhciBzZXJ2aWNlcyA9IHtcbiAgICogICAgIHVzZXI6IFVzZXJzLFxuICAgKiAgICAgcG9zdDogUG9zdHNcbiAgICogICB9O1xuICAgKlxuICAgKiAgIHJldHVybiB7XG4gICAqICAgICBlbmNvZGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgKiAgICAgICAvLyBSZXByZXNlbnQgdGhlIG9iamVjdCBpbiB0aGUgVVJMIHVzaW5nIGl0cyB1bmlxdWUgSURcbiAgICogICAgICAgcmV0dXJuIG9iamVjdC5pZDtcbiAgICogICAgIH0sXG4gICAqICAgICBkZWNvZGU6IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICogICAgICAgLy8gTG9vayB1cCB0aGUgb2JqZWN0IGJ5IElELCB1c2luZyB0aGUgcGFyYW1ldGVyXG4gICAqICAgICAgIC8vIG5hbWUgKGtleSkgdG8gY2FsbCB0aGUgY29ycmVjdCBzZXJ2aWNlXG4gICAqICAgICAgIHJldHVybiBzZXJ2aWNlc1trZXldLmZpbmRCeUlkKHZhbHVlKTtcbiAgICogICAgIH0sXG4gICAqICAgICBpczogZnVuY3Rpb24ob2JqZWN0LCBrZXkpIHtcbiAgICogICAgICAgLy8gQ2hlY2sgdGhhdCBvYmplY3QgaXMgYSB2YWxpZCBkYk9iamVjdFxuICAgKiAgICAgICByZXR1cm4gYW5ndWxhci5pc09iamVjdChvYmplY3QpICYmIG9iamVjdC5pZCAmJiBzZXJ2aWNlc1trZXldO1xuICAgKiAgICAgfVxuICAgKiAgICAgZXF1YWxzOiBmdW5jdGlvbihhLCBiKSB7XG4gICAqICAgICAgIC8vIENoZWNrIHRoZSBlcXVhbGl0eSBvZiBkZWNvZGVkIG9iamVjdHMgYnkgY29tcGFyaW5nXG4gICAqICAgICAgIC8vIHRoZWlyIHVuaXF1ZSBJRHNcbiAgICogICAgICAgcmV0dXJuIGEuaWQgPT09IGIuaWQ7XG4gICAqICAgICB9XG4gICAqICAgfTtcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIEluIGEgY29uZmlnKCkgYmxvY2ssIHlvdSBjYW4gdGhlbiBhdHRhY2ggVVJMcyB3aXRoXG4gICAqIC8vIHR5cGUtYW5ub3RhdGVkIHBhcmFtZXRlcnM6XG4gICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKCd1c2VycycsIHtcbiAgICogICB1cmw6IFwiL3VzZXJzXCIsXG4gICAqICAgLy8gLi4uXG4gICAqIH0pLnN0YXRlKCd1c2Vycy5pdGVtJywge1xuICAgKiAgIHVybDogXCIve3VzZXI6ZGJPYmplY3R9XCIsXG4gICAqICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMpIHtcbiAgICogICAgIC8vICRzdGF0ZVBhcmFtcy51c2VyIHdpbGwgbm93IGJlIGFuIG9iamVjdCByZXR1cm5lZCBmcm9tXG4gICAqICAgICAvLyB0aGUgVXNlcnMgc2VydmljZVxuICAgKiAgIH0sXG4gICAqICAgLy8gLi4uXG4gICAqIH0pO1xuICAgKiA8L3ByZT5cbiAgICovXG4gIHRoaXMudHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uRm4pIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkZWZpbml0aW9uKSkgcmV0dXJuICR0eXBlc1tuYW1lXTtcbiAgICBpZiAoJHR5cGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJBIHR5cGUgbmFtZWQgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXCIpO1xuXG4gICAgJHR5cGVzW25hbWVdID0gbmV3IFR5cGUoZXh0ZW5kKHsgbmFtZTogbmFtZSB9LCBkZWZpbml0aW9uKSk7XG4gICAgaWYgKGRlZmluaXRpb25Gbikge1xuICAgICAgdHlwZVF1ZXVlLnB1c2goeyBuYW1lOiBuYW1lLCBkZWY6IGRlZmluaXRpb25GbiB9KTtcbiAgICAgIGlmICghZW5xdWV1ZSkgZmx1c2hUeXBlUXVldWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gYGZsdXNoVHlwZVF1ZXVlKClgIHdhaXRzIHVudGlsIGAkdXJsTWF0Y2hlckZhY3RvcnlgIGlzIGluamVjdGVkIGJlZm9yZSBpbnZva2luZyB0aGUgcXVldWVkIGBkZWZpbml0aW9uRm5gc1xuICBmdW5jdGlvbiBmbHVzaFR5cGVRdWV1ZSgpIHtcbiAgICB3aGlsZSh0eXBlUXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVRdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKHR5cGUucGF0dGVybikgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBvdmVycmlkZSBhIHR5cGUncyAucGF0dGVybiBhdCBydW50aW1lLlwiKTtcbiAgICAgIGFuZ3VsYXIuZXh0ZW5kKCR0eXBlc1t0eXBlLm5hbWVdLCBpbmplY3Rvci5pbnZva2UodHlwZS5kZWYpKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlciBkZWZhdWx0IHR5cGVzLiBTdG9yZSB0aGVtIGluIHRoZSBwcm90b3R5cGUgb2YgJHR5cGVzLlxuICBmb3JFYWNoKGRlZmF1bHRUeXBlcywgZnVuY3Rpb24odHlwZSwgbmFtZSkgeyAkdHlwZXNbbmFtZV0gPSBuZXcgVHlwZShleHRlbmQoe25hbWU6IG5hbWV9LCB0eXBlKSk7IH0pO1xuICAkdHlwZXMgPSBpbmhlcml0KCR0eXBlcywge30pO1xuXG4gIC8qIE5vIG5lZWQgdG8gZG9jdW1lbnQgJGdldCwgc2luY2UgaXQgcmV0dXJucyB0aGlzICovXG4gIHRoaXMuJGdldCA9IFsnJGluamVjdG9yJywgZnVuY3Rpb24gKCRpbmplY3Rvcikge1xuICAgIGluamVjdG9yID0gJGluamVjdG9yO1xuICAgIGVucXVldWUgPSBmYWxzZTtcbiAgICBmbHVzaFR5cGVRdWV1ZSgpO1xuXG4gICAgZm9yRWFjaChkZWZhdWx0VHlwZXMsIGZ1bmN0aW9uKHR5cGUsIG5hbWUpIHtcbiAgICAgIGlmICghJHR5cGVzW25hbWVdKSAkdHlwZXNbbmFtZV0gPSBuZXcgVHlwZSh0eXBlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfV07XG5cbiAgdGhpcy5QYXJhbSA9IGZ1bmN0aW9uIFBhcmFtKGlkLCB0eXBlLCBjb25maWcsIGxvY2F0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGNvbmZpZyA9IHVud3JhcFNob3J0aGFuZChjb25maWcpO1xuICAgIHR5cGUgPSBnZXRUeXBlKGNvbmZpZywgdHlwZSwgbG9jYXRpb24pO1xuICAgIHZhciBhcnJheU1vZGUgPSBnZXRBcnJheU1vZGUoKTtcbiAgICB0eXBlID0gYXJyYXlNb2RlID8gdHlwZS4kYXNBcnJheShhcnJheU1vZGUsIGxvY2F0aW9uID09PSBcInNlYXJjaFwiKSA6IHR5cGU7XG4gICAgaWYgKHR5cGUubmFtZSA9PT0gXCJzdHJpbmdcIiAmJiAhYXJyYXlNb2RlICYmIGxvY2F0aW9uID09PSBcInBhdGhcIiAmJiBjb25maWcudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgIGNvbmZpZy52YWx1ZSA9IFwiXCI7IC8vIGZvciAwLjIueDsgaW4gMC4zLjArIGRvIG5vdCBhdXRvbWF0aWNhbGx5IGRlZmF1bHQgdG8gXCJcIlxuICAgIHZhciBpc09wdGlvbmFsID0gY29uZmlnLnZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHNxdWFzaCA9IGdldFNxdWFzaFBvbGljeShjb25maWcsIGlzT3B0aW9uYWwpO1xuICAgIHZhciByZXBsYWNlID0gZ2V0UmVwbGFjZShjb25maWcsIGFycmF5TW9kZSwgaXNPcHRpb25hbCwgc3F1YXNoKTtcblxuICAgIGZ1bmN0aW9uIHVud3JhcFNob3J0aGFuZChjb25maWcpIHtcbiAgICAgIHZhciBrZXlzID0gaXNPYmplY3QoY29uZmlnKSA/IG9iamVjdEtleXMoY29uZmlnKSA6IFtdO1xuICAgICAgdmFyIGlzU2hvcnRoYW5kID0gaW5kZXhPZihrZXlzLCBcInZhbHVlXCIpID09PSAtMSAmJiBpbmRleE9mKGtleXMsIFwidHlwZVwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4T2Yoa2V5cywgXCJzcXVhc2hcIikgPT09IC0xICYmIGluZGV4T2Yoa2V5cywgXCJhcnJheVwiKSA9PT0gLTE7XG4gICAgICBpZiAoaXNTaG9ydGhhbmQpIGNvbmZpZyA9IHsgdmFsdWU6IGNvbmZpZyB9O1xuICAgICAgY29uZmlnLiQkZm4gPSBpc0luamVjdGFibGUoY29uZmlnLnZhbHVlKSA/IGNvbmZpZy52YWx1ZSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZy52YWx1ZTsgfTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHlwZShjb25maWcsIHVybFR5cGUsIGxvY2F0aW9uKSB7XG4gICAgICBpZiAoY29uZmlnLnR5cGUgJiYgdXJsVHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW0gJ1wiK2lkK1wiJyBoYXMgdHdvIHR5cGUgY29uZmlndXJhdGlvbnMuXCIpO1xuICAgICAgaWYgKHVybFR5cGUpIHJldHVybiB1cmxUeXBlO1xuICAgICAgaWYgKCFjb25maWcudHlwZSkgcmV0dXJuIChsb2NhdGlvbiA9PT0gXCJjb25maWdcIiA/ICR0eXBlcy5hbnkgOiAkdHlwZXMuc3RyaW5nKTtcblxuICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoY29uZmlnLnR5cGUpKVxuICAgICAgICByZXR1cm4gJHR5cGVzW2NvbmZpZy50eXBlXTtcbiAgICAgIGlmIChjb25maWcudHlwZSBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgIHJldHVybiBjb25maWcudHlwZTtcbiAgICAgIHJldHVybiBuZXcgVHlwZShjb25maWcudHlwZSk7XG4gICAgfVxuXG4gICAgLy8gYXJyYXkgY29uZmlnOiBwYXJhbSBuYW1lIChwYXJhbVtdKSBvdmVycmlkZXMgZGVmYXVsdCBzZXR0aW5ncy4gIGV4cGxpY2l0IGNvbmZpZyBvdmVycmlkZXMgcGFyYW0gbmFtZS5cbiAgICBmdW5jdGlvbiBnZXRBcnJheU1vZGUoKSB7XG4gICAgICB2YXIgYXJyYXlEZWZhdWx0cyA9IHsgYXJyYXk6IChsb2NhdGlvbiA9PT0gXCJzZWFyY2hcIiA/IFwiYXV0b1wiIDogZmFsc2UpIH07XG4gICAgICB2YXIgYXJyYXlQYXJhbU5vbWVuY2xhdHVyZSA9IGlkLm1hdGNoKC9cXFtcXF0kLykgPyB7IGFycmF5OiB0cnVlIH0gOiB7fTtcbiAgICAgIHJldHVybiBleHRlbmQoYXJyYXlEZWZhdWx0cywgYXJyYXlQYXJhbU5vbWVuY2xhdHVyZSwgY29uZmlnKS5hcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGZhbHNlLCB0cnVlLCBvciB0aGUgc3F1YXNoIHZhbHVlIHRvIGluZGljYXRlIHRoZSBcImRlZmF1bHQgcGFyYW1ldGVyIHVybCBzcXVhc2ggcG9saWN5XCIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U3F1YXNoUG9saWN5KGNvbmZpZywgaXNPcHRpb25hbCkge1xuICAgICAgdmFyIHNxdWFzaCA9IGNvbmZpZy5zcXVhc2g7XG4gICAgICBpZiAoIWlzT3B0aW9uYWwgfHwgc3F1YXNoID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFpc0RlZmluZWQoc3F1YXNoKSB8fCBzcXVhc2ggPT0gbnVsbCkgcmV0dXJuIGRlZmF1bHRTcXVhc2hQb2xpY3k7XG4gICAgICBpZiAoc3F1YXNoID09PSB0cnVlIHx8IGlzU3RyaW5nKHNxdWFzaCkpIHJldHVybiBzcXVhc2g7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNxdWFzaCBwb2xpY3k6ICdcIiArIHNxdWFzaCArIFwiJy4gVmFsaWQgcG9saWNpZXM6IGZhbHNlLCB0cnVlLCBvciBhcmJpdHJhcnkgc3RyaW5nXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCkge1xuICAgICAgdmFyIHJlcGxhY2UsIGNvbmZpZ3VyZWRLZXlzLCBkZWZhdWx0UG9saWN5ID0gW1xuICAgICAgICB7IGZyb206IFwiXCIsICAgdG86IChpc09wdGlvbmFsIHx8IGFycmF5TW9kZSA/IHVuZGVmaW5lZCA6IFwiXCIpIH0sXG4gICAgICAgIHsgZnJvbTogbnVsbCwgdG86IChpc09wdGlvbmFsIHx8IGFycmF5TW9kZSA/IHVuZGVmaW5lZCA6IFwiXCIpIH1cbiAgICAgIF07XG4gICAgICByZXBsYWNlID0gaXNBcnJheShjb25maWcucmVwbGFjZSkgPyBjb25maWcucmVwbGFjZSA6IFtdO1xuICAgICAgaWYgKGlzU3RyaW5nKHNxdWFzaCkpXG4gICAgICAgIHJlcGxhY2UucHVzaCh7IGZyb206IHNxdWFzaCwgdG86IHVuZGVmaW5lZCB9KTtcbiAgICAgIGNvbmZpZ3VyZWRLZXlzID0gbWFwKHJlcGxhY2UsIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uZnJvbTsgfSApO1xuICAgICAgcmV0dXJuIGZpbHRlcihkZWZhdWx0UG9saWN5LCBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpbmRleE9mKGNvbmZpZ3VyZWRLZXlzLCBpdGVtLmZyb20pID09PSAtMTsgfSkuY29uY2F0KHJlcGxhY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFtJbnRlcm5hbF0gR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcGFyYW1ldGVyLCB3aGljaCBtYXkgYmUgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAkJGdldERlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIGlmICghaW5qZWN0b3IpIHRocm93IG5ldyBFcnJvcihcIkluamVjdGFibGUgZnVuY3Rpb25zIGNhbm5vdCBiZSBjYWxsZWQgYXQgY29uZmlndXJhdGlvbiB0aW1lXCIpO1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGluamVjdG9yLmludm9rZShjb25maWcuJCRmbik7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFzZWxmLnR5cGUuaXMoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCB2YWx1ZSAoXCIgKyBkZWZhdWx0VmFsdWUgKyBcIikgZm9yIHBhcmFtZXRlciAnXCIgKyBzZWxmLmlkICsgXCInIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUeXBlIChcIiArIHNlbGYudHlwZS5uYW1lICsgXCIpXCIpO1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBbSW50ZXJuYWxdIEdldHMgdGhlIGRlY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYSB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlLCByZXR1cm5zIHRoZVxuICAgICAqIGRlZmF1bHQgdmFsdWUsIHdoaWNoIG1heSBiZSB0aGUgcmVzdWx0IG9mIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gJHZhbHVlKHZhbHVlKSB7XG4gICAgICBmdW5jdGlvbiBoYXNSZXBsYWNlVmFsKHZhbCkgeyByZXR1cm4gZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmouZnJvbSA9PT0gdmFsOyB9OyB9XG4gICAgICBmdW5jdGlvbiAkcmVwbGFjZSh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBtYXAoZmlsdGVyKHNlbGYucmVwbGFjZSwgaGFzUmVwbGFjZVZhbCh2YWx1ZSkpLCBmdW5jdGlvbihvYmopIHsgcmV0dXJuIG9iai50bzsgfSk7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudC5sZW5ndGggPyByZXBsYWNlbWVudFswXSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSAkcmVwbGFjZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gIWlzRGVmaW5lZCh2YWx1ZSkgPyAkJGdldERlZmF1bHRWYWx1ZSgpIDogc2VsZi50eXBlLiRub3JtYWxpemUodmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkgeyByZXR1cm4gXCJ7UGFyYW06XCIgKyBpZCArIFwiIFwiICsgdHlwZSArIFwiIHNxdWFzaDogJ1wiICsgc3F1YXNoICsgXCInIG9wdGlvbmFsOiBcIiArIGlzT3B0aW9uYWwgKyBcIn1cIjsgfVxuXG4gICAgZXh0ZW5kKHRoaXMsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBhcnJheTogYXJyYXlNb2RlLFxuICAgICAgc3F1YXNoOiBzcXVhc2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgaXNPcHRpb25hbDogaXNPcHRpb25hbCxcbiAgICAgIHZhbHVlOiAkdmFsdWUsXG4gICAgICBkeW5hbWljOiB1bmRlZmluZWQsXG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFBhcmFtU2V0KHBhcmFtcykge1xuICAgIGV4dGVuZCh0aGlzLCBwYXJhbXMgfHwge30pO1xuICB9XG5cbiAgUGFyYW1TZXQucHJvdG90eXBlID0ge1xuICAgICQkbmV3OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpbmhlcml0KHRoaXMsIGV4dGVuZChuZXcgUGFyYW1TZXQoKSwgeyAkJHBhcmVudDogdGhpc30pKTtcbiAgICB9LFxuICAgICQka2V5czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGtleXMgPSBbXSwgY2hhaW4gPSBbXSwgcGFyZW50ID0gdGhpcyxcbiAgICAgICAgaWdub3JlID0gb2JqZWN0S2V5cyhQYXJhbVNldC5wcm90b3R5cGUpO1xuICAgICAgd2hpbGUgKHBhcmVudCkgeyBjaGFpbi5wdXNoKHBhcmVudCk7IHBhcmVudCA9IHBhcmVudC4kJHBhcmVudDsgfVxuICAgICAgY2hhaW4ucmV2ZXJzZSgpO1xuICAgICAgZm9yRWFjaChjaGFpbiwgZnVuY3Rpb24ocGFyYW1zZXQpIHtcbiAgICAgICAgZm9yRWFjaChvYmplY3RLZXlzKHBhcmFtc2V0KSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZihrZXlzLCBrZXkpID09PSAtMSAmJiBpbmRleE9mKGlnbm9yZSwga2V5KSA9PT0gLTEpIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSxcbiAgICAkJHZhbHVlczogZnVuY3Rpb24ocGFyYW1WYWx1ZXMpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB7fSwgc2VsZiA9IHRoaXM7XG4gICAgICBmb3JFYWNoKHNlbGYuJCRrZXlzKCksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IHNlbGZba2V5XS52YWx1ZShwYXJhbVZhbHVlcyAmJiBwYXJhbVZhbHVlc1trZXldKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuICAgICQkZXF1YWxzOiBmdW5jdGlvbihwYXJhbVZhbHVlczEsIHBhcmFtVmFsdWVzMikge1xuICAgICAgdmFyIGVxdWFsID0gdHJ1ZSwgc2VsZiA9IHRoaXM7XG4gICAgICBmb3JFYWNoKHNlbGYuJCRrZXlzKCksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgbGVmdCA9IHBhcmFtVmFsdWVzMSAmJiBwYXJhbVZhbHVlczFba2V5XSwgcmlnaHQgPSBwYXJhbVZhbHVlczIgJiYgcGFyYW1WYWx1ZXMyW2tleV07XG4gICAgICAgIGlmICghc2VsZltrZXldLnR5cGUuZXF1YWxzKGxlZnQsIHJpZ2h0KSkgZXF1YWwgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH0sXG4gICAgJCR2YWxpZGF0ZXM6IGZ1bmN0aW9uICQkdmFsaWRhdGUocGFyYW1WYWx1ZXMpIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy4kJGtleXMoKSwgaSwgcGFyYW0sIHJhd1ZhbCwgbm9ybWFsaXplZCwgZW5jb2RlZDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcmFtID0gdGhpc1trZXlzW2ldXTtcbiAgICAgICAgcmF3VmFsID0gcGFyYW1WYWx1ZXNba2V5c1tpXV07XG4gICAgICAgIGlmICgocmF3VmFsID09PSB1bmRlZmluZWQgfHwgcmF3VmFsID09PSBudWxsKSAmJiBwYXJhbS5pc09wdGlvbmFsKVxuICAgICAgICAgIGJyZWFrOyAvLyBUaGVyZSB3YXMgbm8gcGFyYW1ldGVyIHZhbHVlLCBidXQgdGhlIHBhcmFtIGlzIG9wdGlvbmFsXG4gICAgICAgIG5vcm1hbGl6ZWQgPSBwYXJhbS50eXBlLiRub3JtYWxpemUocmF3VmFsKTtcbiAgICAgICAgaWYgKCFwYXJhbS50eXBlLmlzKG5vcm1hbGl6ZWQpKVxuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIHZhbHVlIHdhcyBub3Qgb2YgdGhlIGNvcnJlY3QgVHlwZSwgYW5kIGNvdWxkIG5vdCBiZSBkZWNvZGVkIHRvIHRoZSBjb3JyZWN0IFR5cGVcbiAgICAgICAgZW5jb2RlZCA9IHBhcmFtLnR5cGUuZW5jb2RlKG5vcm1hbGl6ZWQpO1xuICAgICAgICBpZiAoYW5ndWxhci5pc1N0cmluZyhlbmNvZGVkKSAmJiAhcGFyYW0udHlwZS5wYXR0ZXJuLmV4ZWMoZW5jb2RlZCkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUaGUgdmFsdWUgd2FzIG9mIHRoZSBjb3JyZWN0IHR5cGUsIGJ1dCB3aGVuIGVuY29kZWQsIGRpZCBub3QgbWF0Y2ggdGhlIFR5cGUncyByZWdleHBcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgJCRwYXJlbnQ6IHVuZGVmaW5lZFxuICB9O1xuXG4gIHRoaXMuUGFyYW1TZXQgPSBQYXJhbVNldDtcbn1cblxuLy8gUmVnaXN0ZXIgYXMgYSBwcm92aWRlciBzbyBpdCdzIGF2YWlsYWJsZSB0byBvdGhlciBwcm92aWRlcnNcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcpLnByb3ZpZGVyKCckdXJsTWF0Y2hlckZhY3RvcnknLCAkVXJsTWF0Y2hlckZhY3RvcnkpO1xuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJykucnVuKFsnJHVybE1hdGNoZXJGYWN0b3J5JywgZnVuY3Rpb24oJHVybE1hdGNoZXJGYWN0b3J5KSB7IH1dKTtcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlclxuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlclxuICogQHJlcXVpcmVzICRsb2NhdGlvblByb3ZpZGVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBgJHVybFJvdXRlclByb3ZpZGVyYCBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHdhdGNoaW5nIGAkbG9jYXRpb25gLiBcbiAqIFdoZW4gYCRsb2NhdGlvbmAgY2hhbmdlcyBpdCBydW5zIHRocm91Z2ggYSBsaXN0IG9mIHJ1bGVzIG9uZSBieSBvbmUgdW50aWwgYSBcbiAqIG1hdGNoIGlzIGZvdW5kLiBgJHVybFJvdXRlclByb3ZpZGVyYCBpcyB1c2VkIGJlaGluZCB0aGUgc2NlbmVzIGFueXRpbWUgeW91IHNwZWNpZnkgXG4gKiBhIHVybCBpbiBhIHN0YXRlIGNvbmZpZ3VyYXRpb24uIEFsbCB1cmxzIGFyZSBjb21waWxlZCBpbnRvIGEgVXJsTWF0Y2hlciBvYmplY3QuXG4gKlxuICogVGhlcmUgYXJlIHNldmVyYWwgbWV0aG9kcyBvbiBgJHVybFJvdXRlclByb3ZpZGVyYCB0aGF0IG1ha2UgaXQgdXNlZnVsIHRvIHVzZSBkaXJlY3RseVxuICogaW4geW91ciBtb2R1bGUgY29uZmlnLlxuICovXG4kVXJsUm91dGVyUHJvdmlkZXIuJGluamVjdCA9IFsnJGxvY2F0aW9uUHJvdmlkZXInLCAnJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXInXTtcbmZ1bmN0aW9uICRVcmxSb3V0ZXJQcm92aWRlciggICAkbG9jYXRpb25Qcm92aWRlciwgICAkdXJsTWF0Y2hlckZhY3RvcnkpIHtcbiAgdmFyIHJ1bGVzID0gW10sIG90aGVyd2lzZSA9IG51bGwsIGludGVyY2VwdERlZmVycmVkID0gZmFsc2UsIGxpc3RlbmVyO1xuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBhIHByZWZpeCBvZiBhbGwgc3RyaW5ncyBtYXRjaGluZyB0aGUgUmVnRXhwXG4gIGZ1bmN0aW9uIHJlZ0V4cFByZWZpeChyZSkge1xuICAgIHZhciBwcmVmaXggPSAvXlxcXigoPzpcXFxcW15hLXpBLVowLTldfFteXFxcXFxcW1xcXVxcXiQqKz8uKCl8e31dKykqKS8uZXhlYyhyZS5zb3VyY2UpO1xuICAgIHJldHVybiAocHJlZml4ICE9IG51bGwpID8gcHJlZml4WzFdLnJlcGxhY2UoL1xcXFwoLikvZywgXCIkMVwiKSA6ICcnO1xuICB9XG5cbiAgLy8gSW50ZXJwb2xhdGVzIG1hdGNoZWQgdmFsdWVzIGludG8gYSBTdHJpbmcucmVwbGFjZSgpLXN0eWxlIHBhdHRlcm5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUocGF0dGVybiwgbWF0Y2gpIHtcbiAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC9cXCQoXFwkfFxcZHsxLDJ9KS8sIGZ1bmN0aW9uIChtLCB3aGF0KSB7XG4gICAgICByZXR1cm4gbWF0Y2hbd2hhdCA9PT0gJyQnID8gMCA6IE51bWJlcih3aGF0KV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlclByb3ZpZGVyI3J1bGVcbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlclByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZWZpbmVzIHJ1bGVzIHRoYXQgYXJlIHVzZWQgYnkgYCR1cmxSb3V0ZXJQcm92aWRlcmAgdG8gZmluZCBtYXRjaGVzIGZvclxuICAgKiBzcGVjaWZpYyBVUkxzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8cHJlPlxuICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICpcbiAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XG4gICAqICAgLy8gSGVyZSdzIGFuIGV4YW1wbGUgb2YgaG93IHlvdSBtaWdodCBhbGxvdyBjYXNlIGluc2Vuc2l0aXZlIHVybHNcbiAgICogICAkdXJsUm91dGVyUHJvdmlkZXIucnVsZShmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcbiAgICogICAgIHZhciBwYXRoID0gJGxvY2F0aW9uLnBhdGgoKSxcbiAgICogICAgICAgICBub3JtYWxpemVkID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgKlxuICAgKiAgICAgaWYgKHBhdGggIT09IG5vcm1hbGl6ZWQpIHtcbiAgICogICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqIH0pO1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcnVsZSBIYW5kbGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYCRpbmplY3RvcmAgYW5kIGAkbG9jYXRpb25gXG4gICAqIHNlcnZpY2VzIGFzIGFyZ3VtZW50cy4gWW91IGNhbiB1c2UgdGhlbSB0byByZXR1cm4gYSB2YWxpZCBwYXRoIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGAkdXJsUm91dGVyUHJvdmlkZXJgIC0gYCR1cmxSb3V0ZXJQcm92aWRlcmAgaW5zdGFuY2VcbiAgICovXG4gIHRoaXMucnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHJ1bGUpKSB0aHJvdyBuZXcgRXJyb3IoXCIncnVsZScgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIHJ1bGVzLnB1c2gocnVsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBvYmplY3RcbiAgICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyUHJvdmlkZXIjb3RoZXJ3aXNlXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRGVmaW5lcyBhIHBhdGggdGhhdCBpcyB1c2VkIHdoZW4gYW4gaW52YWxpZCByb3V0ZSBpcyByZXF1ZXN0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxwcmU+XG4gICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXIucm91dGVyJ10pO1xuICAgKlxuICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICogICAvLyBpZiB0aGUgcGF0aCBkb2Vzbid0IG1hdGNoIGFueSBvZiB0aGUgdXJscyB5b3UgY29uZmlndXJlZFxuICAgKiAgIC8vIG90aGVyd2lzZSB3aWxsIHRha2UgY2FyZSBvZiByb3V0aW5nIHRoZSB1c2VyIHRvIHRoZVxuICAgKiAgIC8vIHNwZWNpZmllZCB1cmxcbiAgICogICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKCcvaW5kZXgnKTtcbiAgICpcbiAgICogICAvLyBFeGFtcGxlIG9mIHVzaW5nIGZ1bmN0aW9uIHJ1bGUgYXMgcGFyYW1cbiAgICogICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2NhdGlvbikge1xuICAgKiAgICAgcmV0dXJuICcvYS92YWxpZC91cmwnO1xuICAgKiAgIH0pO1xuICAgKiB9KTtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSBydWxlIFRoZSB1cmwgcGF0aCB5b3Ugd2FudCB0byByZWRpcmVjdCB0byBvciBhIGZ1bmN0aW9uIFxuICAgKiBydWxlIHRoYXQgcmV0dXJucyB0aGUgdXJsIHBhdGguIFRoZSBmdW5jdGlvbiB2ZXJzaW9uIGlzIHBhc3NlZCB0d28gcGFyYW1zOiBcbiAgICogYCRpbmplY3RvcmAgYW5kIGAkbG9jYXRpb25gIHNlcnZpY2VzLCBhbmQgbXVzdCByZXR1cm4gYSB1cmwgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGAkdXJsUm91dGVyUHJvdmlkZXJgIC0gYCR1cmxSb3V0ZXJQcm92aWRlcmAgaW5zdGFuY2VcbiAgICovXG4gIHRoaXMub3RoZXJ3aXNlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoaXNTdHJpbmcocnVsZSkpIHtcbiAgICAgIHZhciByZWRpcmVjdCA9IHJ1bGU7XG4gICAgICBydWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVkaXJlY3Q7IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0Z1bmN0aW9uKHJ1bGUpKSB0aHJvdyBuZXcgRXJyb3IoXCIncnVsZScgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIG90aGVyd2lzZSA9IHJ1bGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICBmdW5jdGlvbiBoYW5kbGVJZk1hdGNoKCRpbmplY3RvciwgaGFuZGxlciwgbWF0Y2gpIHtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJlc3VsdCA9ICRpbmplY3Rvci5pbnZva2UoaGFuZGxlciwgaGFuZGxlciwgeyAkbWF0Y2g6IG1hdGNoIH0pO1xuICAgIHJldHVybiBpc0RlZmluZWQocmVzdWx0KSA/IHJlc3VsdCA6IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlclByb3ZpZGVyI3doZW5cbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlclByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZWdpc3RlcnMgYSBoYW5kbGVyIGZvciBhIGdpdmVuIHVybCBtYXRjaGluZy4gXG4gICAqIFxuICAgKiBJZiB0aGUgaGFuZGxlciBpcyBhIHN0cmluZywgaXQgaXNcbiAgICogdHJlYXRlZCBhcyBhIHJlZGlyZWN0LCBhbmQgaXMgaW50ZXJwb2xhdGVkIGFjY29yZGluZyB0byB0aGUgc3ludGF4IG9mIG1hdGNoXG4gICAqIChpLmUuIGxpa2UgYFN0cmluZy5yZXBsYWNlKClgIGZvciBgUmVnRXhwYCwgb3IgbGlrZSBhIGBVcmxNYXRjaGVyYCBwYXR0ZXJuIG90aGVyd2lzZSkuXG4gICAqXG4gICAqIElmIHRoZSBoYW5kbGVyIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGluamVjdGFibGUuIEl0IGdldHMgaW52b2tlZCBpZiBgJGxvY2F0aW9uYFxuICAgKiBtYXRjaGVzLiBZb3UgaGF2ZSB0aGUgb3B0aW9uIG9mIGluamVjdCB0aGUgbWF0Y2ggb2JqZWN0IGFzIGAkbWF0Y2hgLlxuICAgKlxuICAgKiBUaGUgaGFuZGxlciBjYW4gcmV0dXJuXG4gICAqXG4gICAqIC0gKipmYWxzeSoqIHRvIGluZGljYXRlIHRoYXQgdGhlIHJ1bGUgZGlkbid0IG1hdGNoIGFmdGVyIGFsbCwgdGhlbiBgJHVybFJvdXRlcmBcbiAgICogICB3aWxsIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFub3RoZXIgb25lIHRoYXQgbWF0Y2hlcy5cbiAgICogLSAqKnN0cmluZyoqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSByZWRpcmVjdCBhbmQgcGFzc2VkIHRvIGAkbG9jYXRpb24udXJsKClgXG4gICAqIC0gKip2b2lkKiogb3IgYW55ICoqdHJ1dGh5KiogdmFsdWUgdGVsbHMgYCR1cmxSb3V0ZXJgIHRoYXQgdGhlIHVybCB3YXMgaGFuZGxlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPHByZT5cbiAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XG4gICAqXG4gICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci53aGVuKCRzdGF0ZS51cmwsIGZ1bmN0aW9uICgkbWF0Y2gsICRzdGF0ZVBhcmFtcykge1xuICAgKiAgICAgaWYgKCRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUgIT09IHN0YXRlIHx8XG4gICAqICAgICAgICAgIWVxdWFsRm9yS2V5cygkbWF0Y2gsICRzdGF0ZVBhcmFtcykge1xuICAgKiAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oc3RhdGUsICRtYXRjaCwgZmFsc2UpO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiB9KTtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gd2hhdCBUaGUgaW5jb21pbmcgcGF0aCB0aGF0IHlvdSB3YW50IHRvIHJlZGlyZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gaGFuZGxlciBUaGUgcGF0aCB5b3Ugd2FudCB0byByZWRpcmVjdCB5b3VyIHVzZXIgdG8uXG4gICAqL1xuICB0aGlzLndoZW4gPSBmdW5jdGlvbiAod2hhdCwgaGFuZGxlcikge1xuICAgIHZhciByZWRpcmVjdCwgaGFuZGxlcklzU3RyaW5nID0gaXNTdHJpbmcoaGFuZGxlcik7XG4gICAgaWYgKGlzU3RyaW5nKHdoYXQpKSB3aGF0ID0gJHVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUod2hhdCk7XG5cbiAgICBpZiAoIWhhbmRsZXJJc1N0cmluZyAmJiAhaXNGdW5jdGlvbihoYW5kbGVyKSAmJiAhaXNBcnJheShoYW5kbGVyKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgJ2hhbmRsZXInIGluIHdoZW4oKVwiKTtcblxuICAgIHZhciBzdHJhdGVnaWVzID0ge1xuICAgICAgbWF0Y2hlcjogZnVuY3Rpb24gKHdoYXQsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXJJc1N0cmluZykge1xuICAgICAgICAgIHJlZGlyZWN0ID0gJHVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUoaGFuZGxlcik7XG4gICAgICAgICAgaGFuZGxlciA9IFsnJG1hdGNoJywgZnVuY3Rpb24gKCRtYXRjaCkgeyByZXR1cm4gcmVkaXJlY3QuZm9ybWF0KCRtYXRjaCk7IH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCRpbmplY3RvciwgJGxvY2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUlmTWF0Y2goJGluamVjdG9yLCBoYW5kbGVyLCB3aGF0LmV4ZWMoJGxvY2F0aW9uLnBhdGgoKSwgJGxvY2F0aW9uLnNlYXJjaCgpKSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwcmVmaXg6IGlzU3RyaW5nKHdoYXQucHJlZml4KSA/IHdoYXQucHJlZml4IDogJydcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVnZXg6IGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICh3aGF0Lmdsb2JhbCB8fCB3aGF0LnN0aWNreSkgdGhyb3cgbmV3IEVycm9yKFwid2hlbigpIFJlZ0V4cCBtdXN0IG5vdCBiZSBnbG9iYWwgb3Igc3RpY2t5XCIpO1xuXG4gICAgICAgIGlmIChoYW5kbGVySXNTdHJpbmcpIHtcbiAgICAgICAgICByZWRpcmVjdCA9IGhhbmRsZXI7XG4gICAgICAgICAgaGFuZGxlciA9IFsnJG1hdGNoJywgZnVuY3Rpb24gKCRtYXRjaCkgeyByZXR1cm4gaW50ZXJwb2xhdGUocmVkaXJlY3QsICRtYXRjaCk7IH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCRpbmplY3RvciwgJGxvY2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUlmTWF0Y2goJGluamVjdG9yLCBoYW5kbGVyLCB3aGF0LmV4ZWMoJGxvY2F0aW9uLnBhdGgoKSkpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgcHJlZml4OiByZWdFeHBQcmVmaXgod2hhdClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjaGVjayA9IHsgbWF0Y2hlcjogJHVybE1hdGNoZXJGYWN0b3J5LmlzTWF0Y2hlcih3aGF0KSwgcmVnZXg6IHdoYXQgaW5zdGFuY2VvZiBSZWdFeHAgfTtcblxuICAgIGZvciAodmFyIG4gaW4gY2hlY2spIHtcbiAgICAgIGlmIChjaGVja1tuXSkgcmV0dXJuIHRoaXMucnVsZShzdHJhdGVnaWVzW25dKHdoYXQsIGhhbmRsZXIpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkICd3aGF0JyBpbiB3aGVuKClcIik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlciNkZWZlckludGVyY2VwdFxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERpc2FibGVzIChvciBlbmFibGVzKSBkZWZlcnJpbmcgbG9jYXRpb24gY2hhbmdlIGludGVyY2VwdGlvbi5cbiAgICpcbiAgICogSWYgeW91IHdpc2ggdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZiBzeW5jaW5nIHRoZSBVUkwgKGZvciBleGFtcGxlLCBpZiB5b3Ugd2lzaCB0b1xuICAgKiBkZWZlciBhIHRyYW5zaXRpb24gYnV0IG1haW50YWluIHRoZSBjdXJyZW50IFVSTCksIGNhbGwgdGhpcyBtZXRob2QgYXQgY29uZmlndXJhdGlvbiB0aW1lLlxuICAgKiBUaGVuLCBhdCBydW4gdGltZSwgY2FsbCBgJHVybFJvdXRlci5saXN0ZW4oKWAgYWZ0ZXIgeW91IGhhdmUgY29uZmlndXJlZCB5b3VyIG93blxuICAgKiBgJGxvY2F0aW9uQ2hhbmdlU3VjY2Vzc2AgZXZlbnQgaGFuZGxlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPHByZT5cbiAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XG4gICAqXG4gICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgKlxuICAgKiAgIC8vIFByZXZlbnQgJHVybFJvdXRlciBmcm9tIGF1dG9tYXRpY2FsbHkgaW50ZXJjZXB0aW5nIFVSTCBjaGFuZ2VzO1xuICAgKiAgIC8vIHRoaXMgYWxsb3dzIHlvdSB0byBjb25maWd1cmUgY3VzdG9tIGJlaGF2aW9yIGluIGJldHdlZW5cbiAgICogICAvLyBsb2NhdGlvbiBjaGFuZ2VzIGFuZCByb3V0ZSBzeW5jaHJvbml6YXRpb246XG4gICAqICAgJHVybFJvdXRlclByb3ZpZGVyLmRlZmVySW50ZXJjZXB0KCk7XG4gICAqXG4gICAqIH0pLnJ1bihmdW5jdGlvbiAoJHJvb3RTY29wZSwgJHVybFJvdXRlciwgVXNlclNlcnZpY2UpIHtcbiAgICpcbiAgICogICAkcm9vdFNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKGUpIHtcbiAgICogICAgIC8vIFVzZXJTZXJ2aWNlIGlzIGFuIGV4YW1wbGUgc2VydmljZSBmb3IgbWFuYWdpbmcgdXNlciBzdGF0ZVxuICAgKiAgICAgaWYgKFVzZXJTZXJ2aWNlLmlzTG9nZ2VkSW4oKSkgcmV0dXJuO1xuICAgKlxuICAgKiAgICAgLy8gUHJldmVudCAkdXJsUm91dGVyJ3MgZGVmYXVsdCBoYW5kbGVyIGZyb20gZmlyaW5nXG4gICAqICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAqXG4gICAqICAgICBVc2VyU2VydmljZS5oYW5kbGVMb2dpbigpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAqICAgICAgIC8vIE9uY2UgdGhlIHVzZXIgaGFzIGxvZ2dlZCBpbiwgc3luYyB0aGUgY3VycmVudCBVUkxcbiAgICogICAgICAgLy8gdG8gdGhlIHJvdXRlcjpcbiAgICogICAgICAgJHVybFJvdXRlci5zeW5jKCk7XG4gICAqICAgICB9KTtcbiAgICogICB9KTtcbiAgICpcbiAgICogICAvLyBDb25maWd1cmVzICR1cmxSb3V0ZXIncyBsaXN0ZW5lciAqYWZ0ZXIqIHlvdXIgY3VzdG9tIGxpc3RlbmVyXG4gICAqICAgJHVybFJvdXRlci5saXN0ZW4oKTtcbiAgICogfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlZmVyIEluZGljYXRlcyB3aGV0aGVyIHRvIGRlZmVyIGxvY2F0aW9uIGNoYW5nZSBpbnRlcmNlcHRpb24uIFBhc3NpbmdcbiAgICAgICAgICAgIG5vIHBhcmFtZXRlciBpcyBlcXVpdmFsZW50IHRvIGB0cnVlYC5cbiAgICovXG4gIHRoaXMuZGVmZXJJbnRlcmNlcHQgPSBmdW5jdGlvbiAoZGVmZXIpIHtcbiAgICBpZiAoZGVmZXIgPT09IHVuZGVmaW5lZCkgZGVmZXIgPSB0cnVlO1xuICAgIGludGVyY2VwdERlZmVycmVkID0gZGVmZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBvYmplY3RcbiAgICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyXG4gICAqXG4gICAqIEByZXF1aXJlcyAkbG9jYXRpb25cbiAgICogQHJlcXVpcmVzICRyb290U2NvcGVcbiAgICogQHJlcXVpcmVzICRpbmplY3RvclxuICAgKiBAcmVxdWlyZXMgJGJyb3dzZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqL1xuICB0aGlzLiRnZXQgPSAkZ2V0O1xuICAkZ2V0LiRpbmplY3QgPSBbJyRsb2NhdGlvbicsICckcm9vdFNjb3BlJywgJyRpbmplY3RvcicsICckYnJvd3NlcicsICckc25pZmZlciddO1xuICBmdW5jdGlvbiAkZ2V0KCAgICRsb2NhdGlvbiwgICAkcm9vdFNjb3BlLCAgICRpbmplY3RvciwgICAkYnJvd3NlciwgICAkc25pZmZlcikge1xuXG4gICAgdmFyIGJhc2VIcmVmID0gJGJyb3dzZXIuYmFzZUhyZWYoKSwgbG9jYXRpb24gPSAkbG9jYXRpb24udXJsKCksIGxhc3RQdXNoZWRVcmw7XG5cbiAgICBmdW5jdGlvbiBhcHBlbmRCYXNlUGF0aCh1cmwsIGlzSHRtbDUsIGFic29sdXRlKSB7XG4gICAgICBpZiAoYmFzZUhyZWYgPT09ICcvJykgcmV0dXJuIHVybDtcbiAgICAgIGlmIChpc0h0bWw1KSByZXR1cm4gYmFzZUhyZWYuc2xpY2UoMCwgLTEpICsgdXJsO1xuICAgICAgaWYgKGFic29sdXRlKSByZXR1cm4gYmFzZUhyZWYuc2xpY2UoMSkgKyB1cmw7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IE9wdGltaXplIGdyb3VwcyBvZiBydWxlcyB3aXRoIG5vbi1lbXB0eSBwcmVmaXggaW50byBzb21lIHNvcnQgb2YgZGVjaXNpb24gdHJlZVxuICAgIGZ1bmN0aW9uIHVwZGF0ZShldnQpIHtcbiAgICAgIGlmIChldnQgJiYgZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIHZhciBpZ25vcmVVcGRhdGUgPSBsYXN0UHVzaGVkVXJsICYmICRsb2NhdGlvbi51cmwoKSA9PT0gbGFzdFB1c2hlZFVybDtcbiAgICAgIGxhc3RQdXNoZWRVcmwgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBUT0RPOiBSZS1pbXBsZW1lbnQgdGhpcyBpbiAxLjAgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXJvdXRlci9pc3N1ZXMvMTU3M1xuICAgICAgLy9pZiAoaWdub3JlVXBkYXRlKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgZnVuY3Rpb24gY2hlY2socnVsZSkge1xuICAgICAgICB2YXIgaGFuZGxlZCA9IHJ1bGUoJGluamVjdG9yLCAkbG9jYXRpb24pO1xuXG4gICAgICAgIGlmICghaGFuZGxlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaXNTdHJpbmcoaGFuZGxlZCkpICRsb2NhdGlvbi5yZXBsYWNlKCkudXJsKGhhbmRsZWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBuID0gcnVsZXMubGVuZ3RoLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGVjayhydWxlc1tpXSkpIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGFsd2F5cyBjaGVjayBvdGhlcndpc2UgbGFzdCB0byBhbGxvdyBkeW5hbWljIHVwZGF0ZXMgdG8gdGhlIHNldCBvZiBydWxlc1xuICAgICAgaWYgKG90aGVyd2lzZSkgY2hlY2sob3RoZXJ3aXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyIHx8ICRyb290U2NvcGUuJG9uKCckbG9jYXRpb25DaGFuZ2VTdWNjZXNzJywgdXBkYXRlKTtcbiAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICB9XG5cbiAgICBpZiAoIWludGVyY2VwdERlZmVycmVkKSBsaXN0ZW4oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyI3N5bmNcbiAgICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFRyaWdnZXJzIGFuIHVwZGF0ZTsgdGhlIHNhbWUgdXBkYXRlIHRoYXQgaGFwcGVucyB3aGVuIHRoZSBhZGRyZXNzIGJhciB1cmwgY2hhbmdlcywgYWthIGAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzYC5cbiAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHVzZSBgcHJldmVudERlZmF1bHQoKWAgb24gdGhlIGAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzYCBldmVudCxcbiAgICAgICAqIHBlcmZvcm0gc29tZSBjdXN0b20gbG9naWMgKHJvdXRlIHByb3RlY3Rpb24sIGF1dGgsIGNvbmZpZywgcmVkaXJlY3Rpb24sIGV0YykgYW5kIHRoZW4gZmluYWxseSBwcm9jZWVkXG4gICAgICAgKiB3aXRoIHRoZSB0cmFuc2l0aW9uIGJ5IGNhbGxpbmcgYCR1cmxSb3V0ZXIuc3luYygpYC5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogPHByZT5cbiAgICAgICAqIGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKVxuICAgICAgICogICAucnVuKGZ1bmN0aW9uKCRyb290U2NvcGUsICR1cmxSb3V0ZXIpIHtcbiAgICAgICAqICAgICAkcm9vdFNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICogICAgICAgLy8gSGFsdCBzdGF0ZSBjaGFuZ2UgZnJvbSBldmVuIHN0YXJ0aW5nXG4gICAgICAgKiAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAqICAgICAgIC8vIFBlcmZvcm0gY3VzdG9tIGxvZ2ljXG4gICAgICAgKiAgICAgICB2YXIgbWVldHNSZXF1aXJlbWVudCA9IC4uLlxuICAgICAgICogICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgdXBkYXRlIGFuZCBzdGF0ZSB0cmFuc2l0aW9uIGlmIGxvZ2ljIGFsbG93c1xuICAgICAgICogICAgICAgaWYgKG1lZXRzUmVxdWlyZW1lbnQpICR1cmxSb3V0ZXIuc3luYygpO1xuICAgICAgICogICAgIH0pO1xuICAgICAgICogfSk7XG4gICAgICAgKiA8L3ByZT5cbiAgICAgICAqL1xuICAgICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfSxcblxuICAgICAgbGlzdGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbigpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiBmdW5jdGlvbihyZWFkKSB7XG4gICAgICAgIGlmIChyZWFkKSB7XG4gICAgICAgICAgbG9jYXRpb24gPSAkbG9jYXRpb24udXJsKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkbG9jYXRpb24udXJsKCkgPT09IGxvY2F0aW9uKSByZXR1cm47XG5cbiAgICAgICAgJGxvY2F0aW9uLnVybChsb2NhdGlvbik7XG4gICAgICAgICRsb2NhdGlvbi5yZXBsYWNlKCk7XG4gICAgICB9LFxuXG4gICAgICBwdXNoOiBmdW5jdGlvbih1cmxNYXRjaGVyLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgIHZhciB1cmwgPSB1cmxNYXRjaGVyLmZvcm1hdChwYXJhbXMgfHwge30pO1xuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc3BlY2lhbCBoYXNoIHBhcmFtLCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHVybCAhPT0gbnVsbCAmJiBwYXJhbXMgJiYgcGFyYW1zWycjJ10pIHtcbiAgICAgICAgICAgIHVybCArPSAnIycgKyBwYXJhbXNbJyMnXTtcbiAgICAgICAgfVxuXG4gICAgICAgICRsb2NhdGlvbi51cmwodXJsKTtcbiAgICAgICAgbGFzdFB1c2hlZFVybCA9IG9wdGlvbnMgJiYgb3B0aW9ucy4kJGF2b2lkUmVzeW5jID8gJGxvY2F0aW9uLnVybCgpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICRsb2NhdGlvbi5yZXBsYWNlKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyI2hyZWZcbiAgICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIEEgVVJMIGdlbmVyYXRpb24gbWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgY29tcGlsZWQgVVJMIGZvciBhIGdpdmVuXG4gICAgICAgKiB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyIGBVcmxNYXRjaGVyYH0sIHBvcHVsYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzLlxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiA8cHJlPlxuICAgICAgICogJGJvYiA9ICR1cmxSb3V0ZXIuaHJlZihuZXcgVXJsTWF0Y2hlcihcIi9hYm91dC86cGVyc29uXCIpLCB7XG4gICAgICAgKiAgIHBlcnNvbjogXCJib2JcIlxuICAgICAgICogfSk7XG4gICAgICAgKiAvLyAkYm9iID09IFwiL2Fib3V0L2JvYlwiO1xuICAgICAgICogPC9wcmU+XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtVcmxNYXRjaGVyfSB1cmxNYXRjaGVyIFRoZSBgVXJsTWF0Y2hlcmAgb2JqZWN0IHdoaWNoIGlzIHVzZWQgYXMgdGhlIHRlbXBsYXRlIG9mIHRoZSBVUkwgdG8gZ2VuZXJhdGUuXG4gICAgICAgKiBAcGFyYW0ge29iamVjdD19IHBhcmFtcyBBbiBvYmplY3Qgb2YgcGFyYW1ldGVyIHZhbHVlcyB0byBmaWxsIHRoZSBtYXRjaGVyJ3MgcmVxdWlyZWQgcGFyYW1ldGVycy5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgICAgICpcbiAgICAgICAqIC0gKipgYWJzb2x1dGVgKiogLSB7Ym9vbGVhbj1mYWxzZX0sICBJZiB0cnVlIHdpbGwgZ2VuZXJhdGUgYW4gYWJzb2x1dGUgdXJsLCBlLmcuIFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9mdWxsdXJsXCIuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVsbHkgY29tcGlsZWQgVVJMLCBvciBgbnVsbGAgaWYgYHBhcmFtc2AgZmFpbCB2YWxpZGF0aW9uIGFnYWluc3QgYHVybE1hdGNoZXJgXG4gICAgICAgKi9cbiAgICAgIGhyZWY6IGZ1bmN0aW9uKHVybE1hdGNoZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXVybE1hdGNoZXIudmFsaWRhdGVzKHBhcmFtcykpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBpc0h0bWw1ID0gJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKCk7XG4gICAgICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KGlzSHRtbDUpKSB7XG4gICAgICAgICAgaXNIdG1sNSA9IGlzSHRtbDUuZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzSHRtbDUgPSBpc0h0bWw1ICYmICRzbmlmZmVyLmhpc3Rvcnk7XG4gICAgICAgIFxuICAgICAgICB2YXIgdXJsID0gdXJsTWF0Y2hlci5mb3JtYXQocGFyYW1zKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKCFpc0h0bWw1ICYmIHVybCAhPT0gbnVsbCkge1xuICAgICAgICAgIHVybCA9IFwiI1wiICsgJGxvY2F0aW9uUHJvdmlkZXIuaGFzaFByZWZpeCgpICsgdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgaGFzaCBwYXJhbSwgaWYgbmVlZGVkXG4gICAgICAgIGlmICh1cmwgIT09IG51bGwgJiYgcGFyYW1zICYmIHBhcmFtc1snIyddKSB7XG4gICAgICAgICAgdXJsICs9ICcjJyArIHBhcmFtc1snIyddO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsID0gYXBwZW5kQmFzZVBhdGgodXJsLCBpc0h0bWw1LCBvcHRpb25zLmFic29sdXRlKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGUgfHwgIXVybCkge1xuICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2xhc2ggPSAoIWlzSHRtbDUgJiYgdXJsID8gJy8nIDogJycpLCBwb3J0ID0gJGxvY2F0aW9uLnBvcnQoKTtcbiAgICAgICAgcG9ydCA9IChwb3J0ID09PSA4MCB8fCBwb3J0ID09PSA0NDMgPyAnJyA6ICc6JyArIHBvcnQpO1xuXG4gICAgICAgIHJldHVybiBbJGxvY2F0aW9uLnByb3RvY29sKCksICc6Ly8nLCAkbG9jYXRpb24uaG9zdCgpLCBwb3J0LCBzbGFzaCwgdXJsXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIucm91dGVyJykucHJvdmlkZXIoJyR1cmxSb3V0ZXInLCAkVXJsUm91dGVyUHJvdmlkZXIpO1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVQcm92aWRlclxuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlclxuICogQHJlcXVpcmVzIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgbmV3IGAkc3RhdGVQcm92aWRlcmAgd29ya3Mgc2ltaWxhciB0byBBbmd1bGFyJ3MgdjEgcm91dGVyLCBidXQgaXQgZm9jdXNlcyBwdXJlbHlcbiAqIG9uIHN0YXRlLlxuICpcbiAqIEEgc3RhdGUgY29ycmVzcG9uZHMgdG8gYSBcInBsYWNlXCIgaW4gdGhlIGFwcGxpY2F0aW9uIGluIHRlcm1zIG9mIHRoZSBvdmVyYWxsIFVJIGFuZFxuICogbmF2aWdhdGlvbi4gQSBzdGF0ZSBkZXNjcmliZXMgKHZpYSB0aGUgY29udHJvbGxlciAvIHRlbXBsYXRlIC8gdmlldyBwcm9wZXJ0aWVzKSB3aGF0XG4gKiB0aGUgVUkgbG9va3MgbGlrZSBhbmQgZG9lcyBhdCB0aGF0IHBsYWNlLlxuICpcbiAqIFN0YXRlcyBvZnRlbiBoYXZlIHRoaW5ncyBpbiBjb21tb24sIGFuZCB0aGUgcHJpbWFyeSB3YXkgb2YgZmFjdG9yaW5nIG91dCB0aGVzZVxuICogY29tbW9uYWxpdGllcyBpbiB0aGlzIG1vZGVsIGlzIHZpYSB0aGUgc3RhdGUgaGllcmFyY2h5LCBpLmUuIHBhcmVudC9jaGlsZCBzdGF0ZXMgYWthXG4gKiBuZXN0ZWQgc3RhdGVzLlxuICpcbiAqIFRoZSBgJHN0YXRlUHJvdmlkZXJgIHByb3ZpZGVzIGludGVyZmFjZXMgdG8gZGVjbGFyZSB0aGVzZSBzdGF0ZXMgZm9yIHlvdXIgYXBwLlxuICovXG4kU3RhdGVQcm92aWRlci4kaW5qZWN0ID0gWyckdXJsUm91dGVyUHJvdmlkZXInLCAnJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXInXTtcbmZ1bmN0aW9uICRTdGF0ZVByb3ZpZGVyKCAgICR1cmxSb3V0ZXJQcm92aWRlciwgICAkdXJsTWF0Y2hlckZhY3RvcnkpIHtcblxuICB2YXIgcm9vdCwgc3RhdGVzID0ge30sICRzdGF0ZSwgcXVldWUgPSB7fSwgYWJzdHJhY3RLZXkgPSAnYWJzdHJhY3QnO1xuXG4gIC8vIEJ1aWxkcyBzdGF0ZSBwcm9wZXJ0aWVzIGZyb20gZGVmaW5pdGlvbiBwYXNzZWQgdG8gcmVnaXN0ZXJTdGF0ZSgpXG4gIHZhciBzdGF0ZUJ1aWxkZXIgPSB7XG5cbiAgICAvLyBEZXJpdmUgcGFyZW50IHN0YXRlIGZyb20gYSBoaWVyYXJjaGljYWwgbmFtZSBvbmx5IGlmICdwYXJlbnQnIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWQuXG4gICAgLy8gc3RhdGUuY2hpbGRyZW4gPSBbXTtcbiAgICAvLyBpZiAocGFyZW50KSBwYXJlbnQuY2hpbGRyZW4ucHVzaChzdGF0ZSk7XG4gICAgcGFyZW50OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKGlzRGVmaW5lZChzdGF0ZS5wYXJlbnQpICYmIHN0YXRlLnBhcmVudCkgcmV0dXJuIGZpbmRTdGF0ZShzdGF0ZS5wYXJlbnQpO1xuICAgICAgLy8gcmVnZXggbWF0Y2hlcyBhbnkgdmFsaWQgY29tcG9zaXRlIHN0YXRlIG5hbWVcbiAgICAgIC8vIHdvdWxkIG1hdGNoIFwiY29udGFjdC5saXN0XCIgYnV0IG5vdCBcImNvbnRhY3RzXCJcbiAgICAgIHZhciBjb21wb3NpdGVOYW1lID0gL14oLispXFwuW14uXSskLy5leGVjKHN0YXRlLm5hbWUpO1xuICAgICAgcmV0dXJuIGNvbXBvc2l0ZU5hbWUgPyBmaW5kU3RhdGUoY29tcG9zaXRlTmFtZVsxXSkgOiByb290O1xuICAgIH0sXG5cbiAgICAvLyBpbmhlcml0ICdkYXRhJyBmcm9tIHBhcmVudCBhbmQgb3ZlcnJpZGUgYnkgb3duIHZhbHVlcyAoaWYgYW55KVxuICAgIGRhdGE6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUucGFyZW50ICYmIHN0YXRlLnBhcmVudC5kYXRhKSB7XG4gICAgICAgIHN0YXRlLmRhdGEgPSBzdGF0ZS5zZWxmLmRhdGEgPSBpbmhlcml0KHN0YXRlLnBhcmVudC5kYXRhLCBzdGF0ZS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZS5kYXRhO1xuICAgIH0sXG5cbiAgICAvLyBCdWlsZCBhIFVSTE1hdGNoZXIgaWYgbmVjZXNzYXJ5LCBlaXRoZXIgdmlhIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMXG4gICAgdXJsOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgdmFyIHVybCA9IHN0YXRlLnVybCwgY29uZmlnID0geyBwYXJhbXM6IHN0YXRlLnBhcmFtcyB8fCB7fSB9O1xuXG4gICAgICBpZiAoaXNTdHJpbmcodXJsKSkge1xuICAgICAgICBpZiAodXJsLmNoYXJBdCgwKSA9PSAnXicpIHJldHVybiAkdXJsTWF0Y2hlckZhY3RvcnkuY29tcGlsZSh1cmwuc3Vic3RyaW5nKDEpLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gKHN0YXRlLnBhcmVudC5uYXZpZ2FibGUgfHwgcm9vdCkudXJsLmNvbmNhdCh1cmwsIGNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXJsIHx8ICR1cmxNYXRjaGVyRmFjdG9yeS5pc01hdGNoZXIodXJsKSkgcmV0dXJuIHVybDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdXJsICdcIiArIHVybCArIFwiJyBpbiBzdGF0ZSAnXCIgKyBzdGF0ZSArIFwiJ1wiKTtcbiAgICB9LFxuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY2xvc2VzdCBhbmNlc3RvciBzdGF0ZSB0aGF0IGhhcyBhIFVSTCAoaS5lLiBpcyBuYXZpZ2FibGUpXG4gICAgbmF2aWdhYmxlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnVybCA/IHN0YXRlIDogKHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5uYXZpZ2FibGUgOiBudWxsKTtcbiAgICB9LFxuXG4gICAgLy8gT3duIHBhcmFtZXRlcnMgZm9yIHRoaXMgc3RhdGUuIHN0YXRlLnVybC5wYXJhbXMgaXMgYWxyZWFkeSBidWlsdCBhdCB0aGlzIHBvaW50LiBDcmVhdGUgYW5kIGFkZCBub24tdXJsIHBhcmFtc1xuICAgIG93blBhcmFtczogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBzdGF0ZS51cmwgJiYgc3RhdGUudXJsLnBhcmFtcyB8fCBuZXcgJCRVTUZQLlBhcmFtU2V0KCk7XG4gICAgICBmb3JFYWNoKHN0YXRlLnBhcmFtcyB8fCB7fSwgZnVuY3Rpb24oY29uZmlnLCBpZCkge1xuICAgICAgICBpZiAoIXBhcmFtc1tpZF0pIHBhcmFtc1tpZF0gPSBuZXcgJCRVTUZQLlBhcmFtKGlkLCBudWxsLCBjb25maWcsIFwiY29uZmlnXCIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cbiAgICAvLyBEZXJpdmUgcGFyYW1ldGVycyBmb3IgdGhpcyBzdGF0ZSBhbmQgZW5zdXJlIHRoZXkncmUgYSBzdXBlci1zZXQgb2YgcGFyZW50J3MgcGFyYW1ldGVyc1xuICAgIHBhcmFtczogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBvd25QYXJhbXMgPSBwaWNrKHN0YXRlLm93blBhcmFtcywgc3RhdGUub3duUGFyYW1zLiQka2V5cygpKTtcbiAgICAgIHJldHVybiBzdGF0ZS5wYXJlbnQgJiYgc3RhdGUucGFyZW50LnBhcmFtcyA/IGV4dGVuZChzdGF0ZS5wYXJlbnQucGFyYW1zLiQkbmV3KCksIG93blBhcmFtcykgOiBuZXcgJCRVTUZQLlBhcmFtU2V0KCk7XG4gICAgfSxcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGV4cGxpY2l0IG11bHRpLXZpZXcgY29uZmlndXJhdGlvbiwgbWFrZSBvbmUgdXAgc28gd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIHRvIGhhbmRsZSBib3RoIGNhc2VzIGluIHRoZSB2aWV3IGRpcmVjdGl2ZSBsYXRlci4gTm90ZSB0aGF0IGhhdmluZyBhbiBleHBsaWNpdFxuICAgIC8vICd2aWV3cycgcHJvcGVydHkgd2lsbCBtZWFuIHRoZSBkZWZhdWx0IHVubmFtZWQgdmlldyBwcm9wZXJ0aWVzIGFyZSBpZ25vcmVkLiBUaGlzXG4gICAgLy8gaXMgYWxzbyBhIGdvb2QgdGltZSB0byByZXNvbHZlIHZpZXcgbmFtZXMgdG8gYWJzb2x1dGUgbmFtZXMsIHNvIGV2ZXJ5dGhpbmcgaXMgYVxuICAgIC8vIHN0cmFpZ2h0IGxvb2t1cCBhdCBsaW5rIHRpbWUuXG4gICAgdmlld3M6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICB2YXIgdmlld3MgPSB7fTtcblxuICAgICAgZm9yRWFjaChpc0RlZmluZWQoc3RhdGUudmlld3MpID8gc3RhdGUudmlld3MgOiB7ICcnOiBzdGF0ZSB9LCBmdW5jdGlvbiAodmlldywgbmFtZSkge1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdAJykgPCAwKSBuYW1lICs9ICdAJyArIHN0YXRlLnBhcmVudC5uYW1lO1xuICAgICAgICB2aWV3LnJlc29sdmVBcyA9IHZpZXcucmVzb2x2ZUFzIHx8IHN0YXRlLnJlc29sdmVBcyB8fCAnJHJlc29sdmUnO1xuICAgICAgICB2aWV3c1tuYW1lXSA9IHZpZXc7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB2aWV3cztcbiAgICB9LFxuXG4gICAgLy8gS2VlcCBhIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZSBhcyB0aGlzIGlzIG5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cbiAgICBwYXRoOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5wYXRoLmNvbmNhdChzdGF0ZSkgOiBbXTsgLy8gZXhjbHVkZSByb290IGZyb20gcGF0aFxuICAgIH0sXG5cbiAgICAvLyBTcGVlZCB1cCAkc3RhdGUuY29udGFpbnMoKSBhcyBpdCdzIHVzZWQgYSBsb3RcbiAgICBpbmNsdWRlczogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IHN0YXRlLnBhcmVudCA/IGV4dGVuZCh7fSwgc3RhdGUucGFyZW50LmluY2x1ZGVzKSA6IHt9O1xuICAgICAgaW5jbHVkZXNbc3RhdGUubmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGluY2x1ZGVzO1xuICAgIH0sXG5cbiAgICAkZGVsZWdhdGVzOiB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzUmVsYXRpdmUoc3RhdGVOYW1lKSB7XG4gICAgcmV0dXJuIHN0YXRlTmFtZS5pbmRleE9mKFwiLlwiKSA9PT0gMCB8fCBzdGF0ZU5hbWUuaW5kZXhPZihcIl5cIikgPT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kU3RhdGUoc3RhdGVPck5hbWUsIGJhc2UpIHtcbiAgICBpZiAoIXN0YXRlT3JOYW1lKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgdmFyIGlzU3RyID0gaXNTdHJpbmcoc3RhdGVPck5hbWUpLFxuICAgICAgICBuYW1lICA9IGlzU3RyID8gc3RhdGVPck5hbWUgOiBzdGF0ZU9yTmFtZS5uYW1lLFxuICAgICAgICBwYXRoICA9IGlzUmVsYXRpdmUobmFtZSk7XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgaWYgKCFiYXNlKSB0aHJvdyBuZXcgRXJyb3IoXCJObyByZWZlcmVuY2UgcG9pbnQgZ2l2ZW4gZm9yIHBhdGggJ1wiICArIG5hbWUgKyBcIidcIik7XG4gICAgICBiYXNlID0gZmluZFN0YXRlKGJhc2UpO1xuICAgICAgXG4gICAgICB2YXIgcmVsID0gbmFtZS5zcGxpdChcIi5cIiksIGkgPSAwLCBwYXRoTGVuZ3RoID0gcmVsLmxlbmd0aCwgY3VycmVudCA9IGJhc2U7XG5cbiAgICAgIGZvciAoOyBpIDwgcGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWxbaV0gPT09IFwiXCIgJiYgaSA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBiYXNlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxbaV0gPT09IFwiXlwiKSB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50LnBhcmVudCkgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCAnXCIgKyBuYW1lICsgXCInIG5vdCB2YWxpZCBmb3Igc3RhdGUgJ1wiICsgYmFzZS5uYW1lICsgXCInXCIpO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlbCA9IHJlbC5zbGljZShpKS5qb2luKFwiLlwiKTtcbiAgICAgIG5hbWUgPSBjdXJyZW50Lm5hbWUgKyAoY3VycmVudC5uYW1lICYmIHJlbCA/IFwiLlwiIDogXCJcIikgKyByZWw7XG4gICAgfVxuICAgIHZhciBzdGF0ZSA9IHN0YXRlc1tuYW1lXTtcblxuICAgIGlmIChzdGF0ZSAmJiAoaXNTdHIgfHwgKCFpc1N0ciAmJiAoc3RhdGUgPT09IHN0YXRlT3JOYW1lIHx8IHN0YXRlLnNlbGYgPT09IHN0YXRlT3JOYW1lKSkpKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBxdWV1ZVN0YXRlKHBhcmVudE5hbWUsIHN0YXRlKSB7XG4gICAgaWYgKCFxdWV1ZVtwYXJlbnROYW1lXSkge1xuICAgICAgcXVldWVbcGFyZW50TmFtZV0gPSBbXTtcbiAgICB9XG4gICAgcXVldWVbcGFyZW50TmFtZV0ucHVzaChzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaFF1ZXVlZENoaWxkcmVuKHBhcmVudE5hbWUpIHtcbiAgICB2YXIgcXVldWVkID0gcXVldWVbcGFyZW50TmFtZV0gfHwgW107XG4gICAgd2hpbGUocXVldWVkLmxlbmd0aCkge1xuICAgICAgcmVnaXN0ZXJTdGF0ZShxdWV1ZWQuc2hpZnQoKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJTdGF0ZShzdGF0ZSkge1xuICAgIC8vIFdyYXAgYSBuZXcgb2JqZWN0IGFyb3VuZCB0aGUgc3RhdGUgc28gd2UgY2FuIHN0b3JlIG91ciBwcml2YXRlIGRldGFpbHMgZWFzaWx5LlxuICAgIHN0YXRlID0gaW5oZXJpdChzdGF0ZSwge1xuICAgICAgc2VsZjogc3RhdGUsXG4gICAgICByZXNvbHZlOiBzdGF0ZS5yZXNvbHZlIHx8IHt9LFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uYW1lOyB9XG4gICAgfSk7XG5cbiAgICB2YXIgbmFtZSA9IHN0YXRlLm5hbWU7XG4gICAgaWYgKCFpc1N0cmluZyhuYW1lKSB8fCBuYW1lLmluZGV4T2YoJ0AnKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtdXN0IGhhdmUgYSB2YWxpZCBuYW1lXCIpO1xuICAgIGlmIChzdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHRocm93IG5ldyBFcnJvcihcIlN0YXRlICdcIiArIG5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWZpbmVkXCIpO1xuXG4gICAgLy8gR2V0IHBhcmVudCBuYW1lXG4gICAgdmFyIHBhcmVudE5hbWUgPSAobmFtZS5pbmRleE9mKCcuJykgIT09IC0xKSA/IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGFzdEluZGV4T2YoJy4nKSlcbiAgICAgICAgOiAoaXNTdHJpbmcoc3RhdGUucGFyZW50KSkgPyBzdGF0ZS5wYXJlbnRcbiAgICAgICAgOiAoaXNPYmplY3Qoc3RhdGUucGFyZW50KSAmJiBpc1N0cmluZyhzdGF0ZS5wYXJlbnQubmFtZSkpID8gc3RhdGUucGFyZW50Lm5hbWVcbiAgICAgICAgOiAnJztcblxuICAgIC8vIElmIHBhcmVudCBpcyBub3QgcmVnaXN0ZXJlZCB5ZXQsIGFkZCBzdGF0ZSB0byBxdWV1ZSBhbmQgcmVnaXN0ZXIgbGF0ZXJcbiAgICBpZiAocGFyZW50TmFtZSAmJiAhc3RhdGVzW3BhcmVudE5hbWVdKSB7XG4gICAgICByZXR1cm4gcXVldWVTdGF0ZShwYXJlbnROYW1lLCBzdGF0ZS5zZWxmKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc3RhdGVCdWlsZGVyKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihzdGF0ZUJ1aWxkZXJba2V5XSkpIHN0YXRlW2tleV0gPSBzdGF0ZUJ1aWxkZXJba2V5XShzdGF0ZSwgc3RhdGVCdWlsZGVyLiRkZWxlZ2F0ZXNba2V5XSk7XG4gICAgfVxuICAgIHN0YXRlc1tuYW1lXSA9IHN0YXRlO1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIHN0YXRlIGluIHRoZSBnbG9iYWwgc3RhdGUgbGlzdCBhbmQgd2l0aCAkdXJsUm91dGVyIGlmIG5lY2Vzc2FyeS5cbiAgICBpZiAoIXN0YXRlW2Fic3RyYWN0S2V5XSAmJiBzdGF0ZS51cmwpIHtcbiAgICAgICR1cmxSb3V0ZXJQcm92aWRlci53aGVuKHN0YXRlLnVybCwgWyckbWF0Y2gnLCAnJHN0YXRlUGFyYW1zJywgZnVuY3Rpb24gKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSB7XG4gICAgICAgIGlmICgkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlICE9IHN0YXRlIHx8ICFlcXVhbEZvcktleXMoJG1hdGNoLCAkc3RhdGVQYXJhbXMpKSB7XG4gICAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbyhzdGF0ZSwgJG1hdGNoLCB7IGluaGVyaXQ6IHRydWUsIGxvY2F0aW9uOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGFueSBxdWV1ZWQgY2hpbGRyZW5cbiAgICBmbHVzaFF1ZXVlZENoaWxkcmVuKG5hbWUpO1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLy8gQ2hlY2tzIHRleHQgdG8gc2VlIGlmIGl0IGxvb2tzIGxpa2UgYSBnbG9iLlxuICBmdW5jdGlvbiBpc0dsb2IgKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5pbmRleE9mKCcqJykgPiAtMTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBnbG9iIG1hdGNoZXMgY3VycmVudCAkc3RhdGUgbmFtZS5cbiAgZnVuY3Rpb24gZG9lc1N0YXRlTWF0Y2hHbG9iIChnbG9iKSB7XG4gICAgdmFyIGdsb2JTZWdtZW50cyA9IGdsb2Iuc3BsaXQoJy4nKSxcbiAgICAgICAgc2VnbWVudHMgPSAkc3RhdGUuJGN1cnJlbnQubmFtZS5zcGxpdCgnLicpO1xuXG4gICAgLy9tYXRjaCBzaW5nbGUgc3RhcnNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGdsb2JTZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChnbG9iU2VnbWVudHNbaV0gPT09ICcqJykge1xuICAgICAgICBzZWdtZW50c1tpXSA9ICcqJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL21hdGNoIGdyZWVkeSBzdGFydHNcbiAgICBpZiAoZ2xvYlNlZ21lbnRzWzBdID09PSAnKionKSB7XG4gICAgICAgc2VnbWVudHMgPSBzZWdtZW50cy5zbGljZShpbmRleE9mKHNlZ21lbnRzLCBnbG9iU2VnbWVudHNbMV0pKTtcbiAgICAgICBzZWdtZW50cy51bnNoaWZ0KCcqKicpO1xuICAgIH1cbiAgICAvL21hdGNoIGdyZWVkeSBlbmRzXG4gICAgaWYgKGdsb2JTZWdtZW50c1tnbG9iU2VnbWVudHMubGVuZ3RoIC0gMV0gPT09ICcqKicpIHtcbiAgICAgICBzZWdtZW50cy5zcGxpY2UoaW5kZXhPZihzZWdtZW50cywgZ2xvYlNlZ21lbnRzW2dsb2JTZWdtZW50cy5sZW5ndGggLSAyXSkgKyAxLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICBzZWdtZW50cy5wdXNoKCcqKicpO1xuICAgIH1cblxuICAgIGlmIChnbG9iU2VnbWVudHMubGVuZ3RoICE9IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBzZWdtZW50cy5qb2luKCcnKSA9PT0gZ2xvYlNlZ21lbnRzLmpvaW4oJycpO1xuICB9XG5cblxuICAvLyBJbXBsaWNpdCByb290IHN0YXRlIHRoYXQgaXMgYWx3YXlzIGFjdGl2ZVxuICByb290ID0gcmVnaXN0ZXJTdGF0ZSh7XG4gICAgbmFtZTogJycsXG4gICAgdXJsOiAnXicsXG4gICAgdmlld3M6IG51bGwsXG4gICAgJ2Fic3RyYWN0JzogdHJ1ZVxuICB9KTtcbiAgcm9vdC5uYXZpZ2FibGUgPSBudWxsO1xuXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUHJvdmlkZXIjZGVjb3JhdG9yXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFsbG93cyB5b3UgdG8gZXh0ZW5kIChjYXJlZnVsbHkpIG9yIG92ZXJyaWRlIChhdCB5b3VyIG93biBwZXJpbCkgdGhlIFxuICAgKiBgc3RhdGVCdWlsZGVyYCBvYmplY3QgdXNlZCBpbnRlcm5hbGx5IGJ5IGAkc3RhdGVQcm92aWRlcmAuIFRoaXMgY2FuIGJlIHVzZWQgXG4gICAqIHRvIGFkZCBjdXN0b20gZnVuY3Rpb25hbGl0eSB0byB1aS1yb3V0ZXIsIGZvciBleGFtcGxlIGluZmVycmluZyB0ZW1wbGF0ZVVybCBcbiAgICogYmFzZWQgb24gdGhlIHN0YXRlIG5hbWUuXG4gICAqXG4gICAqIFdoZW4gcGFzc2luZyBvbmx5IGEgbmFtZSwgaXQgcmV0dXJucyB0aGUgY3VycmVudCAob3JpZ2luYWwgb3IgZGVjb3JhdGVkKSBidWlsZGVyXG4gICAqIGZ1bmN0aW9uIHRoYXQgbWF0Y2hlcyBgbmFtZWAuXG4gICAqXG4gICAqIFRoZSBidWlsZGVyIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBkZWNvcmF0ZWQgYXJlIGxpc3RlZCBiZWxvdy4gVGhvdWdoIG5vdCBhbGxcbiAgICogbmVjZXNzYXJpbHkgaGF2ZSBhIGdvb2QgdXNlIGNhc2UgZm9yIGRlY29yYXRpb24sIHRoYXQgaXMgdXAgdG8geW91IHRvIGRlY2lkZS5cbiAgICpcbiAgICogSW4gYWRkaXRpb24sIHVzZXJzIGNhbiBhdHRhY2ggY3VzdG9tIGRlY29yYXRvcnMsIHdoaWNoIHdpbGwgZ2VuZXJhdGUgbmV3IFxuICAgKiBwcm9wZXJ0aWVzIHdpdGhpbiB0aGUgc3RhdGUncyBpbnRlcm5hbCBkZWZpbml0aW9uLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gY2xlYXIgXG4gICAqIHVzZS1jYXNlIGZvciB0aGlzIGJleW9uZCBhY2Nlc3NpbmcgaW50ZXJuYWwgc3RhdGVzIChpLmUuICRzdGF0ZS4kY3VycmVudCksIFxuICAgKiBob3dldmVyLCBleHBlY3QgdGhpcyB0byBiZWNvbWUgaW5jcmVhc2luZ2x5IHJlbGV2YW50IGFzIHdlIGludHJvZHVjZSBhZGRpdGlvbmFsIFxuICAgKiBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzLlxuICAgKlxuICAgKiAqKldhcm5pbmcqKjogRGVjb3JhdG9ycyBzaG91bGQgbm90IGJlIGludGVyZGVwZW5kZW50IGJlY2F1c2UgdGhlIG9yZGVyIG9mIFxuICAgKiBleGVjdXRpb24gb2YgdGhlIGJ1aWxkZXIgZnVuY3Rpb25zIGluIG5vbi1kZXRlcm1pbmlzdGljLiBCdWlsZGVyIGZ1bmN0aW9ucyBcbiAgICogc2hvdWxkIG9ubHkgYmUgZGVwZW5kZW50IG9uIHRoZSBzdGF0ZSBkZWZpbml0aW9uIG9iamVjdCBhbmQgc3VwZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqXG4gICAqIEV4aXN0aW5nIGJ1aWxkZXIgZnVuY3Rpb25zIGFuZCBjdXJyZW50IHJldHVybiB2YWx1ZXM6XG4gICAqXG4gICAqIC0gKipwYXJlbnQqKiBge29iamVjdH1gIC0gcmV0dXJucyB0aGUgcGFyZW50IHN0YXRlIG9iamVjdC5cbiAgICogLSAqKmRhdGEqKiBge29iamVjdH1gIC0gcmV0dXJucyBzdGF0ZSBkYXRhLCBpbmNsdWRpbmcgYW55IGluaGVyaXRlZCBkYXRhIHRoYXQgaXMgbm90XG4gICAqICAgb3ZlcnJpZGRlbiBieSBvd24gdmFsdWVzIChpZiBhbnkpLlxuICAgKiAtICoqdXJsKiogYHtvYmplY3R9YCAtIHJldHVybnMgYSB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyIFVybE1hdGNoZXJ9XG4gICAqICAgb3IgYG51bGxgLlxuICAgKiAtICoqbmF2aWdhYmxlKiogYHtvYmplY3R9YCAtIHJldHVybnMgY2xvc2VzdCBhbmNlc3RvciBzdGF0ZSB0aGF0IGhhcyBhIFVSTCAoYWthIGlzIFxuICAgKiAgIG5hdmlnYWJsZSkuXG4gICAqIC0gKipwYXJhbXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZSBwYXJhbXMgdGhhdCBhcmUgZW5zdXJlZCB0byBcbiAgICogICBiZSBhIHN1cGVyLXNldCBvZiBwYXJlbnQncyBwYXJhbXMuXG4gICAqIC0gKip2aWV3cyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGEgdmlld3Mgb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGFuIGFic29sdXRlIHZpZXcgXG4gICAqICAgbmFtZSAoaS5lLiBcInZpZXdOYW1lQHN0YXRlTmFtZVwiKSBhbmQgZWFjaCB2YWx1ZSBpcyB0aGUgY29uZmlnIG9iamVjdCBcbiAgICogICAodGVtcGxhdGUsIGNvbnRyb2xsZXIpIGZvciB0aGUgdmlldy4gRXZlbiB3aGVuIHlvdSBkb24ndCB1c2UgdGhlIHZpZXdzIG9iamVjdCBcbiAgICogICBleHBsaWNpdGx5IG9uIGEgc3RhdGUgY29uZmlnLCBvbmUgaXMgc3RpbGwgY3JlYXRlZCBmb3IgeW91IGludGVybmFsbHkuXG4gICAqICAgU28gYnkgZGVjb3JhdGluZyB0aGlzIGJ1aWxkZXIgZnVuY3Rpb24geW91IGhhdmUgYWNjZXNzIHRvIGRlY29yYXRpbmcgdGVtcGxhdGUgXG4gICAqICAgYW5kIGNvbnRyb2xsZXIgcHJvcGVydGllcy5cbiAgICogLSAqKm93blBhcmFtcyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGFuIGFycmF5IG9mIHBhcmFtcyB0aGF0IGJlbG9uZyB0byB0aGUgc3RhdGUsIFxuICAgKiAgIG5vdCBpbmNsdWRpbmcgYW55IHBhcmFtcyBkZWZpbmVkIGJ5IGFuY2VzdG9yIHN0YXRlcy5cbiAgICogLSAqKnBhdGgqKiBge3N0cmluZ31gIC0gcmV0dXJucyB0aGUgZnVsbCBwYXRoIGZyb20gdGhlIHJvb3QgZG93biB0byB0aGlzIHN0YXRlLiBcbiAgICogICBOZWVkZWQgZm9yIHN0YXRlIGFjdGl2YXRpb24uXG4gICAqIC0gKippbmNsdWRlcyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIGV2ZXJ5IHN0YXRlIHRoYXQgXG4gICAqICAgd291bGQgcGFzcyBhIGAkc3RhdGUuaW5jbHVkZXMoKWAgdGVzdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPHByZT5cbiAgICogLy8gT3ZlcnJpZGUgdGhlIGludGVybmFsICd2aWV3cycgYnVpbGRlciB3aXRoIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgc3RhdGVcbiAgICogLy8gZGVmaW5pdGlvbiwgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBmdW5jdGlvbiBiZWluZyBvdmVycmlkZGVuOlxuICAgKiAkc3RhdGVQcm92aWRlci5kZWNvcmF0b3IoJ3ZpZXdzJywgZnVuY3Rpb24gKHN0YXRlLCBwYXJlbnQpIHtcbiAgICogICB2YXIgcmVzdWx0ID0ge30sXG4gICAqICAgICAgIHZpZXdzID0gcGFyZW50KHN0YXRlKTtcbiAgICpcbiAgICogICBhbmd1bGFyLmZvckVhY2godmlld3MsIGZ1bmN0aW9uIChjb25maWcsIG5hbWUpIHtcbiAgICogICAgIHZhciBhdXRvTmFtZSA9IChzdGF0ZS5uYW1lICsgJy4nICsgbmFtZSkucmVwbGFjZSgnLicsICcvJyk7XG4gICAqICAgICBjb25maWcudGVtcGxhdGVVcmwgPSBjb25maWcudGVtcGxhdGVVcmwgfHwgJy9wYXJ0aWFscy8nICsgYXV0b05hbWUgKyAnLmh0bWwnO1xuICAgKiAgICAgcmVzdWx0W25hbWVdID0gY29uZmlnO1xuICAgKiAgIH0pO1xuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH0pO1xuICAgKlxuICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZSgnaG9tZScsIHtcbiAgICogICB2aWV3czoge1xuICAgKiAgICAgJ2NvbnRhY3QubGlzdCc6IHsgY29udHJvbGxlcjogJ0xpc3RDb250cm9sbGVyJyB9LFxuICAgKiAgICAgJ2NvbnRhY3QuaXRlbSc6IHsgY29udHJvbGxlcjogJ0l0ZW1Db250cm9sbGVyJyB9XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gLi4uXG4gICAqXG4gICAqICRzdGF0ZS5nbygnaG9tZScpO1xuICAgKiAvLyBBdXRvLXBvcHVsYXRlcyBsaXN0IGFuZCBpdGVtIHZpZXdzIHdpdGggL3BhcnRpYWxzL2hvbWUvY29udGFjdC9saXN0Lmh0bWwsXG4gICAqIC8vIGFuZCAvcGFydGlhbHMvaG9tZS9jb250YWN0L2l0ZW0uaHRtbCwgcmVzcGVjdGl2ZWx5LlxuICAgKiA8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGJ1aWxkZXIgZnVuY3Rpb24gdG8gZGVjb3JhdGUuIFxuICAgKiBAcGFyYW0ge29iamVjdH0gZnVuYyBBIGZ1bmN0aW9uIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGRlY29yYXRpbmcgdGhlIG9yaWdpbmFsIFxuICAgKiBidWlsZGVyIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHBhcmFtZXRlcnM6XG4gICAqXG4gICAqICAgLSBge29iamVjdH1gIC0gc3RhdGUgLSBUaGUgc3RhdGUgY29uZmlnIG9iamVjdC5cbiAgICogICAtIGB7b2JqZWN0fWAgLSBzdXBlciAtIFRoZSBvcmlnaW5hbCBidWlsZGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICRzdGF0ZVByb3ZpZGVyIC0gJHN0YXRlUHJvdmlkZXIgaW5zdGFuY2VcbiAgICovXG4gIHRoaXMuZGVjb3JhdG9yID0gZGVjb3JhdG9yO1xuICBmdW5jdGlvbiBkZWNvcmF0b3IobmFtZSwgZnVuYykge1xuICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgIGlmIChpc1N0cmluZyhuYW1lKSAmJiAhaXNEZWZpbmVkKGZ1bmMpKSB7XG4gICAgICByZXR1cm4gc3RhdGVCdWlsZGVyW25hbWVdO1xuICAgIH1cbiAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykgfHwgIWlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHN0YXRlQnVpbGRlcltuYW1lXSAmJiAhc3RhdGVCdWlsZGVyLiRkZWxlZ2F0ZXNbbmFtZV0pIHtcbiAgICAgIHN0YXRlQnVpbGRlci4kZGVsZWdhdGVzW25hbWVdID0gc3RhdGVCdWlsZGVyW25hbWVdO1xuICAgIH1cbiAgICBzdGF0ZUJ1aWxkZXJbbmFtZV0gPSBmdW5jO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUHJvdmlkZXIjc3RhdGVcbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVnaXN0ZXJzIGEgc3RhdGUgY29uZmlndXJhdGlvbiB1bmRlciBhIGdpdmVuIHN0YXRlIG5hbWUuIFRoZSBzdGF0ZUNvbmZpZyBvYmplY3RcbiAgICogaGFzIHRoZSBmb2xsb3dpbmcgYWNjZXB0YWJsZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIHVuaXF1ZSBzdGF0ZSBuYW1lLCBlLmcuIFwiaG9tZVwiLCBcImFib3V0XCIsIFwiY29udGFjdHNcIi5cbiAgICogVG8gY3JlYXRlIGEgcGFyZW50L2NoaWxkIHN0YXRlIHVzZSBhIGRvdCwgZS5nLiBcImFib3V0LnNhbGVzXCIsIFwiaG9tZS5uZXdlc3RcIi5cbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlQ29uZmlnIFN0YXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbj19IHN0YXRlQ29uZmlnLnRlbXBsYXRlXG4gICAqIDxhIGlkPSd0ZW1wbGF0ZSc+PC9hPlxuICAgKiAgIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICogICBhbiBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIHdoaWNoIHNob3VsZCBiZSB1c2VkIGJ5IHRoZSB1aVZpZXcgZGlyZWN0aXZlcy4gVGhpcyBwcm9wZXJ0eSBcbiAgICogICB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGVtcGxhdGVVcmwuXG4gICAqICAgXG4gICAqICAgSWYgYHRlbXBsYXRlYCBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICpcbiAgICogICAtIHthcnJheS4mbHQ7b2JqZWN0Jmd0O30gLSBzdGF0ZSBwYXJhbWV0ZXJzIGV4dHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50ICRsb2NhdGlvbi5wYXRoKCkgYnlcbiAgICogICAgIGFwcGx5aW5nIHRoZSBjdXJyZW50IHN0YXRlXG4gICAqXG4gICAqIDxwcmU+dGVtcGxhdGU6XG4gICAqICAgXCI8aDE+aW5saW5lIHRlbXBsYXRlIGRlZmluaXRpb248L2gxPlwiICtcbiAgICogICBcIjxkaXYgdWktdmlldz48L2Rpdj5cIjwvcHJlPlxuICAgKiA8cHJlPnRlbXBsYXRlOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICogICAgICAgcmV0dXJuIFwiPGgxPmdlbmVyYXRlZCB0ZW1wbGF0ZTwvaDE+XCI7IH08L3ByZT5cbiAgICogPC9kaXY+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9uPX0gc3RhdGVDb25maWcudGVtcGxhdGVVcmxcbiAgICogPGEgaWQ9J3RlbXBsYXRlVXJsJz48L2E+XG4gICAqXG4gICAqICAgcGF0aCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwYXRoIHRvIGFuIGh0bWxcbiAgICogICB0ZW1wbGF0ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IHVpVmlldy5cbiAgICogICBcbiAgICogICBJZiBgdGVtcGxhdGVVcmxgIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgIC0ge2FycmF5LiZsdDtvYmplY3QmZ3Q7fSAtIHN0YXRlIHBhcmFtZXRlcnMgZXh0cmFjdGVkIGZyb20gdGhlIGN1cnJlbnQgJGxvY2F0aW9uLnBhdGgoKSBieSBcbiAgICogICAgIGFwcGx5aW5nIHRoZSBjdXJyZW50IHN0YXRlXG4gICAqXG4gICAqIDxwcmU+dGVtcGxhdGVVcmw6IFwiaG9tZS5odG1sXCI8L3ByZT5cbiAgICogPHByZT50ZW1wbGF0ZVVybDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAqICAgICByZXR1cm4gbXlUZW1wbGF0ZXNbcGFyYW1zLnBhZ2VJZF07IH08L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbj19IHN0YXRlQ29uZmlnLnRlbXBsYXRlUHJvdmlkZXJcbiAgICogPGEgaWQ9J3RlbXBsYXRlUHJvdmlkZXInPjwvYT5cbiAgICogICAgUHJvdmlkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIEhUTUwgY29udGVudCBzdHJpbmcuXG4gICAqIDxwcmU+IHRlbXBsYXRlUHJvdmlkZXI6XG4gICAqICAgICAgIGZ1bmN0aW9uKE15VGVtcGxhdGVTZXJ2aWNlLCBwYXJhbXMpIHtcbiAgICogICAgICAgICByZXR1cm4gTXlUZW1wbGF0ZVNlcnZpY2UuZ2V0VGVtcGxhdGUocGFyYW1zLnBhZ2VJZCk7XG4gICAqICAgICAgIH08L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb249fSBzdGF0ZUNvbmZpZy5jb250cm9sbGVyXG4gICAqIDxhIGlkPSdjb250cm9sbGVyJz48L2E+XG4gICAqXG4gICAqICBDb250cm9sbGVyIGZuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCBuZXdseVxuICAgKiAgIHJlbGF0ZWQgc2NvcGUgb3IgdGhlIG5hbWUgb2YgYSByZWdpc3RlcmVkIGNvbnRyb2xsZXIgaWYgcGFzc2VkIGFzIGEgc3RyaW5nLlxuICAgKiAgIE9wdGlvbmFsbHksIHRoZSBDb250cm9sbGVyQXMgbWF5IGJlIGRlY2xhcmVkIGhlcmUuXG4gICAqIDxwcmU+Y29udHJvbGxlcjogXCJNeVJlZ2lzdGVyZWRDb250cm9sbGVyXCI8L3ByZT5cbiAgICogPHByZT5jb250cm9sbGVyOlxuICAgKiAgICAgXCJNeVJlZ2lzdGVyZWRDb250cm9sbGVyIGFzIGZvb0N0cmxcIn08L3ByZT5cbiAgICogPHByZT5jb250cm9sbGVyOiBmdW5jdGlvbigkc2NvcGUsIE15U2VydmljZSkge1xuICAgKiAgICAgJHNjb3BlLmRhdGEgPSBNeVNlcnZpY2UuZ2V0RGF0YSgpOyB9PC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBzdGF0ZUNvbmZpZy5jb250cm9sbGVyUHJvdmlkZXJcbiAgICogPGEgaWQ9J2NvbnRyb2xsZXJQcm92aWRlcic+PC9hPlxuICAgKlxuICAgKiBJbmplY3RhYmxlIHByb3ZpZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYWN0dWFsIGNvbnRyb2xsZXIgb3Igc3RyaW5nLlxuICAgKiA8cHJlPmNvbnRyb2xsZXJQcm92aWRlcjpcbiAgICogICBmdW5jdGlvbihNeVJlc29sdmVEYXRhKSB7XG4gICAqICAgICBpZiAoTXlSZXNvbHZlRGF0YS5mb28pXG4gICAqICAgICAgIHJldHVybiBcIkZvb0N0cmxcIlxuICAgKiAgICAgZWxzZSBpZiAoTXlSZXNvbHZlRGF0YS5iYXIpXG4gICAqICAgICAgIHJldHVybiBcIkJhckN0cmxcIjtcbiAgICogICAgIGVsc2UgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgKiAgICAgICAkc2NvcGUuYmF6ID0gXCJRdXhcIjtcbiAgICogICAgIH1cbiAgICogICB9PC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gc3RhdGVDb25maWcuY29udHJvbGxlckFzXG4gICAqIDxhIGlkPSdjb250cm9sbGVyQXMnPjwvYT5cbiAgICogXG4gICAqIEEgY29udHJvbGxlciBhbGlhcyBuYW1lLiBJZiBwcmVzZW50IHRoZSBjb250cm9sbGVyIHdpbGwgYmVcbiAgICogICBwdWJsaXNoZWQgdG8gc2NvcGUgdW5kZXIgdGhlIGNvbnRyb2xsZXJBcyBuYW1lLlxuICAgKiA8cHJlPmNvbnRyb2xsZXJBczogXCJteUN0cmxcIjwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3Q9fSBzdGF0ZUNvbmZpZy5wYXJlbnRcbiAgICogPGEgaWQ9J3BhcmVudCc+PC9hPlxuICAgKiBPcHRpb25hbGx5IHNwZWNpZmllcyB0aGUgcGFyZW50IHN0YXRlIG9mIHRoaXMgc3RhdGUuXG4gICAqXG4gICAqIDxwcmU+cGFyZW50OiAncGFyZW50U3RhdGUnPC9wcmU+XG4gICAqIDxwcmU+cGFyZW50OiBwYXJlbnRTdGF0ZSAvLyBKUyB2YXJpYWJsZTwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdD19IHN0YXRlQ29uZmlnLnJlc29sdmVcbiAgICogPGEgaWQ9J3Jlc29sdmUnPjwvYT5cbiAgICpcbiAgICogQW4gb3B0aW9uYWwgbWFwJmx0O3N0cmluZywgZnVuY3Rpb24mZ3Q7IG9mIGRlcGVuZGVuY2llcyB3aGljaFxuICAgKiAgIHNob3VsZCBiZSBpbmplY3RlZCBpbnRvIHRoZSBjb250cm9sbGVyLiBJZiBhbnkgb2YgdGhlc2UgZGVwZW5kZW5jaWVzIGFyZSBwcm9taXNlcywgXG4gICAqICAgdGhlIHJvdXRlciB3aWxsIHdhaXQgZm9yIHRoZW0gYWxsIHRvIGJlIHJlc29sdmVkIGJlZm9yZSB0aGUgY29udHJvbGxlciBpcyBpbnN0YW50aWF0ZWQuXG4gICAqICAgSWYgYWxsIHRoZSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgc3VjY2Vzc2Z1bGx5LCB0aGUgJHN0YXRlQ2hhbmdlU3VjY2VzcyBldmVudCBpcyBmaXJlZFxuICAgKiAgIGFuZCB0aGUgdmFsdWVzIG9mIHRoZSByZXNvbHZlZCBwcm9taXNlcyBhcmUgaW5qZWN0ZWQgaW50byBhbnkgY29udHJvbGxlcnMgdGhhdCByZWZlcmVuY2UgdGhlbS5cbiAgICogICBJZiBhbnkgIG9mIHRoZSBwcm9taXNlcyBhcmUgcmVqZWN0ZWQgdGhlICRzdGF0ZUNoYW5nZUVycm9yIGV2ZW50IGlzIGZpcmVkLlxuICAgKlxuICAgKiAgIFRoZSBtYXAgb2JqZWN0IGlzOlxuICAgKiAgIFxuICAgKiAgIC0ga2V5IC0ge3N0cmluZ306IG5hbWUgb2YgZGVwZW5kZW5jeSB0byBiZSBpbmplY3RlZCBpbnRvIGNvbnRyb2xsZXJcbiAgICogICAtIGZhY3RvcnkgLSB7c3RyaW5nfGZ1bmN0aW9ufTogSWYgc3RyaW5nIHRoZW4gaXQgaXMgYWxpYXMgZm9yIHNlcnZpY2UuIE90aGVyd2lzZSBpZiBmdW5jdGlvbiwgXG4gICAqICAgICBpdCBpcyBpbmplY3RlZCBhbmQgcmV0dXJuIHZhbHVlIGl0IHRyZWF0ZWQgYXMgZGVwZW5kZW5jeS4gSWYgcmVzdWx0IGlzIGEgcHJvbWlzZSwgaXQgaXMgXG4gICAqICAgICByZXNvbHZlZCBiZWZvcmUgaXRzIHZhbHVlIGlzIGluamVjdGVkIGludG8gY29udHJvbGxlci5cbiAgICpcbiAgICogPHByZT5yZXNvbHZlOiB7XG4gICAqICAgICBteVJlc29sdmUxOlxuICAgKiAgICAgICBmdW5jdGlvbigkaHR0cCwgJHN0YXRlUGFyYW1zKSB7XG4gICAqICAgICAgICAgcmV0dXJuICRodHRwLmdldChcIi9hcGkvZm9vcy9cIitzdGF0ZVBhcmFtcy5mb29JRCk7XG4gICAqICAgICAgIH1cbiAgICogICAgIH08L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBzdGF0ZUNvbmZpZy51cmxcbiAgICogPGEgaWQ9J3VybCc+PC9hPlxuICAgKlxuICAgKiAgIEEgdXJsIGZyYWdtZW50IHdpdGggb3B0aW9uYWwgcGFyYW1ldGVycy4gV2hlbiBhIHN0YXRlIGlzIG5hdmlnYXRlZCBvclxuICAgKiAgIHRyYW5zaXRpb25lZCB0bywgdGhlIGAkc3RhdGVQYXJhbXNgIHNlcnZpY2Ugd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBhbnkgXG4gICAqICAgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkLlxuICAgKlxuICAgKiAgIChTZWUge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBVcmxNYXRjaGVyfSBgVXJsTWF0Y2hlcmB9IGZvclxuICAgKiAgIG1vcmUgZGV0YWlscyBvbiBhY2NlcHRhYmxlIHBhdHRlcm5zIClcbiAgICpcbiAgICogZXhhbXBsZXM6XG4gICAqIDxwcmU+dXJsOiBcIi9ob21lXCJcbiAgICogdXJsOiBcIi91c2Vycy86dXNlcmlkXCJcbiAgICogdXJsOiBcIi9ib29rcy97Ym9va2lkOlthLXpBLVpfLV19XCJcbiAgICogdXJsOiBcIi9ib29rcy97Y2F0ZWdvcnlpZDppbnR9XCJcbiAgICogdXJsOiBcIi9ib29rcy97cHVibGlzaGVybmFtZTpzdHJpbmd9L3tjYXRlZ29yeWlkOmludH1cIlxuICAgKiB1cmw6IFwiL21lc3NhZ2VzP2JlZm9yZSZhZnRlclwiXG4gICAqIHVybDogXCIvbWVzc2FnZXM/e2JlZm9yZTpkYXRlfSZ7YWZ0ZXI6ZGF0ZX1cIlxuICAgKiB1cmw6IFwiL21lc3NhZ2VzLzptYWlsYm94aWQ/e2JlZm9yZTpkYXRlfSZ7YWZ0ZXI6ZGF0ZX1cIlxuICAgKiA8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3Q9fSBzdGF0ZUNvbmZpZy52aWV3c1xuICAgKiA8YSBpZD0ndmlld3MnPjwvYT5cbiAgICogYW4gb3B0aW9uYWwgbWFwJmx0O3N0cmluZywgb2JqZWN0Jmd0OyB3aGljaCBkZWZpbmVkIG11bHRpcGxlIHZpZXdzLCBvciB0YXJnZXRzIHZpZXdzXG4gICAqIG1hbnVhbGx5L2V4cGxpY2l0bHkuXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiBUYXJnZXRzIHRocmVlIG5hbWVkIGB1aS12aWV3YHMgaW4gdGhlIHBhcmVudCBzdGF0ZSdzIHRlbXBsYXRlXG4gICAqIDxwcmU+dmlld3M6IHtcbiAgICogICAgIGhlYWRlcjoge1xuICAgKiAgICAgICBjb250cm9sbGVyOiBcImhlYWRlckN0cmxcIixcbiAgICogICAgICAgdGVtcGxhdGVVcmw6IFwiaGVhZGVyLmh0bWxcIlxuICAgKiAgICAgfSwgYm9keToge1xuICAgKiAgICAgICBjb250cm9sbGVyOiBcImJvZHlDdHJsXCIsXG4gICAqICAgICAgIHRlbXBsYXRlVXJsOiBcImJvZHkuaHRtbFwiXG4gICAqICAgICB9LCBmb290ZXI6IHtcbiAgICogICAgICAgY29udHJvbGxlcjogXCJmb290Q3RybFwiLFxuICAgKiAgICAgICB0ZW1wbGF0ZVVybDogXCJmb290ZXIuaHRtbFwiXG4gICAqICAgICB9XG4gICAqICAgfTwvcHJlPlxuICAgKlxuICAgKiBUYXJnZXRzIG5hbWVkIGB1aS12aWV3PVwiaGVhZGVyXCJgIGZyb20gZ3JhbmRwYXJlbnQgc3RhdGUgJ3RvcCcncyB0ZW1wbGF0ZSwgYW5kIG5hbWVkIGB1aS12aWV3PVwiYm9keVwiIGZyb20gcGFyZW50IHN0YXRlJ3MgdGVtcGxhdGUuXG4gICAqIDxwcmU+dmlld3M6IHtcbiAgICogICAgICdoZWFkZXJAdG9wJzoge1xuICAgKiAgICAgICBjb250cm9sbGVyOiBcIm1zZ0hlYWRlckN0cmxcIixcbiAgICogICAgICAgdGVtcGxhdGVVcmw6IFwibXNnSGVhZGVyLmh0bWxcIlxuICAgKiAgICAgfSwgJ2JvZHknOiB7XG4gICAqICAgICAgIGNvbnRyb2xsZXI6IFwibWVzc2FnZXNDdHJsXCIsXG4gICAqICAgICAgIHRlbXBsYXRlVXJsOiBcIm1lc3NhZ2VzLmh0bWxcIlxuICAgKiAgICAgfVxuICAgKiAgIH08L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gW3N0YXRlQ29uZmlnLmFic3RyYWN0PWZhbHNlXVxuICAgKiA8YSBpZD0nYWJzdHJhY3QnPjwvYT5cbiAgICogQW4gYWJzdHJhY3Qgc3RhdGUgd2lsbCBuZXZlciBiZSBkaXJlY3RseSBhY3RpdmF0ZWQsXG4gICAqICAgYnV0IGNhbiBwcm92aWRlIGluaGVyaXRlZCBwcm9wZXJ0aWVzIHRvIGl0cyBjb21tb24gY2hpbGRyZW4gc3RhdGVzLlxuICAgKiA8cHJlPmFic3RyYWN0OiB0cnVlPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBzdGF0ZUNvbmZpZy5vbkVudGVyXG4gICAqIDxhIGlkPSdvbkVudGVyJz48L2E+XG4gICAqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIGEgc3RhdGUgaXMgZW50ZXJlZC4gR29vZCB3YXlcbiAgICogICB0byB0cmlnZ2VyIGFuIGFjdGlvbiBvciBkaXNwYXRjaCBhbiBldmVudCwgc3VjaCBhcyBvcGVuaW5nIGEgZGlhbG9nLlxuICAgKiBJZiBtaW5pZnlpbmcgeW91ciBzY3JpcHRzLCBtYWtlIHN1cmUgdG8gZXhwbGljaXRseSBhbm5vdGF0ZSB0aGlzIGZ1bmN0aW9uLFxuICAgKiBiZWNhdXNlIGl0IHdvbid0IGJlIGF1dG9tYXRpY2FsbHkgYW5ub3RhdGVkIGJ5IHlvdXIgYnVpbGQgdG9vbHMuXG4gICAqXG4gICAqIDxwcmU+b25FbnRlcjogZnVuY3Rpb24oTXlTZXJ2aWNlLCAkc3RhdGVQYXJhbXMpIHtcbiAgICogICAgIE15U2VydmljZS5mb28oJHN0YXRlUGFyYW1zLm15UGFyYW0pO1xuICAgKiB9PC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBzdGF0ZUNvbmZpZy5vbkV4aXRcbiAgICogPGEgaWQ9J29uRXhpdCc+PC9hPlxuICAgKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igd2hlbiBhIHN0YXRlIGlzIGV4aXRlZC4gR29vZCB3YXkgdG9cbiAgICogICB0cmlnZ2VyIGFuIGFjdGlvbiBvciBkaXNwYXRjaCBhbiBldmVudCwgc3VjaCBhcyBvcGVuaW5nIGEgZGlhbG9nLlxuICAgKiBJZiBtaW5pZnlpbmcgeW91ciBzY3JpcHRzLCBtYWtlIHN1cmUgdG8gZXhwbGljaXRseSBhbm5vdGF0ZSB0aGlzIGZ1bmN0aW9uLFxuICAgKiBiZWNhdXNlIGl0IHdvbid0IGJlIGF1dG9tYXRpY2FsbHkgYW5ub3RhdGVkIGJ5IHlvdXIgYnVpbGQgdG9vbHMuXG4gICAqXG4gICAqIDxwcmU+b25FeGl0OiBmdW5jdGlvbihNeVNlcnZpY2UsICRzdGF0ZVBhcmFtcykge1xuICAgKiAgICAgTXlTZXJ2aWNlLmNsZWFudXAoJHN0YXRlUGFyYW1zLm15UGFyYW0pO1xuICAgKiB9PC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtzdGF0ZUNvbmZpZy5yZWxvYWRPblNlYXJjaD10cnVlXVxuICAgKiA8YSBpZD0ncmVsb2FkT25TZWFyY2gnPjwvYT5cbiAgICpcbiAgICogSWYgYGZhbHNlYCwgd2lsbCBub3QgcmV0cmlnZ2VyIHRoZSBzYW1lIHN0YXRlXG4gICAqICAganVzdCBiZWNhdXNlIGEgc2VhcmNoL3F1ZXJ5IHBhcmFtZXRlciBoYXMgY2hhbmdlZCAodmlhICRsb2NhdGlvbi5zZWFyY2goKSBvciAkbG9jYXRpb24uaGFzaCgpKS4gXG4gICAqICAgVXNlZnVsIGZvciB3aGVuIHlvdSdkIGxpa2UgdG8gbW9kaWZ5ICRsb2NhdGlvbi5zZWFyY2goKSB3aXRob3V0IHRyaWdnZXJpbmcgYSByZWxvYWQuXG4gICAqIDxwcmU+cmVsb2FkT25TZWFyY2g6IGZhbHNlPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gc3RhdGVDb25maWcuZGF0YVxuICAgKiA8YSBpZD0nZGF0YSc+PC9hPlxuICAgKlxuICAgKiBBcmJpdHJhcnkgZGF0YSBvYmplY3QsIHVzZWZ1bCBmb3IgY3VzdG9tIGNvbmZpZ3VyYXRpb24uICBUaGUgcGFyZW50IHN0YXRlJ3MgYGRhdGFgIGlzXG4gICAqICAgcHJvdG90eXBhbGx5IGluaGVyaXRlZC4gIEluIG90aGVyIHdvcmRzLCBhZGRpbmcgYSBkYXRhIHByb3BlcnR5IHRvIGEgc3RhdGUgYWRkcyBpdCB0b1xuICAgKiAgIHRoZSBlbnRpcmUgc3VidHJlZSB2aWEgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cbiAgICpcbiAgICogPHByZT5kYXRhOiB7XG4gICAqICAgICByZXF1aXJlZFJvbGU6ICdmb28nXG4gICAqIH0gPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gc3RhdGVDb25maWcucGFyYW1zXG4gICAqIDxhIGlkPSdwYXJhbXMnPjwvYT5cbiAgICpcbiAgICogQSBtYXAgd2hpY2ggb3B0aW9uYWxseSBjb25maWd1cmVzIHBhcmFtZXRlcnMgZGVjbGFyZWQgaW4gdGhlIGB1cmxgLCBvclxuICAgKiAgIGRlZmluZXMgYWRkaXRpb25hbCBub24tdXJsIHBhcmFtZXRlcnMuICBGb3IgZWFjaCBwYXJhbWV0ZXIgYmVpbmdcbiAgICogICBjb25maWd1cmVkLCBhZGQgYSBjb25maWd1cmF0aW9uIG9iamVjdCBrZXllZCB0byB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiAgIEVhY2ggcGFyYW1ldGVyIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG1heSBjb250YWluIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtICoqIHZhbHVlICoqIC0ge29iamVjdHxmdW5jdGlvbj19OiBzcGVjaWZpZXMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXNcbiAgICogICAgIHBhcmFtZXRlci4gIFRoaXMgaW1wbGljaXRseSBzZXRzIHRoaXMgcGFyYW1ldGVyIGFzIG9wdGlvbmFsLlxuICAgKlxuICAgKiAgICAgV2hlbiBVSS1Sb3V0ZXIgcm91dGVzIHRvIGEgc3RhdGUgYW5kIG5vIHZhbHVlIGlzXG4gICAqICAgICBzcGVjaWZpZWQgZm9yIHRoaXMgcGFyYW1ldGVyIGluIHRoZSBVUkwgb3IgdHJhbnNpdGlvbiwgdGhlXG4gICAqICAgICBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiAgSWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLFxuICAgKiAgICAgaXQgd2lsbCBiZSBpbmplY3RlZCBhbmQgaW52b2tlZCwgYW5kIHRoZSByZXR1cm4gdmFsdWUgdXNlZC5cbiAgICpcbiAgICogICAgICpOb3RlKjogYHVuZGVmaW5lZGAgaXMgdHJlYXRlZCBhcyBcIm5vIGRlZmF1bHQgdmFsdWVcIiB3aGlsZSBgbnVsbGBcbiAgICogICAgIGlzIHRyZWF0ZWQgYXMgXCJ0aGUgZGVmYXVsdCB2YWx1ZSBpcyBgbnVsbGBcIi5cbiAgICpcbiAgICogICAgICpTaG9ydGhhbmQqOiBJZiB5b3Ugb25seSBuZWVkIHRvIGNvbmZpZ3VyZSB0aGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGVcbiAgICogICAgIHBhcmFtZXRlciwgeW91IG1heSB1c2UgYSBzaG9ydGhhbmQgc3ludGF4LiAgIEluIHRoZSAqKmBwYXJhbXNgKipcbiAgICogICAgIG1hcCwgaW5zdGVhZCBtYXBwaW5nIHRoZSBwYXJhbSBuYW1lIHRvIGEgZnVsbCBwYXJhbWV0ZXIgY29uZmlndXJhdGlvblxuICAgKiAgICAgb2JqZWN0LCBzaW1wbHkgc2V0IG1hcCBpdCB0byB0aGUgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUsIGUuZy46XG4gICAqXG4gICAqIDxwcmU+Ly8gZGVmaW5lIGEgcGFyYW1ldGVyJ3MgZGVmYXVsdCB2YWx1ZVxuICAgKiBwYXJhbXM6IHtcbiAgICogICAgIHBhcmFtMTogeyB2YWx1ZTogXCJkZWZhdWx0VmFsdWVcIiB9XG4gICAqIH1cbiAgICogLy8gc2hvcnRoYW5kIGRlZmF1bHQgdmFsdWVzXG4gICAqIHBhcmFtczoge1xuICAgKiAgICAgcGFyYW0xOiBcImRlZmF1bHRWYWx1ZVwiLFxuICAgKiAgICAgcGFyYW0yOiBcInBhcmFtMkRlZmF1bHRcIlxuICAgKiB9PC9wcmU+XG4gICAqXG4gICAqICAgLSAqKiBhcnJheSAqKiAtIHtib29sZWFuPX06ICooZGVmYXVsdDogZmFsc2UpKiBJZiB0cnVlLCB0aGUgcGFyYW0gdmFsdWUgd2lsbCBiZVxuICAgKiAgICAgdHJlYXRlZCBhcyBhbiBhcnJheSBvZiB2YWx1ZXMuICBJZiB5b3Ugc3BlY2lmaWVkIGEgVHlwZSwgdGhlIHZhbHVlIHdpbGwgYmVcbiAgICogICAgIHRyZWF0ZWQgYXMgYW4gYXJyYXkgb2YgdGhlIHNwZWNpZmllZCBUeXBlLiAgTm90ZTogcXVlcnkgcGFyYW1ldGVyIHZhbHVlc1xuICAgKiAgICAgZGVmYXVsdCB0byBhIHNwZWNpYWwgYFwiYXV0b1wiYCBtb2RlLlxuICAgKlxuICAgKiAgICAgRm9yIHF1ZXJ5IHBhcmFtZXRlcnMgaW4gYFwiYXV0b1wiYCBtb2RlLCBpZiBtdWx0aXBsZSAgdmFsdWVzIGZvciBhIHNpbmdsZSBwYXJhbWV0ZXJcbiAgICogICAgIGFyZSBwcmVzZW50IGluIHRoZSBVUkwgKGUuZy46IGAvZm9vP2Jhcj0xJmJhcj0yJmJhcj0zYCkgdGhlbiB0aGUgdmFsdWVzXG4gICAqICAgICBhcmUgbWFwcGVkIHRvIGFuIGFycmF5IChlLmcuOiBgeyBmb286IFsgJzEnLCAnMicsICczJyBdIH1gKS4gIEhvd2V2ZXIsIGlmXG4gICAqICAgICBvbmx5IG9uZSB2YWx1ZSBpcyBwcmVzZW50IChlLmcuOiBgL2Zvbz9iYXI9MWApIHRoZW4gdGhlIHZhbHVlIGlzIHRyZWF0ZWQgYXMgc2luZ2xlXG4gICAqICAgICB2YWx1ZSAoZS5nLjogYHsgZm9vOiAnMScgfWApLlxuICAgKlxuICAgKiA8cHJlPnBhcmFtczoge1xuICAgKiAgICAgcGFyYW0xOiB7IGFycmF5OiB0cnVlIH1cbiAgICogfTwvcHJlPlxuICAgKlxuICAgKiAgIC0gKiogc3F1YXNoICoqIC0ge2Jvb2x8c3RyaW5nPX06IGBzcXVhc2hgIGNvbmZpZ3VyZXMgaG93IGEgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIFVSTCB3aGVuXG4gICAqICAgICB0aGUgY3VycmVudCBwYXJhbWV0ZXIgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIGRlZmF1bHQgdmFsdWUuIElmIGBzcXVhc2hgIGlzIG5vdCBzZXQsIGl0IHVzZXMgdGhlXG4gICAqICAgICBjb25maWd1cmVkIGRlZmF1bHQgc3F1YXNoIHBvbGljeS5cbiAgICogICAgIChTZWUge0BsaW5rIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeSNtZXRob2RzX2RlZmF1bHRTcXVhc2hQb2xpY3kgYGRlZmF1bHRTcXVhc2hQb2xpY3koKWB9KVxuICAgKlxuICAgKiAgIFRoZXJlIGFyZSB0aHJlZSBzcXVhc2ggc2V0dGluZ3M6XG4gICAqXG4gICAqICAgICAtIGZhbHNlOiBUaGUgcGFyYW1ldGVyJ3MgZGVmYXVsdCB2YWx1ZSBpcyBub3Qgc3F1YXNoZWQuICBJdCBpcyBlbmNvZGVkIGFuZCBpbmNsdWRlZCBpbiB0aGUgVVJMXG4gICAqICAgICAtIHRydWU6IFRoZSBwYXJhbWV0ZXIncyBkZWZhdWx0IHZhbHVlIGlzIG9taXR0ZWQgZnJvbSB0aGUgVVJMLiAgSWYgdGhlIHBhcmFtZXRlciBpcyBwcmVjZWVkZWQgYW5kIGZvbGxvd2VkXG4gICAqICAgICAgIGJ5IHNsYXNoZXMgaW4gdGhlIHN0YXRlJ3MgYHVybGAgZGVjbGFyYXRpb24sIHRoZW4gb25lIG9mIHRob3NlIHNsYXNoZXMgYXJlIG9taXR0ZWQuXG4gICAqICAgICAgIFRoaXMgY2FuIGFsbG93IGZvciBjbGVhbmVyIGxvb2tpbmcgVVJMcy5cbiAgICogICAgIC0gYFwiPGFyYml0cmFyeSBzdHJpbmc+XCJgOiBUaGUgcGFyYW1ldGVyJ3MgZGVmYXVsdCB2YWx1ZSBpcyByZXBsYWNlZCB3aXRoIGFuIGFyYml0cmFyeSBwbGFjZWhvbGRlciBvZiAgeW91ciBjaG9pY2UuXG4gICAqXG4gICAqIDxwcmU+cGFyYW1zOiB7XG4gICAqICAgICBwYXJhbTE6IHtcbiAgICogICAgICAgdmFsdWU6IFwiZGVmYXVsdElkXCIsXG4gICAqICAgICAgIHNxdWFzaDogdHJ1ZVxuICAgKiB9IH1cbiAgICogLy8gc3F1YXNoIFwiZGVmYXVsdFZhbHVlXCIgdG8gXCJ+XCJcbiAgICogcGFyYW1zOiB7XG4gICAqICAgICBwYXJhbTE6IHtcbiAgICogICAgICAgdmFsdWU6IFwiZGVmYXVsdFZhbHVlXCIsXG4gICAqICAgICAgIHNxdWFzaDogXCJ+XCJcbiAgICogfSB9XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8cHJlPlxuICAgKiAvLyBTb21lIHN0YXRlIG5hbWUgZXhhbXBsZXNcbiAgICpcbiAgICogLy8gc3RhdGVOYW1lIGNhbiBiZSBhIHNpbmdsZSB0b3AtbGV2ZWwgbmFtZSAobXVzdCBiZSB1bmlxdWUpLlxuICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge30pO1xuICAgKlxuICAgKiAvLyBPciBpdCBjYW4gYmUgYSBuZXN0ZWQgc3RhdGUgbmFtZS4gVGhpcyBzdGF0ZSBpcyBhIGNoaWxkIG9mIHRoZVxuICAgKiAvLyBhYm92ZSBcImhvbWVcIiBzdGF0ZS5cbiAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lLm5ld2VzdFwiLCB7fSk7XG4gICAqXG4gICAqIC8vIE5lc3Qgc3RhdGVzIGFzIGRlZXBseSBhcyBuZWVkZWQuXG4gICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZS5uZXdlc3QuYWJjLnh5ei5pbmNlcHRpb25cIiwge30pO1xuICAgKlxuICAgKiAvLyBzdGF0ZSgpIHJldHVybnMgJHN0YXRlUHJvdmlkZXIsIHNvIHlvdSBjYW4gY2hhaW4gc3RhdGUgZGVjbGFyYXRpb25zLlxuICAgKiAkc3RhdGVQcm92aWRlclxuICAgKiAgIC5zdGF0ZShcImhvbWVcIiwge30pXG4gICAqICAgLnN0YXRlKFwiYWJvdXRcIiwge30pXG4gICAqICAgLnN0YXRlKFwiY29udGFjdHNcIiwge30pO1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICovXG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgZnVuY3Rpb24gc3RhdGUobmFtZSwgZGVmaW5pdGlvbikge1xuICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgIGlmIChpc09iamVjdChuYW1lKSkgZGVmaW5pdGlvbiA9IG5hbWU7XG4gICAgZWxzZSBkZWZpbml0aW9uLm5hbWUgPSBuYW1lO1xuICAgIHJlZ2lzdGVyU3RhdGUoZGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG5nZG9jIG9iamVjdFxuICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gICAqXG4gICAqIEByZXF1aXJlcyAkcm9vdFNjb3BlXG4gICAqIEByZXF1aXJlcyAkcVxuICAgKiBAcmVxdWlyZXMgdWkucm91dGVyLnN0YXRlLiR2aWV3XG4gICAqIEByZXF1aXJlcyAkaW5qZWN0b3JcbiAgICogQHJlcXVpcmVzIHVpLnJvdXRlci51dGlsLiRyZXNvbHZlXG4gICAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUGFyYW1zXG4gICAqIEByZXF1aXJlcyB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJcbiAgICpcbiAgICogQHByb3BlcnR5IHtvYmplY3R9IHBhcmFtcyBBIHBhcmFtIG9iamVjdCwgZS5nLiB7c2VjdGlvbklkOiBzZWN0aW9uLmlkKX0sIHRoYXQgXG4gICAqIHlvdSdkIGxpa2UgdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cbiAgICogQHByb3BlcnR5IHtvYmplY3R9IGN1cnJlbnQgQSByZWZlcmVuY2UgdG8gdGhlIHN0YXRlJ3MgY29uZmlnIG9iamVjdC4gSG93ZXZlciBcbiAgICogeW91IHBhc3NlZCBpdCBpbi4gVXNlZnVsIGZvciBhY2Nlc3NpbmcgY3VzdG9tIGRhdGEuXG4gICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0cmFuc2l0aW9uIEN1cnJlbnRseSBwZW5kaW5nIHRyYW5zaXRpb24uIEEgcHJvbWlzZSB0aGF0J2xsIFxuICAgKiByZXNvbHZlIG9yIHJlamVjdC5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIGAkc3RhdGVgIHNlcnZpY2UgaXMgcmVzcG9uc2libGUgZm9yIHJlcHJlc2VudGluZyBzdGF0ZXMgYXMgd2VsbCBhcyB0cmFuc2l0aW9uaW5nXG4gICAqIGJldHdlZW4gdGhlbS4gSXQgYWxzbyBwcm92aWRlcyBpbnRlcmZhY2VzIHRvIGFzayBmb3IgY3VycmVudCBzdGF0ZSBvciBldmVuIHN0YXRlc1xuICAgKiB5b3UncmUgY29taW5nIGZyb20uXG4gICAqL1xuICB0aGlzLiRnZXQgPSAkZ2V0O1xuICAkZ2V0LiRpbmplY3QgPSBbJyRyb290U2NvcGUnLCAnJHEnLCAnJHZpZXcnLCAnJGluamVjdG9yJywgJyRyZXNvbHZlJywgJyRzdGF0ZVBhcmFtcycsICckdXJsUm91dGVyJywgJyRsb2NhdGlvbicsICckdXJsTWF0Y2hlckZhY3RvcnknXTtcbiAgZnVuY3Rpb24gJGdldCggICAkcm9vdFNjb3BlLCAgICRxLCAgICR2aWV3LCAgICRpbmplY3RvciwgICAkcmVzb2x2ZSwgICAkc3RhdGVQYXJhbXMsICAgJHVybFJvdXRlciwgICAkbG9jYXRpb24sICAgJHVybE1hdGNoZXJGYWN0b3J5KSB7XG5cbiAgICB2YXIgVHJhbnNpdGlvblN1cGVyc2VkZWRFcnJvciA9IG5ldyBFcnJvcigndHJhbnNpdGlvbiBzdXBlcnNlZGVkJyk7XG5cbiAgICB2YXIgVHJhbnNpdGlvblN1cGVyc2VkZWQgPSBzaWxlbmNlVW5jYXVnaHRJblByb21pc2UoJHEucmVqZWN0KFRyYW5zaXRpb25TdXBlcnNlZGVkRXJyb3IpKTtcbiAgICB2YXIgVHJhbnNpdGlvblByZXZlbnRlZCA9IHNpbGVuY2VVbmNhdWdodEluUHJvbWlzZSgkcS5yZWplY3QobmV3IEVycm9yKCd0cmFuc2l0aW9uIHByZXZlbnRlZCcpKSk7XG4gICAgdmFyIFRyYW5zaXRpb25BYm9ydGVkID0gc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlKCRxLnJlamVjdChuZXcgRXJyb3IoJ3RyYW5zaXRpb24gYWJvcnRlZCcpKSk7XG4gICAgdmFyIFRyYW5zaXRpb25GYWlsZWQgPSBzaWxlbmNlVW5jYXVnaHRJblByb21pc2UoJHEucmVqZWN0KG5ldyBFcnJvcigndHJhbnNpdGlvbiBmYWlsZWQnKSkpO1xuXG4gICAgLy8gSGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBhIHN0YXRlIHdoaWNoIGlzIHRoZSB0YXJnZXQgb2YgYSB0cmFuc2l0aW9uIGlzIG5vdCBmb3VuZCwgYW5kIHRoZSB1c2VyXG4gICAgLy8gY2FuIG9wdGlvbmFsbHkgcmV0cnkgb3IgZGVmZXIgdGhlIHRyYW5zaXRpb25cbiAgICBmdW5jdGlvbiBoYW5kbGVSZWRpcmVjdChyZWRpcmVjdCwgc3RhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZXZlbnRcbiAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjJHN0YXRlTm90Rm91bmRcbiAgICAgICAqIEBldmVudE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcbiAgICAgICAqIEBldmVudFR5cGUgYnJvYWRjYXN0IG9uIHJvb3Qgc2NvcGVcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogRmlyZWQgd2hlbiBhIHJlcXVlc3RlZCBzdGF0ZSAqKmNhbm5vdCBiZSBmb3VuZCoqIHVzaW5nIHRoZSBwcm92aWRlZCBzdGF0ZSBuYW1lIGR1cmluZyB0cmFuc2l0aW9uLlxuICAgICAgICogVGhlIGV2ZW50IGlzIGJyb2FkY2FzdCBhbGxvd2luZyBhbnkgaGFuZGxlcnMgYSBzaW5nbGUgY2hhbmNlIHRvIGRlYWwgd2l0aCB0aGUgZXJyb3IgKHVzdWFsbHkgYnlcbiAgICAgICAqIGxhenktbG9hZGluZyB0aGUgdW5mb3VuZCBzdGF0ZSkuIEEgc3BlY2lhbCBgdW5mb3VuZFN0YXRlYCBvYmplY3QgaXMgcGFzc2VkIHRvIHRoZSBsaXN0ZW5lciBoYW5kbGVyLFxuICAgICAgICogeW91IGNhbiBzZWUgaXRzIHRocmVlIHByb3BlcnRpZXMgaW4gdGhlIGV4YW1wbGUuIFlvdSBjYW4gdXNlIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYCB0byBhYm9ydCB0aGVcbiAgICAgICAqIHRyYW5zaXRpb24gYW5kIHRoZSBwcm9taXNlIHJldHVybmVkIGZyb20gYGdvYCB3aWxsIGJlIHJlamVjdGVkIHdpdGggYSBgJ3RyYW5zaXRpb24gYWJvcnRlZCdgIHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5mb3VuZFN0YXRlIFVuZm91bmQgU3RhdGUgaW5mb3JtYXRpb24uIENvbnRhaW5zOiBgdG8sIHRvUGFyYW1zLCBvcHRpb25zYCBwcm9wZXJ0aWVzLlxuICAgICAgICogQHBhcmFtIHtTdGF0ZX0gZnJvbVN0YXRlIEN1cnJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZyb21QYXJhbXMgQ3VycmVudCBzdGF0ZSBwYXJhbXMuXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqXG4gICAgICAgKiA8cHJlPlxuICAgICAgICogLy8gc29tZXdoZXJlLCBhc3N1bWUgbGF6eS5zdGF0ZSBoYXMgbm90IGJlZW4gZGVmaW5lZFxuICAgICAgICogJHN0YXRlLmdvKFwibGF6eS5zdGF0ZVwiLCB7YToxLCBiOjJ9LCB7aW5oZXJpdDpmYWxzZX0pO1xuICAgICAgICpcbiAgICAgICAqIC8vIHNvbWV3aGVyZSBlbHNlXG4gICAgICAgKiAkc2NvcGUuJG9uKCckc3RhdGVOb3RGb3VuZCcsXG4gICAgICAgKiBmdW5jdGlvbihldmVudCwgdW5mb3VuZFN0YXRlLCBmcm9tU3RhdGUsIGZyb21QYXJhbXMpe1xuICAgICAgICogICAgIGNvbnNvbGUubG9nKHVuZm91bmRTdGF0ZS50byk7IC8vIFwibGF6eS5zdGF0ZVwiXG4gICAgICAgKiAgICAgY29uc29sZS5sb2codW5mb3VuZFN0YXRlLnRvUGFyYW1zKTsgLy8ge2E6MSwgYjoyfVxuICAgICAgICogICAgIGNvbnNvbGUubG9nKHVuZm91bmRTdGF0ZS5vcHRpb25zKTsgLy8ge2luaGVyaXQ6ZmFsc2V9ICsgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgKiB9KVxuICAgICAgICogPC9wcmU+XG4gICAgICAgKi9cbiAgICAgIHZhciBldnQgPSAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRzdGF0ZU5vdEZvdW5kJywgcmVkaXJlY3QsIHN0YXRlLCBwYXJhbXMpO1xuXG4gICAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgJHVybFJvdXRlci51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zaXRpb25BYm9ydGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWV2dC5yZXRyeSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgdGhlIGhhbmRsZXIgdG8gcmV0dXJuIGEgcHJvbWlzZSB0byBkZWZlciBzdGF0ZSBsb29rdXAgcmV0cnlcbiAgICAgIGlmIChvcHRpb25zLiRyZXRyeSkge1xuICAgICAgICAkdXJsUm91dGVyLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gVHJhbnNpdGlvbkZhaWxlZDtcbiAgICAgIH1cbiAgICAgIHZhciByZXRyeVRyYW5zaXRpb24gPSAkc3RhdGUudHJhbnNpdGlvbiA9ICRxLndoZW4oZXZ0LnJldHJ5KTtcblxuICAgICAgcmV0cnlUcmFuc2l0aW9uLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXRyeVRyYW5zaXRpb24gIT09ICRzdGF0ZS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckc3RhdGVDaGFuZ2VDYW5jZWwnLCByZWRpcmVjdC50bywgcmVkaXJlY3QudG9QYXJhbXMsIHN0YXRlLCBwYXJhbXMpO1xuICAgICAgICAgIHJldHVybiBUcmFuc2l0aW9uU3VwZXJzZWRlZDtcbiAgICAgICAgfVxuICAgICAgICByZWRpcmVjdC5vcHRpb25zLiRyZXRyeSA9IHRydWU7XG4gICAgICAgIHJldHVybiAkc3RhdGUudHJhbnNpdGlvblRvKHJlZGlyZWN0LnRvLCByZWRpcmVjdC50b1BhcmFtcywgcmVkaXJlY3Qub3B0aW9ucyk7XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zaXRpb25BYm9ydGVkO1xuICAgICAgfSk7XG4gICAgICAkdXJsUm91dGVyLnVwZGF0ZSgpO1xuXG4gICAgICByZXR1cm4gcmV0cnlUcmFuc2l0aW9uO1xuICAgIH1cblxuICAgIHJvb3QubG9jYWxzID0geyByZXNvbHZlOiBudWxsLCBnbG9iYWxzOiB7ICRzdGF0ZVBhcmFtczoge30gfSB9O1xuXG4gICAgJHN0YXRlID0ge1xuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGN1cnJlbnQ6IHJvb3Quc2VsZixcbiAgICAgICRjdXJyZW50OiByb290LFxuICAgICAgdHJhbnNpdGlvbjogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI3JlbG9hZFxuICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBBIG1ldGhvZCB0aGF0IGZvcmNlIHJlbG9hZHMgdGhlIGN1cnJlbnQgc3RhdGUuIEFsbCByZXNvbHZlcyBhcmUgcmUtcmVzb2x2ZWQsXG4gICAgICogY29udHJvbGxlcnMgcmVpbnN0YW50aWF0ZWQsIGFuZCBldmVudHMgcmUtZmlyZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIDxwcmU+XG4gICAgICogdmFyIGFwcCBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgICAqICAgJHNjb3BlLnJlbG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICogICAgICRzdGF0ZS5yZWxvYWQoKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIGByZWxvYWQoKWAgaXMganVzdCBhbiBhbGlhcyBmb3I6XG4gICAgICogPHByZT5cbiAgICAgKiAkc3RhdGUudHJhbnNpdGlvblRvKCRzdGF0ZS5jdXJyZW50LCAkc3RhdGVQYXJhbXMsIHsgXG4gICAgICogICByZWxvYWQ6IHRydWUsIGluaGVyaXQ6IGZhbHNlLCBub3RpZnk6IHRydWVcbiAgICAgKiB9KTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPXxvYmplY3Q9fSBzdGF0ZSAtIEEgc3RhdGUgbmFtZSBvciBhIHN0YXRlIG9iamVjdCwgd2hpY2ggaXMgdGhlIHJvb3Qgb2YgdGhlIHJlc29sdmVzIHRvIGJlIHJlLXJlc29sdmVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogPHByZT5cbiAgICAgKiAvL2Fzc3VtaW5nIGFwcCBhcHBsaWNhdGlvbiBjb25zaXN0cyBvZiAzIHN0YXRlczogJ2NvbnRhY3RzJywgJ2NvbnRhY3RzLmRldGFpbCcsICdjb250YWN0cy5kZXRhaWwuaXRlbScgXG4gICAgICogLy9hbmQgY3VycmVudCBzdGF0ZSBpcyAnY29udGFjdHMuZGV0YWlsLml0ZW0nXG4gICAgICogdmFyIGFwcCBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgICAqICAgJHNjb3BlLnJlbG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICogICAgIC8vd2lsbCByZWxvYWQgJ2NvbnRhY3QuZGV0YWlsJyBhbmQgJ2NvbnRhY3QuZGV0YWlsLml0ZW0nIHN0YXRlc1xuICAgICAqICAgICAkc3RhdGUucmVsb2FkKCdjb250YWN0LmRldGFpbCcpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIDwvcHJlPlxuICAgICAqXG4gICAgICogYHJlbG9hZCgpYCBpcyBqdXN0IGFuIGFsaWFzIGZvcjpcbiAgICAgKiA8cHJlPlxuICAgICAqICRzdGF0ZS50cmFuc2l0aW9uVG8oJHN0YXRlLmN1cnJlbnQsICRzdGF0ZVBhcmFtcywgeyBcbiAgICAgKiAgIHJlbG9hZDogdHJ1ZSwgaW5oZXJpdDogZmFsc2UsIG5vdGlmeTogdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqIDwvcHJlPlxuXG4gICAgICogQHJldHVybnMge3Byb21pc2V9IEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi4gU2VlXG4gICAgICoge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjbWV0aG9kc19nbyAkc3RhdGUuZ299LlxuICAgICAqL1xuICAgICRzdGF0ZS5yZWxvYWQgPSBmdW5jdGlvbiByZWxvYWQoc3RhdGUpIHtcbiAgICAgIHJldHVybiAkc3RhdGUudHJhbnNpdGlvblRvKCRzdGF0ZS5jdXJyZW50LCAkc3RhdGVQYXJhbXMsIHsgcmVsb2FkOiBzdGF0ZSB8fCB0cnVlLCBpbmhlcml0OiBmYWxzZSwgbm90aWZ5OiB0cnVlfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjZ29cbiAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IHN0YXRlLiBgJHN0YXRlLmdvYCBjYWxscyBcbiAgICAgKiBgJHN0YXRlLnRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSBidXQgYXV0b21hdGljYWxseSBzZXRzIG9wdGlvbnMgdG8gXG4gICAgICogYHsgbG9jYXRpb246IHRydWUsIGluaGVyaXQ6IHRydWUsIHJlbGF0aXZlOiAkc3RhdGUuJGN1cnJlbnQsIG5vdGlmeTogdHJ1ZSB9YC4gXG4gICAgICogVGhpcyBhbGxvd3MgeW91IHRvIGVhc2lseSB1c2UgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8gcGF0aCBhbmQgc3BlY2lmeSBcbiAgICAgKiBvbmx5IHRoZSBwYXJhbWV0ZXJzIHlvdSdkIGxpa2UgdG8gdXBkYXRlICh3aGlsZSBsZXR0aW5nIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnMgXG4gICAgICogaW5oZXJpdCBmcm9tIHRoZSBjdXJyZW50bHkgYWN0aXZlIGFuY2VzdG9yIHN0YXRlcykuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIDxwcmU+XG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICRzdGF0ZS5nbygnY29udGFjdC5kZXRhaWwnKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICogPC9wcmU+XG4gICAgICogPGltZyBzcmM9Jy4uL25nZG9jX2Fzc2V0cy9TdGF0ZUdvRXhhbXBsZXMucG5nJy8+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG8gQWJzb2x1dGUgc3RhdGUgbmFtZSBvciByZWxhdGl2ZSBzdGF0ZSBwYXRoLiBTb21lIGV4YW1wbGVzOlxuICAgICAqXG4gICAgICogLSBgJHN0YXRlLmdvKCdjb250YWN0LmRldGFpbCcpYCAtIHdpbGwgZ28gdG8gdGhlIGBjb250YWN0LmRldGFpbGAgc3RhdGVcbiAgICAgKiAtIGAkc3RhdGUuZ28oJ14nKWAgLSB3aWxsIGdvIHRvIGEgcGFyZW50IHN0YXRlXG4gICAgICogLSBgJHN0YXRlLmdvKCdeLnNpYmxpbmcnKWAgLSB3aWxsIGdvIHRvIGEgc2libGluZyBzdGF0ZVxuICAgICAqIC0gYCRzdGF0ZS5nbygnLmNoaWxkLmdyYW5kY2hpbGQnKWAgLSB3aWxsIGdvIHRvIGdyYW5kY2hpbGQgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gcGFyYW1zIEEgbWFwIG9mIHRoZSBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSBzdGF0ZSwgXG4gICAgICogd2lsbCBwb3B1bGF0ZSAkc3RhdGVQYXJhbXMuIEFueSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBzcGVjaWZpZWQgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSBjdXJyZW50bHkgXG4gICAgICogZGVmaW5lZCBwYXJhbWV0ZXJzLiBPbmx5IHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZSBzdGF0ZSBkZWZpbml0aW9uIGNhbiBiZSBvdmVycmlkZGVuLCBuZXcgXG4gICAgICogcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuIFRoaXMgYWxsb3dzLCBmb3IgZXhhbXBsZSwgZ29pbmcgdG8gYSBzaWJsaW5nIHN0YXRlIHRoYXQgc2hhcmVzIHBhcmFtZXRlcnNcbiAgICAgKiBzcGVjaWZpZWQgaW4gYSBwYXJlbnQgc3RhdGUuIFBhcmFtZXRlciBpbmhlcml0YW5jZSBvbmx5IHdvcmtzIGJldHdlZW4gY29tbW9uIGFuY2VzdG9yIHN0YXRlcywgSS5lLlxuICAgICAqIHRyYW5zaXRpb25pbmcgdG8gYSBzaWJsaW5nIHdpbGwgZ2V0IHlvdSB0aGUgcGFyYW1ldGVycyBmb3IgYWxsIHBhcmVudHMsIHRyYW5zaXRpb25pbmcgdG8gYSBjaGlsZFxuICAgICAqIHdpbGwgZ2V0IHlvdSBhbGwgY3VycmVudCBwYXJhbWV0ZXJzLCBldGMuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtICoqYGxvY2F0aW9uYCoqIC0ge2Jvb2xlYW49dHJ1ZXxzdHJpbmc9fSAtIElmIGB0cnVlYCB3aWxsIHVwZGF0ZSB0aGUgdXJsIGluIHRoZSBsb2NhdGlvbiBiYXIsIGlmIGBmYWxzZWBcbiAgICAgKiAgICB3aWxsIG5vdC4gSWYgc3RyaW5nLCBtdXN0IGJlIGBcInJlcGxhY2VcImAsIHdoaWNoIHdpbGwgdXBkYXRlIHVybCBhbmQgYWxzbyByZXBsYWNlIGxhc3QgaGlzdG9yeSByZWNvcmQuXG4gICAgICogLSAqKmBpbmhlcml0YCoqIC0ge2Jvb2xlYW49dHJ1ZX0sIElmIGB0cnVlYCB3aWxsIGluaGVyaXQgdXJsIHBhcmFtZXRlcnMgZnJvbSBjdXJyZW50IHVybC5cbiAgICAgKiAtICoqYHJlbGF0aXZlYCoqIC0ge29iamVjdD0kc3RhdGUuJGN1cnJlbnR9LCBXaGVuIHRyYW5zaXRpb25pbmcgd2l0aCByZWxhdGl2ZSBwYXRoIChlLmcgJ14nKSwgXG4gICAgICogICAgZGVmaW5lcyB3aGljaCBzdGF0ZSB0byBiZSByZWxhdGl2ZSBmcm9tLlxuICAgICAqIC0gKipgbm90aWZ5YCoqIC0ge2Jvb2xlYW49dHJ1ZX0sIElmIGB0cnVlYCB3aWxsIGJyb2FkY2FzdCAkc3RhdGVDaGFuZ2VTdGFydCBhbmQgJHN0YXRlQ2hhbmdlU3VjY2VzcyBldmVudHMuXG4gICAgICogLSAqKmByZWxvYWRgKiogKHYwLjIuNSkgLSB7Ym9vbGVhbj1mYWxzZXxzdHJpbmd8b2JqZWN0fSwgSWYgYHRydWVgIHdpbGwgZm9yY2UgdHJhbnNpdGlvbiBldmVuIGlmIG5vIHN0YXRlIG9yIHBhcmFtc1xuICAgICAqICAgIGhhdmUgY2hhbmdlZC4gIEl0IHdpbGwgcmVsb2FkIHRoZSByZXNvbHZlcyBhbmQgdmlld3Mgb2YgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHBhcmVudCBzdGF0ZXMuXG4gICAgICogICAgSWYgYHJlbG9hZGAgaXMgYSBzdHJpbmcgKG9yIHN0YXRlIG9iamVjdCksIHRoZSBzdGF0ZSBvYmplY3QgaXMgZmV0Y2hlZCAoYnkgbmFtZSwgb3Igb2JqZWN0IHJlZmVyZW5jZSk7IGFuZCBcXFxuICAgICAqICAgIHRoZSB0cmFuc2l0aW9uIHJlbG9hZHMgdGhlIHJlc29sdmVzIGFuZCB2aWV3cyBmb3IgdGhhdCBtYXRjaGVkIHN0YXRlLCBhbmQgYWxsIGl0cyBjaGlsZHJlbiBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7cHJvbWlzZX0gQSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIG5ldyB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogUG9zc2libGUgc3VjY2VzcyB2YWx1ZXM6XG4gICAgICpcbiAgICAgKiAtICRzdGF0ZS5jdXJyZW50XG4gICAgICpcbiAgICAgKiA8YnIvPlBvc3NpYmxlIHJlamVjdGlvbiB2YWx1ZXM6XG4gICAgICpcbiAgICAgKiAtICd0cmFuc2l0aW9uIHN1cGVyc2VkZWQnIC0gd2hlbiBhIG5ld2VyIHRyYW5zaXRpb24gaGFzIGJlZW4gc3RhcnRlZCBhZnRlciB0aGlzIG9uZVxuICAgICAqIC0gJ3RyYW5zaXRpb24gcHJldmVudGVkJyAtIHdoZW4gYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIGhhcyBiZWVuIGNhbGxlZCBpbiBhIGAkc3RhdGVDaGFuZ2VTdGFydGAgbGlzdGVuZXJcbiAgICAgKiAtICd0cmFuc2l0aW9uIGFib3J0ZWQnIC0gd2hlbiBgZXZlbnQucHJldmVudERlZmF1bHQoKWAgaGFzIGJlZW4gY2FsbGVkIGluIGEgYCRzdGF0ZU5vdEZvdW5kYCBsaXN0ZW5lciBvclxuICAgICAqICAgd2hlbiBhIGAkc3RhdGVOb3RGb3VuZGAgYGV2ZW50LnJldHJ5YCBwcm9taXNlIGVycm9ycy5cbiAgICAgKiAtICd0cmFuc2l0aW9uIGZhaWxlZCcgLSB3aGVuIGEgc3RhdGUgaGFzIGJlZW4gdW5zdWNjZXNzZnVsbHkgZm91bmQgYWZ0ZXIgMiB0cmllcy5cbiAgICAgKiAtICpyZXNvbHZlIGVycm9yKiAtIHdoZW4gYW4gZXJyb3IgaGFzIG9jY3VycmVkIHdpdGggYSBgcmVzb2x2ZWBcbiAgICAgKlxuICAgICAqL1xuICAgICRzdGF0ZS5nbyA9IGZ1bmN0aW9uIGdvKHRvLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAkc3RhdGUudHJhbnNpdGlvblRvKHRvLCBwYXJhbXMsIGV4dGVuZCh7IGluaGVyaXQ6IHRydWUsIHJlbGF0aXZlOiAkc3RhdGUuJGN1cnJlbnQgfSwgb3B0aW9ucykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI3RyYW5zaXRpb25Ub1xuICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBMb3ctbGV2ZWwgbWV0aG9kIGZvciB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IHN0YXRlLiB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNtZXRob2RzX2dvICRzdGF0ZS5nb31cbiAgICAgKiB1c2VzIGB0cmFuc2l0aW9uVG9gIGludGVybmFsbHkuIGAkc3RhdGUuZ29gIGlzIHJlY29tbWVuZGVkIGluIG1vc3Qgc2l0dWF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogPHByZT5cbiAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgKiAgICRzY29wZS5jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgICAgJHN0YXRlLnRyYW5zaXRpb25UbygnY29udGFjdC5kZXRhaWwnKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG8gU3RhdGUgbmFtZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdD19IHRvUGFyYW1zIEEgbWFwIG9mIHRoZSBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSBzdGF0ZSxcbiAgICAgKiB3aWxsIHBvcHVsYXRlICRzdGF0ZVBhcmFtcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gKipgbG9jYXRpb25gKiogLSB7Ym9vbGVhbj10cnVlfHN0cmluZz19IC0gSWYgYHRydWVgIHdpbGwgdXBkYXRlIHRoZSB1cmwgaW4gdGhlIGxvY2F0aW9uIGJhciwgaWYgYGZhbHNlYFxuICAgICAqICAgIHdpbGwgbm90LiBJZiBzdHJpbmcsIG11c3QgYmUgYFwicmVwbGFjZVwiYCwgd2hpY2ggd2lsbCB1cGRhdGUgdXJsIGFuZCBhbHNvIHJlcGxhY2UgbGFzdCBoaXN0b3J5IHJlY29yZC5cbiAgICAgKiAtICoqYGluaGVyaXRgKiogLSB7Ym9vbGVhbj1mYWxzZX0sIElmIGB0cnVlYCB3aWxsIGluaGVyaXQgdXJsIHBhcmFtZXRlcnMgZnJvbSBjdXJyZW50IHVybC5cbiAgICAgKiAtICoqYHJlbGF0aXZlYCoqIC0ge29iamVjdD19LCBXaGVuIHRyYW5zaXRpb25pbmcgd2l0aCByZWxhdGl2ZSBwYXRoIChlLmcgJ14nKSwgXG4gICAgICogICAgZGVmaW5lcyB3aGljaCBzdGF0ZSB0byBiZSByZWxhdGl2ZSBmcm9tLlxuICAgICAqIC0gKipgbm90aWZ5YCoqIC0ge2Jvb2xlYW49dHJ1ZX0sIElmIGB0cnVlYCB3aWxsIGJyb2FkY2FzdCAkc3RhdGVDaGFuZ2VTdGFydCBhbmQgJHN0YXRlQ2hhbmdlU3VjY2VzcyBldmVudHMuXG4gICAgICogLSAqKmByZWxvYWRgKiogKHYwLjIuNSkgLSB7Ym9vbGVhbj1mYWxzZXxzdHJpbmc9fG9iamVjdD19LCBJZiBgdHJ1ZWAgd2lsbCBmb3JjZSB0cmFuc2l0aW9uIGV2ZW4gaWYgdGhlIHN0YXRlIG9yIHBhcmFtcyBcbiAgICAgKiAgICBoYXZlIG5vdCBjaGFuZ2VkLCBha2EgYSByZWxvYWQgb2YgdGhlIHNhbWUgc3RhdGUuIEl0IGRpZmZlcnMgZnJvbSByZWxvYWRPblNlYXJjaCBiZWNhdXNlIHlvdSdkXG4gICAgICogICAgdXNlIHRoaXMgd2hlbiB5b3Ugd2FudCB0byBmb3JjZSBhIHJlbG9hZCB3aGVuICpldmVyeXRoaW5nKiBpcyB0aGUgc2FtZSwgaW5jbHVkaW5nIHNlYXJjaCBwYXJhbXMuXG4gICAgICogICAgaWYgU3RyaW5nLCB0aGVuIHdpbGwgcmVsb2FkIHRoZSBzdGF0ZSB3aXRoIHRoZSBuYW1lIGdpdmVuIGluIHJlbG9hZCwgYW5kIGFueSBjaGlsZHJlbi5cbiAgICAgKiAgICBpZiBPYmplY3QsIHRoZW4gYSBzdGF0ZU9iaiBpcyBleHBlY3RlZCwgd2lsbCByZWxvYWQgdGhlIHN0YXRlIGZvdW5kIGluIHN0YXRlT2JqLCBhbmQgYW55IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3Byb21pc2V9IEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi4gU2VlXG4gICAgICoge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjbWV0aG9kc19nbyAkc3RhdGUuZ299LlxuICAgICAqL1xuICAgICRzdGF0ZS50cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8odG8sIHRvUGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICB0b1BhcmFtcyA9IHRvUGFyYW1zIHx8IHt9O1xuICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7XG4gICAgICAgIGxvY2F0aW9uOiB0cnVlLCBpbmhlcml0OiBmYWxzZSwgcmVsYXRpdmU6IG51bGwsIG5vdGlmeTogdHJ1ZSwgcmVsb2FkOiBmYWxzZSwgJHJldHJ5OiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICAgIHZhciBmcm9tID0gJHN0YXRlLiRjdXJyZW50LCBmcm9tUGFyYW1zID0gJHN0YXRlLnBhcmFtcywgZnJvbVBhdGggPSBmcm9tLnBhdGg7XG4gICAgICB2YXIgZXZ0LCB0b1N0YXRlID0gZmluZFN0YXRlKHRvLCBvcHRpb25zLnJlbGF0aXZlKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIGhhc2ggcGFyYW0gZm9yIGxhdGVyIChzaW5jZSBpdCB3aWxsIGJlIHN0cmlwcGVkIG91dCBieSB2YXJpb3VzIG1ldGhvZHMpXG4gICAgICB2YXIgaGFzaCA9IHRvUGFyYW1zWycjJ107XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHRvU3RhdGUpKSB7XG4gICAgICAgIHZhciByZWRpcmVjdCA9IHsgdG86IHRvLCB0b1BhcmFtczogdG9QYXJhbXMsIG9wdGlvbnM6IG9wdGlvbnMgfTtcbiAgICAgICAgdmFyIHJlZGlyZWN0UmVzdWx0ID0gaGFuZGxlUmVkaXJlY3QocmVkaXJlY3QsIGZyb20uc2VsZiwgZnJvbVBhcmFtcywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHJlZGlyZWN0UmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlZGlyZWN0UmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWx3YXlzIHJldHJ5IG9uY2UgaWYgdGhlICRzdGF0ZU5vdEZvdW5kIHdhcyBub3QgcHJldmVudGVkXG4gICAgICAgIC8vIChoYW5kbGVzIGVpdGhlciByZWRpcmVjdCBjaGFuZ2VkIG9yIHN0YXRlIGxhenktZGVmaW5pdGlvbilcbiAgICAgICAgdG8gPSByZWRpcmVjdC50bztcbiAgICAgICAgdG9QYXJhbXMgPSByZWRpcmVjdC50b1BhcmFtcztcbiAgICAgICAgb3B0aW9ucyA9IHJlZGlyZWN0Lm9wdGlvbnM7XG4gICAgICAgIHRvU3RhdGUgPSBmaW5kU3RhdGUodG8sIG9wdGlvbnMucmVsYXRpdmUpO1xuXG4gICAgICAgIGlmICghaXNEZWZpbmVkKHRvU3RhdGUpKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLnJlbGF0aXZlKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIHN0YXRlICdcIiArIHRvICsgXCInXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlICdcIiArIHRvICsgXCInIGZyb20gc3RhdGUgJ1wiICsgb3B0aW9ucy5yZWxhdGl2ZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRvU3RhdGVbYWJzdHJhY3RLZXldKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJhbnNpdGlvbiB0byBhYnN0cmFjdCBzdGF0ZSAnXCIgKyB0byArIFwiJ1wiKTtcbiAgICAgIGlmIChvcHRpb25zLmluaGVyaXQpIHRvUGFyYW1zID0gaW5oZXJpdFBhcmFtcygkc3RhdGVQYXJhbXMsIHRvUGFyYW1zIHx8IHt9LCAkc3RhdGUuJGN1cnJlbnQsIHRvU3RhdGUpO1xuICAgICAgaWYgKCF0b1N0YXRlLnBhcmFtcy4kJHZhbGlkYXRlcyh0b1BhcmFtcykpIHJldHVybiBUcmFuc2l0aW9uRmFpbGVkO1xuXG4gICAgICB0b1BhcmFtcyA9IHRvU3RhdGUucGFyYW1zLiQkdmFsdWVzKHRvUGFyYW1zKTtcbiAgICAgIHRvID0gdG9TdGF0ZTtcblxuICAgICAgdmFyIHRvUGF0aCA9IHRvLnBhdGg7XG5cbiAgICAgIC8vIFN0YXJ0aW5nIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHBhdGgsIGtlZXAgYWxsIGxldmVscyB0aGF0IGhhdmVuJ3QgY2hhbmdlZFxuICAgICAgdmFyIGtlZXAgPSAwLCBzdGF0ZSA9IHRvUGF0aFtrZWVwXSwgbG9jYWxzID0gcm9vdC5sb2NhbHMsIHRvTG9jYWxzID0gW107XG5cbiAgICAgIGlmICghb3B0aW9ucy5yZWxvYWQpIHtcbiAgICAgICAgd2hpbGUgKHN0YXRlICYmIHN0YXRlID09PSBmcm9tUGF0aFtrZWVwXSAmJiBzdGF0ZS5vd25QYXJhbXMuJCRlcXVhbHModG9QYXJhbXMsIGZyb21QYXJhbXMpKSB7XG4gICAgICAgICAgbG9jYWxzID0gdG9Mb2NhbHNba2VlcF0gPSBzdGF0ZS5sb2NhbHM7XG4gICAgICAgICAga2VlcCsrO1xuICAgICAgICAgIHN0YXRlID0gdG9QYXRoW2tlZXBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKG9wdGlvbnMucmVsb2FkKSB8fCBpc09iamVjdChvcHRpb25zLnJlbG9hZCkpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMucmVsb2FkKSAmJiAhb3B0aW9ucy5yZWxvYWQubmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWxvYWQgc3RhdGUgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciByZWxvYWRTdGF0ZSA9IG9wdGlvbnMucmVsb2FkID09PSB0cnVlID8gZnJvbVBhdGhbMF0gOiBmaW5kU3RhdGUob3B0aW9ucy5yZWxvYWQpO1xuICAgICAgICBpZiAob3B0aW9ucy5yZWxvYWQgJiYgIXJlbG9hZFN0YXRlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCByZWxvYWQgc3RhdGUgJ1wiICsgKGlzU3RyaW5nKG9wdGlvbnMucmVsb2FkKSA/IG9wdGlvbnMucmVsb2FkIDogb3B0aW9ucy5yZWxvYWQubmFtZSkgKyBcIidcIik7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoc3RhdGUgJiYgc3RhdGUgPT09IGZyb21QYXRoW2tlZXBdICYmIHN0YXRlICE9PSByZWxvYWRTdGF0ZSkge1xuICAgICAgICAgIGxvY2FscyA9IHRvTG9jYWxzW2tlZXBdID0gc3RhdGUubG9jYWxzO1xuICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICBzdGF0ZSA9IHRvUGF0aFtrZWVwXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBnb2luZyB0byB0aGUgc2FtZSBzdGF0ZSBhbmQgYWxsIGxvY2FscyBhcmUga2VwdCwgd2UndmUgZ290IG5vdGhpbmcgdG8gZG8uXG4gICAgICAvLyBCdXQgY2xlYXIgJ3RyYW5zaXRpb24nLCBhcyB3ZSBzdGlsbCB3YW50IHRvIGNhbmNlbCBhbnkgb3RoZXIgcGVuZGluZyB0cmFuc2l0aW9ucy5cbiAgICAgIC8vIFRPRE86IFdlIG1heSBub3Qgd2FudCB0byBidW1wICd0cmFuc2l0aW9uJyBpZiB3ZSdyZSBjYWxsZWQgZnJvbSBhIGxvY2F0aW9uIGNoYW5nZVxuICAgICAgLy8gdGhhdCB3ZSd2ZSBpbml0aWF0ZWQgb3Vyc2VsdmVzLCBiZWNhdXNlIHdlIG1pZ2h0IGFjY2lkZW50YWxseSBhYm9ydCBhIGxlZ2l0aW1hdGVcbiAgICAgIC8vIHRyYW5zaXRpb24gaW5pdGlhdGVkIGZyb20gY29kZT9cbiAgICAgIGlmIChzaG91bGRTa2lwUmVsb2FkKHRvLCB0b1BhcmFtcywgZnJvbSwgZnJvbVBhcmFtcywgbG9jYWxzLCBvcHRpb25zKSkge1xuICAgICAgICBpZiAoaGFzaCkgdG9QYXJhbXNbJyMnXSA9IGhhc2g7XG4gICAgICAgICRzdGF0ZS5wYXJhbXMgPSB0b1BhcmFtcztcbiAgICAgICAgY29weSgkc3RhdGUucGFyYW1zLCAkc3RhdGVQYXJhbXMpO1xuICAgICAgICBjb3B5KGZpbHRlckJ5S2V5cyh0by5wYXJhbXMuJCRrZXlzKCksICRzdGF0ZVBhcmFtcyksIHRvLmxvY2Fscy5nbG9iYWxzLiRzdGF0ZVBhcmFtcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9uICYmIHRvLm5hdmlnYWJsZSAmJiB0by5uYXZpZ2FibGUudXJsKSB7XG4gICAgICAgICAgJHVybFJvdXRlci5wdXNoKHRvLm5hdmlnYWJsZS51cmwsIHRvUGFyYW1zLCB7XG4gICAgICAgICAgICAkJGF2b2lkUmVzeW5jOiB0cnVlLCByZXBsYWNlOiBvcHRpb25zLmxvY2F0aW9uID09PSAncmVwbGFjZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAkc3RhdGUudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiAkcS53aGVuKCRzdGF0ZS5jdXJyZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIHBhcmFtZXRlcnMgYmVmb3JlIHdlIHBhc3MgdGhlbSB0byBldmVudCBoYW5kbGVycyBldGMuXG4gICAgICB0b1BhcmFtcyA9IGZpbHRlckJ5S2V5cyh0by5wYXJhbXMuJCRrZXlzKCksIHRvUGFyYW1zIHx8IHt9KTtcbiAgICAgIFxuICAgICAgLy8gUmUtYWRkIHRoZSBzYXZlZCBoYXNoIGJlZm9yZSB3ZSBzdGFydCByZXR1cm5pbmcgdGhpbmdzIG9yIGJyb2FkY2FzdGluZyAkc3RhdGVDaGFuZ2VTdGFydFxuICAgICAgaWYgKGhhc2gpIHRvUGFyYW1zWycjJ10gPSBoYXNoO1xuICAgICAgXG4gICAgICAvLyBCcm9hZGNhc3Qgc3RhcnQgZXZlbnQgYW5kIGNhbmNlbCB0aGUgdHJhbnNpdGlvbiBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmIChvcHRpb25zLm5vdGlmeSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5nZG9jIGV2ZW50XG4gICAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjJHN0YXRlQ2hhbmdlU3RhcnRcbiAgICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAgICAgKiBAZXZlbnRUeXBlIGJyb2FkY2FzdCBvbiByb290IHNjb3BlXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBGaXJlZCB3aGVuIHRoZSBzdGF0ZSB0cmFuc2l0aW9uICoqYmVnaW5zKiouIFlvdSBjYW4gdXNlIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYFxuICAgICAgICAgKiB0byBwcmV2ZW50IHRoZSB0cmFuc2l0aW9uIGZyb20gaGFwcGVuaW5nIGFuZCB0aGVuIHRoZSB0cmFuc2l0aW9uIHByb21pc2Ugd2lsbCBiZVxuICAgICAgICAgKiByZWplY3RlZCB3aXRoIGEgYCd0cmFuc2l0aW9uIHByZXZlbnRlZCdgIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0YXRlfSB0b1N0YXRlIFRoZSBzdGF0ZSBiZWluZyB0cmFuc2l0aW9uZWQgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b1BhcmFtcyBUaGUgcGFyYW1zIHN1cHBsaWVkIHRvIHRoZSBgdG9TdGF0ZWAuXG4gICAgICAgICAqIEBwYXJhbSB7U3RhdGV9IGZyb21TdGF0ZSBUaGUgY3VycmVudCBzdGF0ZSwgcHJlLXRyYW5zaXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tUGFyYW1zIFRoZSBwYXJhbXMgc3VwcGxpZWQgdG8gdGhlIGBmcm9tU3RhdGVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiA8cHJlPlxuICAgICAgICAgKiAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLFxuICAgICAgICAgKiBmdW5jdGlvbihldmVudCwgdG9TdGF0ZSwgdG9QYXJhbXMsIGZyb21TdGF0ZSwgZnJvbVBhcmFtcyl7XG4gICAgICAgICAqICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgKiAgICAgLy8gdHJhbnNpdGlvblRvKCkgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGhcbiAgICAgICAgICogICAgIC8vIGEgJ3RyYW5zaXRpb24gcHJldmVudGVkJyBlcnJvclxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiA8L3ByZT5cbiAgICAgICAgICovXG4gICAgICAgIGlmICgkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRzdGF0ZUNoYW5nZVN0YXJ0JywgdG8uc2VsZiwgdG9QYXJhbXMsIGZyb20uc2VsZiwgZnJvbVBhcmFtcywgb3B0aW9ucykuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJHN0YXRlQ2hhbmdlQ2FuY2VsJywgdG8uc2VsZiwgdG9QYXJhbXMsIGZyb20uc2VsZiwgZnJvbVBhcmFtcyk7XG4gICAgICAgICAgLy9Eb24ndCB1cGRhdGUgYW5kIHJlc3luYyB1cmwgaWYgdGhlcmUncyBiZWVuIGEgbmV3IHRyYW5zaXRpb24gc3RhcnRlZC4gc2VlIGlzc3VlICMyMjM4LCAjNjAwXG4gICAgICAgICAgaWYgKCRzdGF0ZS50cmFuc2l0aW9uID09IG51bGwpICR1cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgICAgcmV0dXJuIFRyYW5zaXRpb25QcmV2ZW50ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVzb2x2ZSBsb2NhbHMgZm9yIHRoZSByZW1haW5pbmcgc3RhdGVzLCBidXQgZG9uJ3QgdXBkYXRlIGFueSBnbG9iYWwgc3RhdGUganVzdFxuICAgICAgLy8geWV0IC0tIGlmIGFueXRoaW5nIGZhaWxzIHRvIHJlc29sdmUgdGhlIGN1cnJlbnQgc3RhdGUgbmVlZHMgdG8gcmVtYWluIHVudG91Y2hlZC5cbiAgICAgIC8vIFdlIGFsc28gc2V0IHVwIGFuIGluaGVyaXRhbmNlIGNoYWluIGZvciB0aGUgbG9jYWxzIGhlcmUuIFRoaXMgYWxsb3dzIHRoZSB2aWV3IGRpcmVjdGl2ZVxuICAgICAgLy8gdG8gcXVpY2tseSBsb29rIHVwIHRoZSBjb3JyZWN0IGRlZmluaXRpb24gZm9yIGVhY2ggdmlldyBpbiB0aGUgY3VycmVudCBzdGF0ZS4gRXZlblxuICAgICAgLy8gdGhvdWdoIHdlIGNyZWF0ZSB0aGUgbG9jYWxzIG9iamVjdCBpdHNlbGYgb3V0c2lkZSByZXNvbHZlU3RhdGUoKSwgaXQgaXMgaW5pdGlhbGx5XG4gICAgICAvLyBlbXB0eSBhbmQgZ2V0cyBmaWxsZWQgYXN5bmNocm9ub3VzbHkuIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcHJvbWlzZSBmb3IgdGhlXG4gICAgICAvLyAoZnVsbHkgcmVzb2x2ZWQpIGN1cnJlbnQgbG9jYWxzLCBhbmQgcGFzcyB0aGlzIGRvd24gdGhlIGNoYWluLlxuICAgICAgdmFyIHJlc29sdmVkID0gJHEud2hlbihsb2NhbHMpO1xuXG4gICAgICBmb3IgKHZhciBsID0ga2VlcDsgbCA8IHRvUGF0aC5sZW5ndGg7IGwrKywgc3RhdGUgPSB0b1BhdGhbbF0pIHtcbiAgICAgICAgbG9jYWxzID0gdG9Mb2NhbHNbbF0gPSBpbmhlcml0KGxvY2Fscyk7XG4gICAgICAgIHJlc29sdmVkID0gcmVzb2x2ZVN0YXRlKHN0YXRlLCB0b1BhcmFtcywgc3RhdGUgPT09IHRvLCByZXNvbHZlZCwgbG9jYWxzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gT25jZSBldmVyeXRoaW5nIGlzIHJlc29sdmVkLCB3ZSBhcmUgcmVhZHkgdG8gcGVyZm9ybSB0aGUgYWN0dWFsIHRyYW5zaXRpb25cbiAgICAgIC8vIGFuZCByZXR1cm4gYSBwcm9taXNlIGZvciB0aGUgbmV3IHN0YXRlLiBXZSBhbHNvIGtlZXAgdHJhY2sgb2Ygd2hhdCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgcHJvbWlzZSBpcywgc28gdGhhdCB3ZSBjYW4gZGV0ZWN0IG92ZXJsYXBwaW5nIHRyYW5zaXRpb25zIGFuZFxuICAgICAgLy8ga2VlcCBvbmx5IHRoZSBvdXRjb21lIG9mIHRoZSBsYXN0IHRyYW5zaXRpb24uXG4gICAgICB2YXIgdHJhbnNpdGlvbiA9ICRzdGF0ZS50cmFuc2l0aW9uID0gcmVzb2x2ZWQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsLCBlbnRlcmluZywgZXhpdGluZztcblxuICAgICAgICBpZiAoJHN0YXRlLnRyYW5zaXRpb24gIT09IHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRzdGF0ZUNoYW5nZUNhbmNlbCcsIHRvLnNlbGYsIHRvUGFyYW1zLCBmcm9tLnNlbGYsIGZyb21QYXJhbXMpO1xuICAgICAgICAgIHJldHVybiBUcmFuc2l0aW9uU3VwZXJzZWRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4aXQgJ2Zyb20nIHN0YXRlcyBub3Qga2VwdFxuICAgICAgICBmb3IgKGwgPSBmcm9tUGF0aC5sZW5ndGggLSAxOyBsID49IGtlZXA7IGwtLSkge1xuICAgICAgICAgIGV4aXRpbmcgPSBmcm9tUGF0aFtsXTtcbiAgICAgICAgICBpZiAoZXhpdGluZy5zZWxmLm9uRXhpdCkge1xuICAgICAgICAgICAgJGluamVjdG9yLmludm9rZShleGl0aW5nLnNlbGYub25FeGl0LCBleGl0aW5nLnNlbGYsIGV4aXRpbmcubG9jYWxzLmdsb2JhbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleGl0aW5nLmxvY2FscyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnRlciAndG8nIHN0YXRlcyBub3Qga2VwdFxuICAgICAgICBmb3IgKGwgPSBrZWVwOyBsIDwgdG9QYXRoLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgZW50ZXJpbmcgPSB0b1BhdGhbbF07XG4gICAgICAgICAgZW50ZXJpbmcubG9jYWxzID0gdG9Mb2NhbHNbbF07XG4gICAgICAgICAgaWYgKGVudGVyaW5nLnNlbGYub25FbnRlcikge1xuICAgICAgICAgICAgJGluamVjdG9yLmludm9rZShlbnRlcmluZy5zZWxmLm9uRW50ZXIsIGVudGVyaW5nLnNlbGYsIGVudGVyaW5nLmxvY2Fscy5nbG9iYWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdW4gaXQgYWdhaW4sIHRvIGNhdGNoIGFueSB0cmFuc2l0aW9ucyBpbiBjYWxsYmFja3NcbiAgICAgICAgaWYgKCRzdGF0ZS50cmFuc2l0aW9uICE9PSB0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckc3RhdGVDaGFuZ2VDYW5jZWwnLCB0by5zZWxmLCB0b1BhcmFtcywgZnJvbS5zZWxmLCBmcm9tUGFyYW1zKTtcbiAgICAgICAgICByZXR1cm4gVHJhbnNpdGlvblN1cGVyc2VkZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgZ2xvYmFscyBpbiAkc3RhdGVcbiAgICAgICAgJHN0YXRlLiRjdXJyZW50ID0gdG87XG4gICAgICAgICRzdGF0ZS5jdXJyZW50ID0gdG8uc2VsZjtcbiAgICAgICAgJHN0YXRlLnBhcmFtcyA9IHRvUGFyYW1zO1xuICAgICAgICBjb3B5KCRzdGF0ZS5wYXJhbXMsICRzdGF0ZVBhcmFtcyk7XG4gICAgICAgICRzdGF0ZS50cmFuc2l0aW9uID0gbnVsbDtcblxuICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbiAmJiB0by5uYXZpZ2FibGUpIHtcbiAgICAgICAgICAkdXJsUm91dGVyLnB1c2godG8ubmF2aWdhYmxlLnVybCwgdG8ubmF2aWdhYmxlLmxvY2Fscy5nbG9iYWxzLiRzdGF0ZVBhcmFtcywge1xuICAgICAgICAgICAgJCRhdm9pZFJlc3luYzogdHJ1ZSwgcmVwbGFjZTogb3B0aW9ucy5sb2NhdGlvbiA9PT0gJ3JlcGxhY2UnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5ub3RpZnkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlIyRzdGF0ZUNoYW5nZVN1Y2Nlc3NcbiAgICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAgICAgKiBAZXZlbnRUeXBlIGJyb2FkY2FzdCBvbiByb290IHNjb3BlXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBGaXJlZCBvbmNlIHRoZSBzdGF0ZSB0cmFuc2l0aW9uIGlzICoqY29tcGxldGUqKi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtTdGF0ZX0gdG9TdGF0ZSBUaGUgc3RhdGUgYmVpbmcgdHJhbnNpdGlvbmVkIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9QYXJhbXMgVGhlIHBhcmFtcyBzdXBwbGllZCB0byB0aGUgYHRvU3RhdGVgLlxuICAgICAgICAgKiBAcGFyYW0ge1N0YXRlfSBmcm9tU3RhdGUgVGhlIGN1cnJlbnQgc3RhdGUsIHByZS10cmFuc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZnJvbVBhcmFtcyBUaGUgcGFyYW1zIHN1cHBsaWVkIHRvIHRoZSBgZnJvbVN0YXRlYC5cbiAgICAgICAgICovXG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgdG8uc2VsZiwgdG9QYXJhbXMsIGZyb20uc2VsZiwgZnJvbVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgJHVybFJvdXRlci51cGRhdGUodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuICRzdGF0ZS5jdXJyZW50O1xuICAgICAgfSkudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gcHJvcGFnYXRlIFRyYW5zaXRpb25TdXBlcnNlZGVkIGVycm9yIHdpdGhvdXQgZW1pdHRpbmcgJHN0YXRlQ2hhbmdlQ2FuY2VsXG4gICAgICAgIC8vIGFzIGl0IHdhcyBhbHJlYWR5IGVtaXR0ZWQgaW4gdGhlIHN1Y2Nlc3MgaGFuZGxlciBhYm92ZVxuICAgICAgICBpZiAoZXJyb3IgPT09IFRyYW5zaXRpb25TdXBlcnNlZGVkRXJyb3IpIHJldHVybiBUcmFuc2l0aW9uU3VwZXJzZWRlZDtcblxuICAgICAgICBpZiAoJHN0YXRlLnRyYW5zaXRpb24gIT09IHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRzdGF0ZUNoYW5nZUNhbmNlbCcsIHRvLnNlbGYsIHRvUGFyYW1zLCBmcm9tLnNlbGYsIGZyb21QYXJhbXMpO1xuICAgICAgICAgIHJldHVybiBUcmFuc2l0aW9uU3VwZXJzZWRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgICRzdGF0ZS50cmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlIyRzdGF0ZUNoYW5nZUVycm9yXG4gICAgICAgICAqIEBldmVudE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcbiAgICAgICAgICogQGV2ZW50VHlwZSBicm9hZGNhc3Qgb24gcm9vdCBzY29wZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogRmlyZWQgd2hlbiBhbiAqKmVycm9yIG9jY3VycyoqIGR1cmluZyB0cmFuc2l0aW9uLiBJdCdzIGltcG9ydGFudCB0byBub3RlIHRoYXQgaWYgeW91XG4gICAgICAgICAqIGhhdmUgYW55IGVycm9ycyBpbiB5b3VyIHJlc29sdmUgZnVuY3Rpb25zIChqYXZhc2NyaXB0IGVycm9ycywgbm9uLWV4aXN0ZW50IHNlcnZpY2VzLCBldGMpXG4gICAgICAgICAqIHRoZXkgd2lsbCBub3QgdGhyb3cgdHJhZGl0aW9uYWxseS4gWW91IG11c3QgbGlzdGVuIGZvciB0aGlzICRzdGF0ZUNoYW5nZUVycm9yIGV2ZW50IHRvXG4gICAgICAgICAqIGNhdGNoICoqQUxMKiogZXJyb3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0YXRlfSB0b1N0YXRlIFRoZSBzdGF0ZSBiZWluZyB0cmFuc2l0aW9uZWQgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b1BhcmFtcyBUaGUgcGFyYW1zIHN1cHBsaWVkIHRvIHRoZSBgdG9TdGF0ZWAuXG4gICAgICAgICAqIEBwYXJhbSB7U3RhdGV9IGZyb21TdGF0ZSBUaGUgY3VycmVudCBzdGF0ZSwgcHJlLXRyYW5zaXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tUGFyYW1zIFRoZSBwYXJhbXMgc3VwcGxpZWQgdG8gdGhlIGBmcm9tU3RhdGVgLlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgcmVzb2x2ZSBlcnJvciBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBldnQgPSAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRzdGF0ZUNoYW5nZUVycm9yJywgdG8uc2VsZiwgdG9QYXJhbXMsIGZyb20uc2VsZiwgZnJvbVBhcmFtcywgZXJyb3IpO1xuXG4gICAgICAgIGlmICghZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAkdXJsUm91dGVyLnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRyYW5zaXRpb247XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjaXNcbiAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2ltaWxhciB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNtZXRob2RzX2luY2x1ZGVzICRzdGF0ZS5pbmNsdWRlc30sXG4gICAgICogYnV0IG9ubHkgY2hlY2tzIGZvciB0aGUgZnVsbCBzdGF0ZSBuYW1lLiBJZiBwYXJhbXMgaXMgc3VwcGxpZWQgdGhlbiBpdCB3aWxsIGJlXG4gICAgICogdGVzdGVkIGZvciBzdHJpY3QgZXF1YWxpdHkgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgcGFyYW1zIG9iamVjdCwgc28gYWxsIHBhcmFtc1xuICAgICAqIG11c3QgbWF0Y2ggd2l0aCBub25lIG1pc3NpbmcgYW5kIG5vIGV4dHJhcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogPHByZT5cbiAgICAgKiAkc3RhdGUuJGN1cnJlbnQubmFtZSA9ICdjb250YWN0cy5kZXRhaWxzLml0ZW0nO1xuICAgICAqXG4gICAgICogLy8gYWJzb2x1dGUgbmFtZVxuICAgICAqICRzdGF0ZS5pcygnY29udGFjdC5kZXRhaWxzLml0ZW0nKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmlzKGNvbnRhY3REZXRhaWxJdGVtU3RhdGVPYmplY3QpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKlxuICAgICAqIC8vIHJlbGF0aXZlIG5hbWUgKC4gYW5kIF4pLCB0eXBpY2FsbHkgZnJvbSBhIHRlbXBsYXRlXG4gICAgICogLy8gRS5nLiBmcm9tIHRoZSAnY29udGFjdHMuZGV0YWlscycgdGVtcGxhdGVcbiAgICAgKiA8ZGl2IG5nLWNsYXNzPVwie2hpZ2hsaWdodGVkOiAkc3RhdGUuaXMoJy5pdGVtJyl9XCI+SXRlbTwvZGl2PlxuICAgICAqIDwvcHJlPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzdGF0ZU9yTmFtZSBUaGUgc3RhdGUgbmFtZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUpIG9yIHN0YXRlIG9iamVjdCB5b3UnZCBsaWtlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gcGFyYW1zIEEgcGFyYW0gb2JqZWN0LCBlLmcuIGB7c2VjdGlvbklkOiBzZWN0aW9uLmlkfWAsIHRoYXQgeW91J2QgbGlrZVxuICAgICAqIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogLSAqKmByZWxhdGl2ZWAqKiAtIHtzdHJpbmd8b2JqZWN0fSAtICBJZiBgc3RhdGVPck5hbWVgIGlzIGEgcmVsYXRpdmUgc3RhdGUgbmFtZSBhbmQgYG9wdGlvbnMucmVsYXRpdmVgIGlzIHNldCwgLmlzIHdpbGxcbiAgICAgKiB0ZXN0IHJlbGF0aXZlIHRvIGBvcHRpb25zLnJlbGF0aXZlYCBzdGF0ZSAob3IgbmFtZSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGl0IGlzIHRoZSBzdGF0ZS5cbiAgICAgKi9cbiAgICAkc3RhdGUuaXMgPSBmdW5jdGlvbiBpcyhzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gZXh0ZW5kKHsgcmVsYXRpdmU6ICRzdGF0ZS4kY3VycmVudCB9LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIHZhciBzdGF0ZSA9IGZpbmRTdGF0ZShzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHN0YXRlKSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAoJHN0YXRlLiRjdXJyZW50ICE9PSBzdGF0ZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIHJldHVybiBwYXJhbXMgPyBlcXVhbEZvcktleXMoc3RhdGUucGFyYW1zLiQkdmFsdWVzKHBhcmFtcyksICRzdGF0ZVBhcmFtcykgOiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI2luY2x1ZGVzXG4gICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEEgbWV0aG9kIHRvIGRldGVybWluZSBpZiB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUgaXMgZXF1YWwgdG8gb3IgaXMgdGhlIGNoaWxkIG9mIHRoZVxuICAgICAqIHN0YXRlIHN0YXRlTmFtZS4gSWYgYW55IHBhcmFtcyBhcmUgcGFzc2VkIHRoZW4gdGhleSB3aWxsIGJlIHRlc3RlZCBmb3IgYSBtYXRjaCBhcyB3ZWxsLlxuICAgICAqIE5vdCBhbGwgdGhlIHBhcmFtZXRlcnMgbmVlZCB0byBiZSBwYXNzZWQsIGp1c3QgdGhlIG9uZXMgeW91J2QgbGlrZSB0byB0ZXN0IGZvciBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogUGFydGlhbCBhbmQgcmVsYXRpdmUgbmFtZXNcbiAgICAgKiA8cHJlPlxuICAgICAqICRzdGF0ZS4kY3VycmVudC5uYW1lID0gJ2NvbnRhY3RzLmRldGFpbHMuaXRlbSc7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBwYXJ0aWFsIG5hbWVzXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHNcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmRldGFpbHNcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmRldGFpbHMuaXRlbVwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMubGlzdFwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImFib3V0XCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBVc2luZyByZWxhdGl2ZSBuYW1lcyAoLiBhbmQgXiksIHR5cGljYWxseSBmcm9tIGEgdGVtcGxhdGVcbiAgICAgKiAvLyBFLmcuIGZyb20gdGhlICdjb250YWN0cy5kZXRhaWxzJyB0ZW1wbGF0ZVxuICAgICAqIDxkaXYgbmctY2xhc3M9XCJ7aGlnaGxpZ2h0ZWQ6ICRzdGF0ZS5pbmNsdWRlcygnLml0ZW0nKX1cIj5JdGVtPC9kaXY+XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBCYXNpYyBnbG9iYmluZyBwYXR0ZXJuc1xuICAgICAqIDxwcmU+XG4gICAgICogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPSAnY29udGFjdHMuZGV0YWlscy5pdGVtLnVybCc7XG4gICAgICpcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKi4qXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKipcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIioqLml0ZW0uKipcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy5pdGVtLnVybFwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLioudXJsXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKlwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIml0ZW0uKipcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZU9yTmFtZSBBIHBhcnRpYWwgbmFtZSwgcmVsYXRpdmUgbmFtZSwgb3IgZ2xvYiBwYXR0ZXJuXG4gICAgICogdG8gYmUgc2VhcmNoZWQgZm9yIHdpdGhpbiB0aGUgY3VycmVudCBzdGF0ZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gcGFyYW1zIEEgcGFyYW0gb2JqZWN0LCBlLmcuIGB7c2VjdGlvbklkOiBzZWN0aW9uLmlkfWAsXG4gICAgICogdGhhdCB5b3UnZCBsaWtlIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogLSAqKmByZWxhdGl2ZWAqKiAtIHtzdHJpbmd8b2JqZWN0PX0gLSAgSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIHJlZmVyZW5jZSBhbmQgYG9wdGlvbnMucmVsYXRpdmVgIGlzIHNldCxcbiAgICAgKiAuaW5jbHVkZXMgd2lsbCB0ZXN0IHJlbGF0aXZlIHRvIGBvcHRpb25zLnJlbGF0aXZlYCBzdGF0ZSAob3IgbmFtZSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGl0IGRvZXMgaW5jbHVkZSB0aGUgc3RhdGVcbiAgICAgKi9cbiAgICAkc3RhdGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyhzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gZXh0ZW5kKHsgcmVsYXRpdmU6ICRzdGF0ZS4kY3VycmVudCB9LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIGlmIChpc1N0cmluZyhzdGF0ZU9yTmFtZSkgJiYgaXNHbG9iKHN0YXRlT3JOYW1lKSkge1xuICAgICAgICBpZiAoIWRvZXNTdGF0ZU1hdGNoR2xvYihzdGF0ZU9yTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVPck5hbWUgPSAkc3RhdGUuJGN1cnJlbnQubmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gZmluZFN0YXRlKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKTtcbiAgICAgIGlmICghaXNEZWZpbmVkKHN0YXRlKSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAoIWlzRGVmaW5lZCgkc3RhdGUuJGN1cnJlbnQuaW5jbHVkZXNbc3RhdGUubmFtZV0pKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaWYgKCFwYXJhbXMpIHsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHBhcmFtcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sIHBhcmFtRGVmID0gc3RhdGUucGFyYW1zW2tleV07XG4gICAgICAgIGlmIChwYXJhbURlZiAmJiAhcGFyYW1EZWYudHlwZS5lcXVhbHMoJHN0YXRlUGFyYW1zW2tleV0sIHBhcmFtc1trZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI2hyZWZcbiAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQSB1cmwgZ2VuZXJhdGlvbiBtZXRob2QgdGhhdCByZXR1cm5zIHRoZSBjb21waWxlZCB1cmwgZm9yIHRoZSBnaXZlbiBzdGF0ZSBwb3B1bGF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiA8cHJlPlxuICAgICAqIGV4cGVjdCgkc3RhdGUuaHJlZihcImFib3V0LnBlcnNvblwiLCB7IHBlcnNvbjogXCJib2JcIiB9KSkudG9FcXVhbChcIi9hYm91dC9ib2JcIik7XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHN0YXRlT3JOYW1lIFRoZSBzdGF0ZSBuYW1lIG9yIHN0YXRlIG9iamVjdCB5b3UnZCBsaWtlIHRvIGdlbmVyYXRlIGEgdXJsIGZyb20uXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBwYXJhbXMgQW4gb2JqZWN0IG9mIHBhcmFtZXRlciB2YWx1ZXMgdG8gZmlsbCB0aGUgc3RhdGUncyByZXF1aXJlZCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogLSAqKmBsb3NzeWAqKiAtIHtib29sZWFuPXRydWV9IC0gIElmIHRydWUsIGFuZCBpZiB0aGVyZSBpcyBubyB1cmwgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdGF0ZSBwcm92aWRlZCBpbiB0aGVcbiAgICAgKiAgICBmaXJzdCBwYXJhbWV0ZXIsIHRoZW4gdGhlIGNvbnN0cnVjdGVkIGhyZWYgdXJsIHdpbGwgYmUgYnVpbHQgZnJvbSB0aGUgZmlyc3QgbmF2aWdhYmxlIGFuY2VzdG9yIChha2FcbiAgICAgKiAgICBhbmNlc3RvciB3aXRoIGEgdmFsaWQgdXJsKS5cbiAgICAgKiAtICoqYGluaGVyaXRgKiogLSB7Ym9vbGVhbj10cnVlfSwgSWYgYHRydWVgIHdpbGwgaW5oZXJpdCB1cmwgcGFyYW1ldGVycyBmcm9tIGN1cnJlbnQgdXJsLlxuICAgICAqIC0gKipgcmVsYXRpdmVgKiogLSB7b2JqZWN0PSRzdGF0ZS4kY3VycmVudH0sIFdoZW4gdHJhbnNpdGlvbmluZyB3aXRoIHJlbGF0aXZlIHBhdGggKGUuZyAnXicpLCBcbiAgICAgKiAgICBkZWZpbmVzIHdoaWNoIHN0YXRlIHRvIGJlIHJlbGF0aXZlIGZyb20uXG4gICAgICogLSAqKmBhYnNvbHV0ZWAqKiAtIHtib29sZWFuPWZhbHNlfSwgIElmIHRydWUgd2lsbCBnZW5lcmF0ZSBhbiBhYnNvbHV0ZSB1cmwsIGUuZy4gXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL2Z1bGx1cmxcIi5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjb21waWxlZCBzdGF0ZSB1cmxcbiAgICAgKi9cbiAgICAkc3RhdGUuaHJlZiA9IGZ1bmN0aW9uIGhyZWYoc3RhdGVPck5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7XG4gICAgICAgIGxvc3N5OiAgICB0cnVlLFxuICAgICAgICBpbmhlcml0OiAgdHJ1ZSxcbiAgICAgICAgYWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICByZWxhdGl2ZTogJHN0YXRlLiRjdXJyZW50XG4gICAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgICAgdmFyIHN0YXRlID0gZmluZFN0YXRlKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQoc3RhdGUpKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChvcHRpb25zLmluaGVyaXQpIHBhcmFtcyA9IGluaGVyaXRQYXJhbXMoJHN0YXRlUGFyYW1zLCBwYXJhbXMgfHwge30sICRzdGF0ZS4kY3VycmVudCwgc3RhdGUpO1xuICAgICAgXG4gICAgICB2YXIgbmF2ID0gKHN0YXRlICYmIG9wdGlvbnMubG9zc3kpID8gc3RhdGUubmF2aWdhYmxlIDogc3RhdGU7XG5cbiAgICAgIGlmICghbmF2IHx8IG5hdi51cmwgPT09IHVuZGVmaW5lZCB8fCBuYXYudXJsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuICR1cmxSb3V0ZXIuaHJlZihuYXYudXJsLCBmaWx0ZXJCeUtleXMoc3RhdGUucGFyYW1zLiQka2V5cygpLmNvbmNhdCgnIycpLCBwYXJhbXMgfHwge30pLCB7XG4gICAgICAgIGFic29sdXRlOiBvcHRpb25zLmFic29sdXRlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNnZXRcbiAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGFueSBzcGVjaWZpYyBzdGF0ZSBvciBhbGwgc3RhdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0PX0gc3RhdGVPck5hbWUgKGFic29sdXRlIG9yIHJlbGF0aXZlKSBJZiBwcm92aWRlZCwgd2lsbCBvbmx5IGdldCB0aGUgY29uZmlnIGZvclxuICAgICAqIHRoZSByZXF1ZXN0ZWQgc3RhdGUuIElmIG5vdCBwcm92aWRlZCwgcmV0dXJucyBhbiBhcnJheSBvZiBBTEwgc3RhdGUgY29uZmlncy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3Q9fSBjb250ZXh0IFdoZW4gc3RhdGVPck5hbWUgaXMgYSByZWxhdGl2ZSBzdGF0ZSByZWZlcmVuY2UsIHRoZSBzdGF0ZSB3aWxsIGJlIHJldHJpZXZlZCByZWxhdGl2ZSB0byBjb250ZXh0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8QXJyYXl9IFN0YXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGFycmF5IG9mIGFsbCBvYmplY3RzLlxuICAgICAqL1xuICAgICRzdGF0ZS5nZXQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gbWFwKG9iamVjdEtleXMoc3RhdGVzKSwgZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gc3RhdGVzW25hbWVdLnNlbGY7IH0pO1xuICAgICAgdmFyIHN0YXRlID0gZmluZFN0YXRlKHN0YXRlT3JOYW1lLCBjb250ZXh0IHx8ICRzdGF0ZS4kY3VycmVudCk7XG4gICAgICByZXR1cm4gKHN0YXRlICYmIHN0YXRlLnNlbGYpID8gc3RhdGUuc2VsZiA6IG51bGw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlc29sdmVTdGF0ZShzdGF0ZSwgcGFyYW1zLCBwYXJhbXNBcmVGaWx0ZXJlZCwgaW5oZXJpdGVkLCBkc3QsIG9wdGlvbnMpIHtcbiAgICAgIC8vIE1ha2UgYSByZXN0cmljdGVkICRzdGF0ZVBhcmFtcyB3aXRoIG9ubHkgdGhlIHBhcmFtZXRlcnMgdGhhdCBhcHBseSB0byB0aGlzIHN0YXRlIGlmXG4gICAgICAvLyBuZWNlc3NhcnkuIEluIGFkZGl0aW9uIHRvIGJlaW5nIGF2YWlsYWJsZSB0byB0aGUgY29udHJvbGxlciBhbmQgb25FbnRlci9vbkV4aXQgY2FsbGJhY2tzLFxuICAgICAgLy8gd2UgYWxzbyBuZWVkICRzdGF0ZVBhcmFtcyB0byBiZSBhdmFpbGFibGUgZm9yIGFueSAkaW5qZWN0b3IgY2FsbHMgd2UgbWFrZSBkdXJpbmcgdGhlXG4gICAgICAvLyBkZXBlbmRlbmN5IHJlc29sdXRpb24gcHJvY2Vzcy5cbiAgICAgIHZhciAkc3RhdGVQYXJhbXMgPSAocGFyYW1zQXJlRmlsdGVyZWQpID8gcGFyYW1zIDogZmlsdGVyQnlLZXlzKHN0YXRlLnBhcmFtcy4kJGtleXMoKSwgcGFyYW1zKTtcbiAgICAgIHZhciBsb2NhbHMgPSB7ICRzdGF0ZVBhcmFtczogJHN0YXRlUGFyYW1zIH07XG5cbiAgICAgIC8vIFJlc29sdmUgJ2dsb2JhbCcgZGVwZW5kZW5jaWVzIGZvciB0aGUgc3RhdGUsIGkuZS4gdGhvc2Ugbm90IHNwZWNpZmljIHRvIGEgdmlldy5cbiAgICAgIC8vIFdlJ3JlIGFsc28gaW5jbHVkaW5nICRzdGF0ZVBhcmFtcyBpbiB0aGlzOyB0aGF0IHdheSB0aGUgcGFyYW1ldGVycyBhcmUgcmVzdHJpY3RlZFxuICAgICAgLy8gdG8gdGhlIHNldCB0aGF0IHNob3VsZCBiZSB2aXNpYmxlIHRvIHRoZSBzdGF0ZSwgYW5kIGFyZSBpbmRlcGVuZGVudCBvZiB3aGVuIHdlIHVwZGF0ZVxuICAgICAgLy8gdGhlIGdsb2JhbCAkc3RhdGUgYW5kICRzdGF0ZVBhcmFtcyB2YWx1ZXMuXG4gICAgICBkc3QucmVzb2x2ZSA9ICRyZXNvbHZlLnJlc29sdmUoc3RhdGUucmVzb2x2ZSwgbG9jYWxzLCBkc3QucmVzb2x2ZSwgc3RhdGUpO1xuICAgICAgdmFyIHByb21pc2VzID0gW2RzdC5yZXNvbHZlLnRoZW4oZnVuY3Rpb24gKGdsb2JhbHMpIHtcbiAgICAgICAgZHN0Lmdsb2JhbHMgPSBnbG9iYWxzO1xuICAgICAgfSldO1xuICAgICAgaWYgKGluaGVyaXRlZCkgcHJvbWlzZXMucHVzaChpbmhlcml0ZWQpO1xuXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVmlld3MoKSB7XG4gICAgICAgIHZhciB2aWV3c1Byb21pc2VzID0gW107XG5cbiAgICAgICAgLy8gUmVzb2x2ZSB0ZW1wbGF0ZSBhbmQgZGVwZW5kZW5jaWVzIGZvciBhbGwgdmlld3MuXG4gICAgICAgIGZvckVhY2goc3RhdGUudmlld3MsIGZ1bmN0aW9uICh2aWV3LCBuYW1lKSB7XG4gICAgICAgICAgdmFyIGluamVjdGFibGVzID0gKHZpZXcucmVzb2x2ZSAmJiB2aWV3LnJlc29sdmUgIT09IHN0YXRlLnJlc29sdmUgPyB2aWV3LnJlc29sdmUgOiB7fSk7XG4gICAgICAgICAgaW5qZWN0YWJsZXMuJHRlbXBsYXRlID0gWyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJHZpZXcubG9hZChuYW1lLCB7IHZpZXc6IHZpZXcsIGxvY2FsczogZHN0Lmdsb2JhbHMsIHBhcmFtczogJHN0YXRlUGFyYW1zLCBub3RpZnk6IG9wdGlvbnMubm90aWZ5IH0pIHx8ICcnO1xuICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgdmlld3NQcm9taXNlcy5wdXNoKCRyZXNvbHZlLnJlc29sdmUoaW5qZWN0YWJsZXMsIGRzdC5nbG9iYWxzLCBkc3QucmVzb2x2ZSwgc3RhdGUpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gUmVmZXJlbmNlcyB0byB0aGUgY29udHJvbGxlciAob25seSBpbnN0YW50aWF0ZWQgYXQgbGluayB0aW1lKVxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmlldy5jb250cm9sbGVyUHJvdmlkZXIpIHx8IGlzQXJyYXkodmlldy5jb250cm9sbGVyUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgIHZhciBpbmplY3RMb2NhbHMgPSBhbmd1bGFyLmV4dGVuZCh7fSwgaW5qZWN0YWJsZXMsIGRzdC5nbG9iYWxzKTtcbiAgICAgICAgICAgICAgcmVzdWx0LiQkY29udHJvbGxlciA9ICRpbmplY3Rvci5pbnZva2Uodmlldy5jb250cm9sbGVyUHJvdmlkZXIsIG51bGwsIGluamVjdExvY2Fscyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQuJCRjb250cm9sbGVyID0gdmlldy5jb250cm9sbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvdmlkZSBhY2Nlc3MgdG8gdGhlIHN0YXRlIGl0c2VsZiBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICAgICAgICByZXN1bHQuJCRzdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmVzdWx0LiQkY29udHJvbGxlckFzID0gdmlldy5jb250cm9sbGVyQXM7XG4gICAgICAgICAgICByZXN1bHQuJCRyZXNvbHZlQXMgPSB2aWV3LnJlc29sdmVBcztcbiAgICAgICAgICAgIGRzdFtuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwodmlld3NQcm9taXNlcykudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBkc3QuZ2xvYmFscztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhaXQgZm9yIGFsbCB0aGUgcHJvbWlzZXMgYW5kIHRoZW4gcmV0dXJuIHRoZSBhY3RpdmF0aW9uIG9iamVjdFxuICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihyZXNvbHZlVmlld3MpLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICRzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFNraXBSZWxvYWQodG8sIHRvUGFyYW1zLCBmcm9tLCBmcm9tUGFyYW1zLCBsb2NhbHMsIG9wdGlvbnMpIHtcbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gZGlmZmVyZW5jZXMgaW4gbm9uLXNlYXJjaCAocGF0aC9vYmplY3QpIHBhcmFtcywgZmFsc2UgaWYgdGhlcmUgYXJlIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gbm9uU2VhcmNoUGFyYW1zRXF1YWwoZnJvbUFuZFRvU3RhdGUsIGZyb21QYXJhbXMsIHRvUGFyYW1zKSB7XG4gICAgICAvLyBJZGVudGlmeSB3aGV0aGVyIGFsbCB0aGUgcGFyYW1ldGVycyB0aGF0IGRpZmZlciBiZXR3ZWVuIGBmcm9tUGFyYW1zYCBhbmQgYHRvUGFyYW1zYCB3ZXJlIHNlYXJjaCBwYXJhbXMuXG4gICAgICBmdW5jdGlvbiBub3RTZWFyY2hQYXJhbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BbmRUb1N0YXRlLnBhcmFtc1trZXldLmxvY2F0aW9uICE9IFwic2VhcmNoXCI7XG4gICAgICB9XG4gICAgICB2YXIgbm9uUXVlcnlQYXJhbUtleXMgPSBmcm9tQW5kVG9TdGF0ZS5wYXJhbXMuJCRrZXlzKCkuZmlsdGVyKG5vdFNlYXJjaFBhcmFtKTtcbiAgICAgIHZhciBub25RdWVyeVBhcmFtcyA9IHBpY2suYXBwbHkoe30sIFtmcm9tQW5kVG9TdGF0ZS5wYXJhbXNdLmNvbmNhdChub25RdWVyeVBhcmFtS2V5cykpO1xuICAgICAgdmFyIG5vblF1ZXJ5UGFyYW1TZXQgPSBuZXcgJCRVTUZQLlBhcmFtU2V0KG5vblF1ZXJ5UGFyYW1zKTtcbiAgICAgIHJldHVybiBub25RdWVyeVBhcmFtU2V0LiQkZXF1YWxzKGZyb21QYXJhbXMsIHRvUGFyYW1zKTtcbiAgICB9XG5cbiAgICAvLyBJZiByZWxvYWQgd2FzIG5vdCBleHBsaWNpdGx5IHJlcXVlc3RlZFxuICAgIC8vIGFuZCB3ZSdyZSB0cmFuc2l0aW9uaW5nIHRvIHRoZSBzYW1lIHN0YXRlIHdlJ3JlIGFscmVhZHkgaW5cbiAgICAvLyBhbmQgICAgdGhlIGxvY2FscyBkaWRuJ3QgY2hhbmdlXG4gICAgLy8gICAgIG9yIHRoZXkgY2hhbmdlZCBpbiBhIHdheSB0aGF0IGRvZXNuJ3QgbWVyaXQgcmVsb2FkaW5nXG4gICAgLy8gICAgICAgIChyZWxvYWRPblBhcmFtczpmYWxzZSwgb3IgcmVsb2FkT25TZWFyY2guZmFsc2UgYW5kIG9ubHkgc2VhcmNoIHBhcmFtcyBjaGFuZ2VkKVxuICAgIC8vIFRoZW4gcmV0dXJuIHRydWUuXG4gICAgaWYgKCFvcHRpb25zLnJlbG9hZCAmJiB0byA9PT0gZnJvbSAmJlxuICAgICAgKGxvY2FscyA9PT0gZnJvbS5sb2NhbHMgfHwgKHRvLnNlbGYucmVsb2FkT25TZWFyY2ggPT09IGZhbHNlICYmIG5vblNlYXJjaFBhcmFtc0VxdWFsKGZyb20sIGZyb21QYXJhbXMsIHRvUGFyYW1zKSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gIC5mYWN0b3J5KCckc3RhdGVQYXJhbXMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB7fTsgfSlcbiAgLmNvbnN0YW50KFwiJHN0YXRlLnJ1bnRpbWVcIiwgeyBhdXRvaW5qZWN0OiB0cnVlIH0pXG4gIC5wcm92aWRlcignJHN0YXRlJywgJFN0YXRlUHJvdmlkZXIpXG4gIC8vIEluamVjdCAkc3RhdGUgdG8gaW5pdGlhbGl6ZSB3aGVuIGVudGVyaW5nIHJ1bnRpbWUuICMyNTc0XG4gIC5ydW4oWyckaW5qZWN0b3InLCBmdW5jdGlvbiAoJGluamVjdG9yKSB7XG4gICAgLy8gQWxsb3cgdGVzdHMgKHN0YXRlU3BlYy5qcykgdG8gdHVybiB0aGlzIG9mZiBieSBkZWZpbmluZyB0aGlzIGNvbnN0YW50XG4gICAgaWYgKCRpbmplY3Rvci5nZXQoXCIkc3RhdGUucnVudGltZVwiKS5hdXRvaW5qZWN0KSB7XG4gICAgICAkaW5qZWN0b3IuZ2V0KCckc3RhdGUnKTtcbiAgICB9XG4gIH1dKTtcblxuXG4kVmlld1Byb3ZpZGVyLiRpbmplY3QgPSBbXTtcbmZ1bmN0aW9uICRWaWV3UHJvdmlkZXIoKSB7XG5cbiAgdGhpcy4kZ2V0ID0gJGdldDtcbiAgLyoqXG4gICAqIEBuZ2RvYyBvYmplY3RcbiAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiR2aWV3XG4gICAqXG4gICAqIEByZXF1aXJlcyB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5XG4gICAqIEByZXF1aXJlcyAkcm9vdFNjb3BlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKi9cbiAgJGdldC4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJywgJyR0ZW1wbGF0ZUZhY3RvcnknXTtcbiAgZnVuY3Rpb24gJGdldCggICAkcm9vdFNjb3BlLCAgICR0ZW1wbGF0ZUZhY3RvcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gJHZpZXcubG9hZCgnZnVsbC52aWV3TmFtZScsIHsgdGVtcGxhdGU6IC4uLiwgY29udHJvbGxlcjogLi4uLCByZXNvbHZlOiAuLi4sIGFzeW5jOiBmYWxzZSwgcGFyYW1zOiAuLi4gfSlcbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHZpZXcjbG9hZFxuICAgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kdmlld1xuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWVcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9wdGlvbiBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQobmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0LCBkZWZhdWx0cyA9IHtcbiAgICAgICAgICB0ZW1wbGF0ZTogbnVsbCwgY29udHJvbGxlcjogbnVsbCwgdmlldzogbnVsbCwgbG9jYWxzOiBudWxsLCBub3RpZnk6IHRydWUsIGFzeW5jOiB0cnVlLCBwYXJhbXM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnZpZXcpIHtcbiAgICAgICAgICByZXN1bHQgPSAkdGVtcGxhdGVGYWN0b3J5LmZyb21Db25maWcob3B0aW9ucy52aWV3LCBvcHRpb25zLnBhcmFtcywgb3B0aW9ucy5sb2NhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykucHJvdmlkZXIoJyR2aWV3JywgJFZpZXdQcm92aWRlcik7XG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiR1aVZpZXdTY3JvbGxQcm92aWRlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvdmlkZXIgdGhhdCByZXR1cm5zIHRoZSB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiR1aVZpZXdTY3JvbGx9IHNlcnZpY2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRWaWV3U2Nyb2xsUHJvdmlkZXIoKSB7XG5cbiAgdmFyIHVzZUFuY2hvclNjcm9sbCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiR1aVZpZXdTY3JvbGxQcm92aWRlciN1c2VBbmNob3JTY3JvbGxcbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldmVydHMgYmFjayB0byB1c2luZyB0aGUgY29yZSBbYCRhbmNob3JTY3JvbGxgXShodHRwOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZy4kYW5jaG9yU2Nyb2xsKSBzZXJ2aWNlIGZvclxuICAgKiBzY3JvbGxpbmcgYmFzZWQgb24gdGhlIHVybCBhbmNob3IuXG4gICAqL1xuICB0aGlzLnVzZUFuY2hvclNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB1c2VBbmNob3JTY3JvbGwgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2Mgb2JqZWN0XG4gICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsXG4gICAqXG4gICAqIEByZXF1aXJlcyAkYW5jaG9yU2Nyb2xsXG4gICAqIEByZXF1aXJlcyAkdGltZW91dFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogV2hlbiBjYWxsZWQgd2l0aCBhIGpxTGl0ZSBlbGVtZW50LCBpdCBzY3JvbGxzIHRoZSBlbGVtZW50IGludG8gdmlldyAoYWZ0ZXIgYVxuICAgKiBgJHRpbWVvdXRgIHNvIHRoZSBET00gaGFzIHRpbWUgdG8gcmVmcmVzaCkuXG4gICAqXG4gICAqIElmIHlvdSBwcmVmZXIgdG8gcmVseSBvbiBgJGFuY2hvclNjcm9sbGAgdG8gc2Nyb2xsIHRoZSB2aWV3IHRvIHRoZSBhbmNob3IsXG4gICAqIHRoaXMgY2FuIGJlIGVuYWJsZWQgYnkgY2FsbGluZyB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiR1aVZpZXdTY3JvbGxQcm92aWRlciNtZXRob2RzX3VzZUFuY2hvclNjcm9sbCBgJHVpVmlld1Njcm9sbFByb3ZpZGVyLnVzZUFuY2hvclNjcm9sbCgpYH0uXG4gICAqL1xuICB0aGlzLiRnZXQgPSBbJyRhbmNob3JTY3JvbGwnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAoJGFuY2hvclNjcm9sbCwgJHRpbWVvdXQpIHtcbiAgICBpZiAodXNlQW5jaG9yU2Nyb2xsKSB7XG4gICAgICByZXR1cm4gJGFuY2hvclNjcm9sbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCRlbGVtZW50KSB7XG4gICAgICByZXR1cm4gJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAkZWxlbWVudFswXS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfSwgMCwgZmFsc2UpO1xuICAgIH07XG4gIH1dO1xufVxuXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykucHJvdmlkZXIoJyR1aVZpZXdTY3JvbGwnLCAkVmlld1Njcm9sbFByb3ZpZGVyKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXdcbiAqXG4gKiBAcmVxdWlyZXMgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICogQHJlcXVpcmVzICRjb21waWxlXG4gKiBAcmVxdWlyZXMgJGNvbnRyb2xsZXJcbiAqIEByZXF1aXJlcyAkaW5qZWN0b3JcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUuJHVpVmlld1Njcm9sbFxuICogQHJlcXVpcmVzICRkb2N1bWVudFxuICpcbiAqIEByZXN0cmljdCBFQ0FcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSB1aS12aWV3IGRpcmVjdGl2ZSB0ZWxscyAkc3RhdGUgd2hlcmUgdG8gcGxhY2UgeW91ciB0ZW1wbGF0ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIEEgdmlldyBuYW1lLiBUaGUgbmFtZSBzaG91bGQgYmUgdW5pcXVlIGFtb25nc3QgdGhlIG90aGVyIHZpZXdzIGluIHRoZVxuICogc2FtZSBzdGF0ZS4gWW91IGNhbiBoYXZlIHZpZXdzIG9mIHRoZSBzYW1lIG5hbWUgdGhhdCBsaXZlIGluIGRpZmZlcmVudCBzdGF0ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBhdXRvc2Nyb2xsIEl0IGFsbG93cyB5b3UgdG8gc2V0IHRoZSBzY3JvbGwgYmVoYXZpb3Igb2YgdGhlIGJyb3dzZXIgd2luZG93XG4gKiB3aGVuIGEgdmlldyBpcyBwb3B1bGF0ZWQuIEJ5IGRlZmF1bHQsICRhbmNob3JTY3JvbGwgaXMgb3ZlcnJpZGRlbiBieSB1aS1yb3V0ZXIncyBjdXN0b20gc2Nyb2xsXG4gKiBzZXJ2aWNlLCB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiR1aVZpZXdTY3JvbGx9LiBUaGlzIGN1c3RvbSBzZXJ2aWNlIGxldCdzIHlvdVxuICogc2Nyb2xsIHVpLXZpZXcgZWxlbWVudHMgaW50byB2aWV3IHdoZW4gdGhleSBhcmUgcG9wdWxhdGVkIGR1cmluZyBhIHN0YXRlIGFjdGl2YXRpb24uXG4gKlxuICogKk5vdGU6IFRvIHJldmVydCBiYWNrIHRvIG9sZCBbYCRhbmNob3JTY3JvbGxgXShodHRwOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZy4kYW5jaG9yU2Nyb2xsKVxuICogZnVuY3Rpb25hbGl0eSwgY2FsbCBgJHVpVmlld1Njcm9sbFByb3ZpZGVyLnVzZUFuY2hvclNjcm9sbCgpYC4qXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvbmxvYWQgRXhwcmVzc2lvbiB0byBldmFsdWF0ZSB3aGVuZXZlciB0aGUgdmlldyB1cGRhdGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBBIHZpZXcgY2FuIGJlIHVubmFtZWQgb3IgbmFtZWQuXG4gKiA8cHJlPlxuICogPCEtLSBVbm5hbWVkIC0tPlxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICpcbiAqIDwhLS0gTmFtZWQgLS0+XG4gKiA8ZGl2IHVpLXZpZXc9XCJ2aWV3TmFtZVwiPjwvZGl2PlxuICogPC9wcmU+XG4gKlxuICogWW91IGNhbiBvbmx5IGhhdmUgb25lIHVubmFtZWQgdmlldyB3aXRoaW4gYW55IHRlbXBsYXRlIChvciByb290IGh0bWwpLiBJZiB5b3UgYXJlIG9ubHkgdXNpbmcgYVxuICogc2luZ2xlIHZpZXcgYW5kIGl0IGlzIHVubmFtZWQgdGhlbiB5b3UgY2FuIHBvcHVsYXRlIGl0IGxpa2Ugc286XG4gKiA8cHJlPlxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHtcbiAqICAgdGVtcGxhdGU6IFwiPGgxPkhFTExPITwvaDE+XCJcbiAqIH0pXG4gKiA8L3ByZT5cbiAqXG4gKiBUaGUgYWJvdmUgaXMgYSBjb252ZW5pZW50IHNob3J0Y3V0IGVxdWl2YWxlbnQgdG8gc3BlY2lmeWluZyB5b3VyIHZpZXcgZXhwbGljaXRseSB3aXRoIHRoZSB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVByb3ZpZGVyI21ldGhvZHNfc3RhdGUgYHZpZXdzYH1cbiAqIGNvbmZpZyBwcm9wZXJ0eSwgYnkgbmFtZSwgaW4gdGhpcyBjYXNlIGFuIGVtcHR5IG5hbWU6XG4gKiA8cHJlPlxuICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHtcbiAqICAgdmlld3M6IHtcbiAqICAgICBcIlwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICogICAgIH1cbiAqICAgfSAgICBcbiAqIH0pXG4gKiA8L3ByZT5cbiAqXG4gKiBCdXQgdHlwaWNhbGx5IHlvdSdsbCBvbmx5IHVzZSB0aGUgdmlld3MgcHJvcGVydHkgaWYgeW91IG5hbWUgeW91ciB2aWV3IG9yIGhhdmUgbW9yZSB0aGFuIG9uZSB2aWV3XG4gKiBpbiB0aGUgc2FtZSB0ZW1wbGF0ZS4gVGhlcmUncyBub3QgcmVhbGx5IGEgY29tcGVsbGluZyByZWFzb24gdG8gbmFtZSBhIHZpZXcgaWYgaXRzIHRoZSBvbmx5IG9uZSxcbiAqIGJ1dCB5b3UgY291bGQgaWYgeW91IHdhbnRlZCwgbGlrZSBzbzpcbiAqIDxwcmU+XG4gKiA8ZGl2IHVpLXZpZXc9XCJtYWluXCI+PC9kaXY+XG4gKiA8L3ByZT5cbiAqIDxwcmU+XG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwibWFpblwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICogICAgIH1cbiAqICAgfSAgICBcbiAqIH0pXG4gKiA8L3ByZT5cbiAqXG4gKiBSZWFsbHkgdGhvdWdoLCB5b3UnbGwgdXNlIHZpZXdzIHRvIHNldCB1cCBtdWx0aXBsZSB2aWV3czpcbiAqIDxwcmU+XG4gKiA8ZGl2IHVpLXZpZXc+PC9kaXY+XG4gKiA8ZGl2IHVpLXZpZXc9XCJjaGFydFwiPjwvZGl2PlxuICogPGRpdiB1aS12aWV3PVwiZGF0YVwiPjwvZGl2PlxuICogPC9wcmU+XG4gKlxuICogPHByZT5cbiAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZVwiLCB7XG4gKiAgIHZpZXdzOiB7XG4gKiAgICAgXCJcIjoge1xuICogICAgICAgdGVtcGxhdGU6IFwiPGgxPkhFTExPITwvaDE+XCJcbiAqICAgICB9LFxuICogICAgIFwiY2hhcnRcIjoge1xuICogICAgICAgdGVtcGxhdGU6IFwiPGNoYXJ0X3RoaW5nLz5cIlxuICogICAgIH0sXG4gKiAgICAgXCJkYXRhXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxkYXRhX3RoaW5nLz5cIlxuICogICAgIH1cbiAqICAgfSAgICBcbiAqIH0pXG4gKiA8L3ByZT5cbiAqXG4gKiBFeGFtcGxlcyBmb3IgYGF1dG9zY3JvbGxgOlxuICpcbiAqIDxwcmU+XG4gKiA8IS0tIElmIGF1dG9zY3JvbGwgcHJlc2VudCB3aXRoIG5vIGV4cHJlc3Npb24sXG4gKiAgICAgIHRoZW4gc2Nyb2xsIHVpLXZpZXcgaW50byB2aWV3IC0tPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbC8+XG4gKlxuICogPCEtLSBJZiBhdXRvc2Nyb2xsIHByZXNlbnQgd2l0aCB2YWxpZCBleHByZXNzaW9uLFxuICogICAgICB0aGVuIHNjcm9sbCB1aS12aWV3IGludG8gdmlldyBpZiBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlIC0tPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbD0ndHJ1ZScvPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbD0nZmFsc2UnLz5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J3Njb3BlVmFyaWFibGUnLz5cbiAqIDwvcHJlPlxuICpcbiAqIFJlc29sdmUgZGF0YTpcbiAqXG4gKiBUaGUgcmVzb2x2ZWQgZGF0YSBmcm9tIHRoZSBzdGF0ZSdzIGByZXNvbHZlYCBibG9jayBpcyBwbGFjZWQgb24gdGhlIHNjb3BlIGFzIGAkcmVzb2x2ZWAgKHRoaXNcbiAqIGNhbiBiZSBjdXN0b21pemVkIHVzaW5nIFtbVmlld0RlY2xhcmF0aW9uLnJlc29sdmVBc11dKS4gIFRoaXMgY2FuIGJlIHRoZW4gYWNjZXNzZWQgZnJvbSB0aGUgdGVtcGxhdGUuXG4gKlxuICogTm90ZSB0aGF0IHdoZW4gYGNvbnRyb2xsZXJBc2AgaXMgYmVpbmcgdXNlZCwgYCRyZXNvbHZlYCBpcyBzZXQgb24gdGhlIGNvbnRyb2xsZXIgaW5zdGFuY2UgKmFmdGVyKiB0aGVcbiAqIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkLiAgVGhlIGAkb25Jbml0KClgIGhvb2sgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiBjb2RlIHdoaWNoXG4gKiBkZXBlbmRzIG9uIGAkcmVzb2x2ZWAgZGF0YS5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlIG9mICRyZXNvbHZlIGluIGEgdmlldyB0ZW1wbGF0ZVxuICogPHByZT5cbiAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKCdob21lJywge1xuICogICB0ZW1wbGF0ZTogJzxteS1jb21wb25lbnQgdXNlcj1cIiRyZXNvbHZlLnVzZXJcIj48L215LWNvbXBvbmVudD4nLFxuICogICByZXNvbHZlOiB7XG4gKiAgICAgdXNlcjogZnVuY3Rpb24oVXNlclNlcnZpY2UpIHsgcmV0dXJuIFVzZXJTZXJ2aWNlLmZldGNoVXNlcigpOyB9XG4gKiAgIH1cbiAqIH0pO1xuICogPC9wcmU+XG4gKi9cbiRWaWV3RGlyZWN0aXZlLiRpbmplY3QgPSBbJyRzdGF0ZScsICckaW5qZWN0b3InLCAnJHVpVmlld1Njcm9sbCcsICckaW50ZXJwb2xhdGUnLCAnJHEnXTtcbmZ1bmN0aW9uICRWaWV3RGlyZWN0aXZlKCAgICRzdGF0ZSwgICAkaW5qZWN0b3IsICAgJHVpVmlld1Njcm9sbCwgICAkaW50ZXJwb2xhdGUsICAgJHEpIHtcblxuICBmdW5jdGlvbiBnZXRTZXJ2aWNlKCkge1xuICAgIHJldHVybiAoJGluamVjdG9yLmhhcykgPyBmdW5jdGlvbihzZXJ2aWNlKSB7XG4gICAgICByZXR1cm4gJGluamVjdG9yLmhhcyhzZXJ2aWNlKSA/ICRpbmplY3Rvci5nZXQoc2VydmljZSkgOiBudWxsO1xuICAgIH0gOiBmdW5jdGlvbihzZXJ2aWNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gJGluamVjdG9yLmdldChzZXJ2aWNlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBzZXJ2aWNlID0gZ2V0U2VydmljZSgpLFxuICAgICAgJGFuaW1hdG9yID0gc2VydmljZSgnJGFuaW1hdG9yJyksXG4gICAgICAkYW5pbWF0ZSA9IHNlcnZpY2UoJyRhbmltYXRlJyk7XG5cbiAgLy8gUmV0dXJucyBhIHNldCBvZiBET00gbWFuaXB1bGF0aW9uIGZ1bmN0aW9ucyBiYXNlZCBvbiB3aGljaCBBbmd1bGFyIHZlcnNpb25cbiAgLy8gaXQgc2hvdWxkIHVzZVxuICBmdW5jdGlvbiBnZXRSZW5kZXJlcihhdHRycywgc2NvcGUpIHtcbiAgICB2YXIgc3RhdGljcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChlbGVtZW50LCB0YXJnZXQsIGNiKSB7IHRhcmdldC5hZnRlcihlbGVtZW50KTsgY2IoKTsgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChlbGVtZW50LCBjYikgeyBlbGVtZW50LnJlbW92ZSgpOyBjYigpOyB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBpZiAoJGFuaW1hdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbihlbGVtZW50LCB0YXJnZXQsIGNiKSB7XG4gICAgICAgICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA+IDIpIHtcbiAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCkudGhlbihjYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKGVsZW1lbnQsIGNiKSB7XG4gICAgICAgICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA+IDIpIHtcbiAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGVsZW1lbnQpLnRoZW4oY2IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbGVtZW50LCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgkYW5pbWF0b3IpIHtcbiAgICAgIHZhciBhbmltYXRlID0gJGFuaW1hdG9yICYmICRhbmltYXRvcihzY29wZSwgYXR0cnMpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24oZWxlbWVudCwgdGFyZ2V0LCBjYikge2FuaW1hdGUuZW50ZXIoZWxlbWVudCwgbnVsbCwgdGFyZ2V0KTsgY2IoKTsgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKGVsZW1lbnQsIGNiKSB7IGFuaW1hdGUubGVhdmUoZWxlbWVudCk7IGNiKCk7IH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRpY3MoKTtcbiAgfVxuXG4gIHZhciBkaXJlY3RpdmUgPSB7XG4gICAgcmVzdHJpY3Q6ICdFQ0EnLFxuICAgIHRlcm1pbmFsOiB0cnVlLFxuICAgIHByaW9yaXR5OiA0MDAsXG4gICAgdHJhbnNjbHVkZTogJ2VsZW1lbnQnLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uICh0RWxlbWVudCwgdEF0dHJzLCAkdHJhbnNjbHVkZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgJGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHZhciBwcmV2aW91c0VsLCBjdXJyZW50RWwsIGN1cnJlbnRTY29wZSwgbGF0ZXN0TG9jYWxzLFxuICAgICAgICAgICAgb25sb2FkRXhwICAgICA9IGF0dHJzLm9ubG9hZCB8fCAnJyxcbiAgICAgICAgICAgIGF1dG9TY3JvbGxFeHAgPSBhdHRycy5hdXRvc2Nyb2xsLFxuICAgICAgICAgICAgcmVuZGVyZXIgICAgICA9IGdldFJlbmRlcmVyKGF0dHJzLCBzY29wZSksXG4gICAgICAgICAgICBpbmhlcml0ZWQgICAgID0gJGVsZW1lbnQuaW5oZXJpdGVkRGF0YSgnJHVpVmlldycpO1xuXG4gICAgICAgIHNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHVwZGF0ZVZpZXcoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB1cGRhdGVWaWV3KHRydWUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFudXBMYXN0VmlldygpIHtcbiAgICAgICAgICBpZiAocHJldmlvdXNFbCkge1xuICAgICAgICAgICAgcHJldmlvdXNFbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50U2NvcGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudEVsKSB7XG4gICAgICAgICAgICB2YXIgJHVpVmlld0RhdGEgPSBjdXJyZW50RWwuZGF0YSgnJHVpVmlld0FuaW0nKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmxlYXZlKGN1cnJlbnRFbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICR1aVZpZXdEYXRhLiQkYW5pbUxlYXZlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgcHJldmlvdXNFbCA9IG51bGw7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJldmlvdXNFbCA9IGN1cnJlbnRFbDtcbiAgICAgICAgICAgIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmlldyhmaXJzdFRpbWUpIHtcbiAgICAgICAgICB2YXIgbmV3U2NvcGUsXG4gICAgICAgICAgICAgIG5hbWUgICAgICAgICAgICA9IGdldFVpVmlld05hbWUoc2NvcGUsIGF0dHJzLCAkZWxlbWVudCwgJGludGVycG9sYXRlKSxcbiAgICAgICAgICAgICAgcHJldmlvdXNMb2NhbHMgID0gbmFtZSAmJiAkc3RhdGUuJGN1cnJlbnQgJiYgJHN0YXRlLiRjdXJyZW50LmxvY2Fsc1tuYW1lXTtcblxuICAgICAgICAgIGlmICghZmlyc3RUaW1lICYmIHByZXZpb3VzTG9jYWxzID09PSBsYXRlc3RMb2NhbHMpIHJldHVybjsgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuJG5ldygpO1xuICAgICAgICAgIGxhdGVzdExvY2FscyA9ICRzdGF0ZS4kY3VycmVudC5sb2NhbHNbbmFtZV07XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAbmdkb2MgZXZlbnRcbiAgICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXcjJHZpZXdDb250ZW50TG9hZGluZ1xuICAgICAgICAgICAqIEBldmVudE9mIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlld1xuICAgICAgICAgICAqIEBldmVudFR5cGUgZW1pdHMgb24gdWktdmlldyBkaXJlY3RpdmUgc2NvcGVcbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEZpcmVkIG9uY2UgdGhlIHZpZXcgKipiZWdpbnMgbG9hZGluZyoqLCAqYmVmb3JlKiB0aGUgRE9NIGlzIHJlbmRlcmVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld05hbWUgTmFtZSBvZiB0aGUgdmlldy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBuZXdTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50TG9hZGluZycsIG5hbWUpO1xuXG4gICAgICAgICAgdmFyIGNsb25lID0gJHRyYW5zY2x1ZGUobmV3U2NvcGUsIGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICAgICAgICB2YXIgYW5pbUVudGVyID0gJHEuZGVmZXIoKSwgYW5pbUxlYXZlID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIHZhciB2aWV3QW5pbURhdGEgPSB7XG4gICAgICAgICAgICAgICRhbmltRW50ZXI6IGFuaW1FbnRlci5wcm9taXNlLFxuICAgICAgICAgICAgICAkYW5pbUxlYXZlOiBhbmltTGVhdmUucHJvbWlzZSxcbiAgICAgICAgICAgICAgJCRhbmltTGVhdmU6IGFuaW1MZWF2ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2xvbmUuZGF0YSgnJHVpVmlld0FuaW0nLCB2aWV3QW5pbURhdGEpO1xuICAgICAgICAgICAgcmVuZGVyZXIuZW50ZXIoY2xvbmUsICRlbGVtZW50LCBmdW5jdGlvbiBvblVpVmlld0VudGVyKCkge1xuICAgICAgICAgICAgICBhbmltRW50ZXIucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICBpZihjdXJyZW50U2NvcGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudEFuaW1hdGlvbkVuZGVkJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXV0b1Njcm9sbEV4cCkgJiYgIWF1dG9TY3JvbGxFeHAgfHwgc2NvcGUuJGV2YWwoYXV0b1Njcm9sbEV4cCkpIHtcbiAgICAgICAgICAgICAgICAkdWlWaWV3U2Nyb2xsKGNsb25lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbGVhbnVwTGFzdFZpZXcoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGN1cnJlbnRFbCA9IGNsb25lO1xuICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlldyMkdmlld0NvbnRlbnRMb2FkZWRcbiAgICAgICAgICAgKiBAZXZlbnRPZiB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXdcbiAgICAgICAgICAgKiBAZXZlbnRUeXBlIGVtaXRzIG9uIHVpLXZpZXcgZGlyZWN0aXZlIHNjb3BlXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAgICogRmlyZWQgb25jZSB0aGUgdmlldyBpcyAqKmxvYWRlZCoqLCAqYWZ0ZXIqIHRoZSBET00gaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3TmFtZSBOYW1lIG9mIHRoZSB2aWV3LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGN1cnJlbnRTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50TG9hZGVkJywgbmFtZSk7XG4gICAgICAgICAgY3VycmVudFNjb3BlLiRldmFsKG9ubG9hZEV4cCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkaXJlY3RpdmU7XG59XG5cbiRWaWV3RGlyZWN0aXZlRmlsbC4kaW5qZWN0ID0gWyckY29tcGlsZScsICckY29udHJvbGxlcicsICckc3RhdGUnLCAnJGludGVycG9sYXRlJ107XG5mdW5jdGlvbiAkVmlld0RpcmVjdGl2ZUZpbGwgKCAgJGNvbXBpbGUsICAgJGNvbnRyb2xsZXIsICAgJHN0YXRlLCAgICRpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUNBJyxcbiAgICBwcmlvcml0eTogLTQwMCxcbiAgICBjb21waWxlOiBmdW5jdGlvbiAodEVsZW1lbnQpIHtcbiAgICAgIHZhciBpbml0aWFsID0gdEVsZW1lbnQuaHRtbCgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgJGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gJHN0YXRlLiRjdXJyZW50LFxuICAgICAgICAgICAgbmFtZSA9IGdldFVpVmlld05hbWUoc2NvcGUsIGF0dHJzLCAkZWxlbWVudCwgJGludGVycG9sYXRlKSxcbiAgICAgICAgICAgIGxvY2FscyAgPSBjdXJyZW50ICYmIGN1cnJlbnQubG9jYWxzW25hbWVdO1xuXG4gICAgICAgIGlmICghIGxvY2Fscykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICRlbGVtZW50LmRhdGEoJyR1aVZpZXcnLCB7IG5hbWU6IG5hbWUsIHN0YXRlOiBsb2NhbHMuJCRzdGF0ZSB9KTtcbiAgICAgICAgJGVsZW1lbnQuaHRtbChsb2NhbHMuJHRlbXBsYXRlID8gbG9jYWxzLiR0ZW1wbGF0ZSA6IGluaXRpYWwpO1xuXG4gICAgICAgIHZhciByZXNvbHZlRGF0YSA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBsb2NhbHMpO1xuICAgICAgICBzY29wZVtsb2NhbHMuJCRyZXNvbHZlQXNdID0gcmVzb2x2ZURhdGE7XG5cbiAgICAgICAgdmFyIGxpbmsgPSAkY29tcGlsZSgkZWxlbWVudC5jb250ZW50cygpKTtcblxuICAgICAgICBpZiAobG9jYWxzLiQkY29udHJvbGxlcikge1xuICAgICAgICAgIGxvY2Fscy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICBsb2NhbHMuJGVsZW1lbnQgPSAkZWxlbWVudDtcbiAgICAgICAgICB2YXIgY29udHJvbGxlciA9ICRjb250cm9sbGVyKGxvY2Fscy4kJGNvbnRyb2xsZXIsIGxvY2Fscyk7XG4gICAgICAgICAgaWYgKGxvY2Fscy4kJGNvbnRyb2xsZXJBcykge1xuICAgICAgICAgICAgc2NvcGVbbG9jYWxzLiQkY29udHJvbGxlckFzXSA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgICBzY29wZVtsb2NhbHMuJCRjb250cm9sbGVyQXNdW2xvY2Fscy4kJHJlc29sdmVBc10gPSByZXNvbHZlRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udHJvbGxlci4kb25Jbml0KSkgY29udHJvbGxlci4kb25Jbml0KCk7XG4gICAgICAgICAgJGVsZW1lbnQuZGF0YSgnJG5nQ29udHJvbGxlckNvbnRyb2xsZXInLCBjb250cm9sbGVyKTtcbiAgICAgICAgICAkZWxlbWVudC5jaGlsZHJlbigpLmRhdGEoJyRuZ0NvbnRyb2xsZXJDb250cm9sbGVyJywgY29udHJvbGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5rKHNjb3BlKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFNoYXJlZCB1aS12aWV3IGNvZGUgZm9yIGJvdGggZGlyZWN0aXZlczpcbiAqIEdpdmVuIHNjb3BlLCBlbGVtZW50LCBhbmQgaXRzIGF0dHJpYnV0ZXMsIHJldHVybiB0aGUgdmlldydzIG5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0VWlWaWV3TmFtZShzY29wZSwgYXR0cnMsIGVsZW1lbnQsICRpbnRlcnBvbGF0ZSkge1xuICB2YXIgbmFtZSA9ICRpbnRlcnBvbGF0ZShhdHRycy51aVZpZXcgfHwgYXR0cnMubmFtZSB8fCAnJykoc2NvcGUpO1xuICB2YXIgdWlWaWV3Q3JlYXRlZEJ5ID0gZWxlbWVudC5pbmhlcml0ZWREYXRhKCckdWlWaWV3Jyk7XG4gIHJldHVybiBuYW1lLmluZGV4T2YoJ0AnKSA+PSAwID8gIG5hbWUgOiAgKG5hbWUgKyAnQCcgKyAodWlWaWV3Q3JlYXRlZEJ5ID8gdWlWaWV3Q3JlYXRlZEJ5LnN0YXRlLm5hbWUgOiAnJykpO1xufVxuXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVZpZXcnLCAkVmlld0RpcmVjdGl2ZSk7XG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVZpZXcnLCAkVmlld0RpcmVjdGl2ZUZpbGwpO1xuXG5mdW5jdGlvbiBwYXJzZVN0YXRlUmVmKHJlZiwgY3VycmVudCkge1xuICB2YXIgcHJlcGFyc2VkID0gcmVmLm1hdGNoKC9eXFxzKih7W159XSp9KVxccyokLyksIHBhcnNlZDtcbiAgaWYgKHByZXBhcnNlZCkgcmVmID0gY3VycmVudCArICcoJyArIHByZXBhcnNlZFsxXSArICcpJztcbiAgcGFyc2VkID0gcmVmLnJlcGxhY2UoL1xcbi9nLCBcIiBcIikubWF0Y2goL14oW14oXSs/KVxccyooXFwoKC4qKVxcKSk/JC8pO1xuICBpZiAoIXBhcnNlZCB8fCBwYXJzZWQubGVuZ3RoICE9PSA0KSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIHJlZiAnXCIgKyByZWYgKyBcIidcIik7XG4gIHJldHVybiB7IHN0YXRlOiBwYXJzZWRbMV0sIHBhcmFtRXhwcjogcGFyc2VkWzNdIHx8IG51bGwgfTtcbn1cblxuZnVuY3Rpb24gc3RhdGVDb250ZXh0KGVsKSB7XG4gIHZhciBzdGF0ZURhdGEgPSBlbC5wYXJlbnQoKS5pbmhlcml0ZWREYXRhKCckdWlWaWV3Jyk7XG5cbiAgaWYgKHN0YXRlRGF0YSAmJiBzdGF0ZURhdGEuc3RhdGUgJiYgc3RhdGVEYXRhLnN0YXRlLm5hbWUpIHtcbiAgICByZXR1cm4gc3RhdGVEYXRhLnN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmZvKGVsKSB7XG4gIC8vIFNWR0FFbGVtZW50IGRvZXMgbm90IHVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUsIGJ1dCByYXRoZXIgdGhlICd4bGlua0hyZWYnIGF0dHJpYnV0ZS5cbiAgdmFyIGlzU3ZnID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsLnByb3AoJ2hyZWYnKSkgPT09ICdbb2JqZWN0IFNWR0FuaW1hdGVkU3RyaW5nXSc7XG4gIHZhciBpc0Zvcm0gPSBlbFswXS5ub2RlTmFtZSA9PT0gXCJGT1JNXCI7XG5cbiAgcmV0dXJuIHtcbiAgICBhdHRyOiBpc0Zvcm0gPyBcImFjdGlvblwiIDogKGlzU3ZnID8gJ3hsaW5rOmhyZWYnIDogJ2hyZWYnKSxcbiAgICBpc0FuY2hvcjogZWwucHJvcChcInRhZ05hbWVcIikudG9VcHBlckNhc2UoKSA9PT0gXCJBXCIsXG4gICAgY2xpY2thYmxlOiAhaXNGb3JtXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsaWNrSG9vayhlbCwgJHN0YXRlLCAkdGltZW91dCwgdHlwZSwgY3VycmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgIHZhciBidXR0b24gPSBlLndoaWNoIHx8IGUuYnV0dG9uLCB0YXJnZXQgPSBjdXJyZW50KCk7XG5cbiAgICBpZiAoIShidXR0b24gPiAxIHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlbC5hdHRyKCd0YXJnZXQnKSkpIHtcbiAgICAgIC8vIEhBQ0s6IFRoaXMgaXMgdG8gYWxsb3cgbmctY2xpY2tzIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmUgdGhlIHRyYW5zaXRpb24gaXMgaW5pdGlhdGVkOlxuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgJHN0YXRlLmdvKHRhcmdldC5zdGF0ZSwgdGFyZ2V0LnBhcmFtcywgdGFyZ2V0Lm9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIGlmIHRoZSBzdGF0ZSBoYXMgbm8gVVJMLCBpZ25vcmUgb25lIHByZXZlbnREZWZhdWx0IGZyb20gdGhlIDxhPiBkaXJlY3RpdmUuXG4gICAgICB2YXIgaWdub3JlUHJldmVudERlZmF1bHRDb3VudCA9IHR5cGUuaXNBbmNob3IgJiYgIXRhcmdldC5ocmVmID8gMTogMDtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaWdub3JlUHJldmVudERlZmF1bHRDb3VudC0tIDw9IDApICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0T3B0cyhlbCwgJHN0YXRlKSB7XG4gIHJldHVybiB7IHJlbGF0aXZlOiBzdGF0ZUNvbnRleHQoZWwpIHx8ICRzdGF0ZS4kY3VycmVudCwgaW5oZXJpdDogdHJ1ZSB9O1xufVxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktc3JlZlxuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gKiBAcmVxdWlyZXMgJHRpbWVvdXRcbiAqXG4gKiBAcmVzdHJpY3QgQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBkaXJlY3RpdmUgdGhhdCBiaW5kcyBhIGxpbmsgKGA8YT5gIHRhZykgdG8gYSBzdGF0ZS4gSWYgdGhlIHN0YXRlIGhhcyBhbiBhc3NvY2lhdGVkXG4gKiBVUkwsIHRoZSBkaXJlY3RpdmUgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlICYgdXBkYXRlIHRoZSBgaHJlZmAgYXR0cmlidXRlIHZpYVxuICogdGhlIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfaHJlZiAkc3RhdGUuaHJlZigpfSBtZXRob2QuIENsaWNraW5nXG4gKiB0aGUgbGluayB3aWxsIHRyaWdnZXIgYSBzdGF0ZSB0cmFuc2l0aW9uIHdpdGggb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAqXG4gKiBBbHNvIG1pZGRsZS1jbGlja2luZywgcmlnaHQtY2xpY2tpbmcsIGFuZCBjdHJsLWNsaWNraW5nIG9uIHRoZSBsaW5rIHdpbGwgYmVcbiAqIGhhbmRsZWQgbmF0aXZlbHkgYnkgdGhlIGJyb3dzZXIuXG4gKlxuICogWW91IGNhbiBhbHNvIHVzZSByZWxhdGl2ZSBzdGF0ZSBwYXRocyB3aXRoaW4gdWktc3JlZiwganVzdCBsaWtlIHRoZSByZWxhdGl2ZVxuICogcGF0aHMgcGFzc2VkIHRvIGAkc3RhdGUuZ28oKWAuIFlvdSBqdXN0IG5lZWQgdG8gYmUgYXdhcmUgdGhhdCB0aGUgcGF0aCBpcyByZWxhdGl2ZVxuICogdG8gdGhlIHN0YXRlIHRoYXQgdGhlIGxpbmsgbGl2ZXMgaW4sIGluIG90aGVyIHdvcmRzIHRoZSBzdGF0ZSB0aGF0IGxvYWRlZCB0aGVcbiAqIHRlbXBsYXRlIGNvbnRhaW5pbmcgdGhlIGxpbmsuXG4gKlxuICogWW91IGNhbiBzcGVjaWZ5IG9wdGlvbnMgdG8gcGFzcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNtZXRob2RzX2dvICRzdGF0ZS5nbygpfVxuICogdXNpbmcgdGhlIGB1aS1zcmVmLW9wdHNgIGF0dHJpYnV0ZS4gT3B0aW9ucyBhcmUgcmVzdHJpY3RlZCB0byBgbG9jYXRpb25gLCBgaW5oZXJpdGAsXG4gKiBhbmQgYHJlbG9hZGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIEhlcmUncyBhbiBleGFtcGxlIG9mIGhvdyB5b3UnZCB1c2UgdWktc3JlZiBhbmQgaG93IGl0IHdvdWxkIGNvbXBpbGUuIElmIHlvdSBoYXZlIHRoZVxuICogZm9sbG93aW5nIHRlbXBsYXRlOlxuICogPHByZT5cbiAqIDxhIHVpLXNyZWY9XCJob21lXCI+SG9tZTwvYT4gfCA8YSB1aS1zcmVmPVwiYWJvdXRcIj5BYm91dDwvYT4gfCA8YSB1aS1zcmVmPVwie3BhZ2U6IDJ9XCI+TmV4dCBwYWdlPC9hPlxuICpcbiAqIDx1bD5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj57eyBjb250YWN0Lm5hbWUgfX08L2E+XG4gKiAgICAgPC9saT5cbiAqIDwvdWw+XG4gKiA8L3ByZT5cbiAqXG4gKiBUaGVuIHRoZSBjb21waWxlZCBodG1sIHdvdWxkIGJlIChhc3N1bWluZyBIdG1sNU1vZGUgaXMgb2ZmIGFuZCBjdXJyZW50IHN0YXRlIGlzIGNvbnRhY3RzKTpcbiAqIDxwcmU+XG4gKiA8YSBocmVmPVwiIy9ob21lXCIgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPiB8IDxhIGhyZWY9XCIjL2Fib3V0XCIgdWktc3JlZj1cImFib3V0XCI+QWJvdXQ8L2E+IHwgPGEgaHJlZj1cIiMvY29udGFjdHM/cGFnZT0yXCIgdWktc3JlZj1cIntwYWdlOiAyfVwiPk5leHQgcGFnZTwvYT5cbiAqXG4gKiA8dWw+XG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAqICAgICAgICAgPGEgaHJlZj1cIiMvY29udGFjdHMvMVwiIHVpLXNyZWY9XCJjb250YWN0cy5kZXRhaWwoeyBpZDogY29udGFjdC5pZCB9KVwiPkpvZTwvYT5cbiAqICAgICA8L2xpPlxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzJcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5BbGljZTwvYT5cbiAqICAgICA8L2xpPlxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzNcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5Cb2I8L2E+XG4gKiAgICAgPC9saT5cbiAqIDwvdWw+XG4gKlxuICogPGEgdWktc3JlZj1cImhvbWVcIiB1aS1zcmVmLW9wdHM9XCJ7cmVsb2FkOiB0cnVlfVwiPkhvbWU8L2E+XG4gKiA8L3ByZT5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWktc3JlZiAnc3RhdGVOYW1lJyBjYW4gYmUgYW55IHZhbGlkIGFic29sdXRlIG9yIHJlbGF0aXZlIHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdWktc3JlZi1vcHRzIG9wdGlvbnMgdG8gcGFzcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNtZXRob2RzX2dvICRzdGF0ZS5nbygpfVxuICovXG4kU3RhdGVSZWZEaXJlY3RpdmUuJGluamVjdCA9IFsnJHN0YXRlJywgJyR0aW1lb3V0J107XG5mdW5jdGlvbiAkU3RhdGVSZWZEaXJlY3RpdmUoJHN0YXRlLCAkdGltZW91dCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgcmVxdWlyZTogWyc/XnVpU3JlZkFjdGl2ZScsICc/XnVpU3JlZkFjdGl2ZUVxJ10sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB1aVNyZWZBY3RpdmUpIHtcbiAgICAgIHZhciByZWYgICAgPSBwYXJzZVN0YXRlUmVmKGF0dHJzLnVpU3JlZiwgJHN0YXRlLmN1cnJlbnQubmFtZSk7XG4gICAgICB2YXIgZGVmICAgID0geyBzdGF0ZTogcmVmLnN0YXRlLCBocmVmOiBudWxsLCBwYXJhbXM6IG51bGwgfTtcbiAgICAgIHZhciB0eXBlICAgPSBnZXRUeXBlSW5mbyhlbGVtZW50KTtcbiAgICAgIHZhciBhY3RpdmUgPSB1aVNyZWZBY3RpdmVbMV0gfHwgdWlTcmVmQWN0aXZlWzBdO1xuICAgICAgdmFyIHVubGlua0luZm9GbiA9IG51bGw7XG4gICAgICB2YXIgaG9va0ZuO1xuXG4gICAgICBkZWYub3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0T3B0cyhlbGVtZW50LCAkc3RhdGUpLCBhdHRycy51aVNyZWZPcHRzID8gc2NvcGUuJGV2YWwoYXR0cnMudWlTcmVmT3B0cykgOiB7fSk7XG5cbiAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCkgZGVmLnBhcmFtcyA9IGFuZ3VsYXIuY29weSh2YWwpO1xuICAgICAgICBkZWYuaHJlZiA9ICRzdGF0ZS5ocmVmKHJlZi5zdGF0ZSwgZGVmLnBhcmFtcywgZGVmLm9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh1bmxpbmtJbmZvRm4pIHVubGlua0luZm9GbigpO1xuICAgICAgICBpZiAoYWN0aXZlKSB1bmxpbmtJbmZvRm4gPSBhY3RpdmUuJCRhZGRTdGF0ZUluZm8ocmVmLnN0YXRlLCBkZWYucGFyYW1zKTtcbiAgICAgICAgaWYgKGRlZi5ocmVmICE9PSBudWxsKSBhdHRycy4kc2V0KHR5cGUuYXR0ciwgZGVmLmhyZWYpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHJlZi5wYXJhbUV4cHIpIHtcbiAgICAgICAgc2NvcGUuJHdhdGNoKHJlZi5wYXJhbUV4cHIsIGZ1bmN0aW9uKHZhbCkgeyBpZiAodmFsICE9PSBkZWYucGFyYW1zKSB1cGRhdGUodmFsKTsgfSwgdHJ1ZSk7XG4gICAgICAgIGRlZi5wYXJhbXMgPSBhbmd1bGFyLmNvcHkoc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwcikpO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG5cbiAgICAgIGlmICghdHlwZS5jbGlja2FibGUpIHJldHVybjtcbiAgICAgIGhvb2tGbiA9IGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZjsgfSk7XG4gICAgICBlbGVtZW50W2VsZW1lbnQub24gPyAnb24nIDogJ2JpbmQnXShcImNsaWNrXCIsIGhvb2tGbik7XG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnRbZWxlbWVudC5vZmYgPyAnb2ZmJyA6ICd1bmJpbmQnXShcImNsaWNrXCIsIGhvb2tGbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS1zdGF0ZVxuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUudWlTcmVmXG4gKlxuICogQHJlc3RyaWN0IEFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE11Y2ggbGlrZSB1aS1zcmVmLCBidXQgd2lsbCBhY2NlcHQgbmFtZWQgJHNjb3BlIHByb3BlcnRpZXMgdG8gZXZhbHVhdGUgZm9yIGEgc3RhdGUgZGVmaW5pdGlvbixcbiAqIHBhcmFtcyBhbmQgb3ZlcnJpZGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWktc3RhdGUgJ3N0YXRlTmFtZScgY2FuIGJlIGFueSB2YWxpZCBhYnNvbHV0ZSBvciByZWxhdGl2ZSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHVpLXN0YXRlLXBhcmFtcyBwYXJhbXMgdG8gcGFzcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNtZXRob2RzX2hyZWYgJHN0YXRlLmhyZWYoKX1cbiAqIEBwYXJhbSB7T2JqZWN0fSB1aS1zdGF0ZS1vcHRzIG9wdGlvbnMgdG8gcGFzcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNtZXRob2RzX2dvICRzdGF0ZS5nbygpfVxuICovXG4kU3RhdGVSZWZEeW5hbWljRGlyZWN0aXZlLiRpbmplY3QgPSBbJyRzdGF0ZScsICckdGltZW91dCddO1xuZnVuY3Rpb24gJFN0YXRlUmVmRHluYW1pY0RpcmVjdGl2ZSgkc3RhdGUsICR0aW1lb3V0KSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICByZXF1aXJlOiBbJz9edWlTcmVmQWN0aXZlJywgJz9edWlTcmVmQWN0aXZlRXEnXSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHVpU3JlZkFjdGl2ZSkge1xuICAgICAgdmFyIHR5cGUgICA9IGdldFR5cGVJbmZvKGVsZW1lbnQpO1xuICAgICAgdmFyIGFjdGl2ZSA9IHVpU3JlZkFjdGl2ZVsxXSB8fCB1aVNyZWZBY3RpdmVbMF07XG4gICAgICB2YXIgZ3JvdXAgID0gW2F0dHJzLnVpU3RhdGUsIGF0dHJzLnVpU3RhdGVQYXJhbXMgfHwgbnVsbCwgYXR0cnMudWlTdGF0ZU9wdHMgfHwgbnVsbF07XG4gICAgICB2YXIgd2F0Y2ggID0gJ1snICsgZ3JvdXAubWFwKGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsIHx8ICdudWxsJzsgfSkuam9pbignLCAnKSArICddJztcbiAgICAgIHZhciBkZWYgICAgPSB7IHN0YXRlOiBudWxsLCBwYXJhbXM6IG51bGwsIG9wdGlvbnM6IG51bGwsIGhyZWY6IG51bGwgfTtcbiAgICAgIHZhciB1bmxpbmtJbmZvRm4gPSBudWxsO1xuICAgICAgdmFyIGhvb2tGbjtcblxuICAgICAgZnVuY3Rpb24gcnVuU3RhdGVSZWZMaW5rIChncm91cCkge1xuICAgICAgICBkZWYuc3RhdGUgPSBncm91cFswXTsgZGVmLnBhcmFtcyA9IGdyb3VwWzFdOyBkZWYub3B0aW9ucyA9IGdyb3VwWzJdO1xuICAgICAgICBkZWYuaHJlZiA9ICRzdGF0ZS5ocmVmKGRlZi5zdGF0ZSwgZGVmLnBhcmFtcywgZGVmLm9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh1bmxpbmtJbmZvRm4pIHVubGlua0luZm9GbigpO1xuICAgICAgICBpZiAoYWN0aXZlKSB1bmxpbmtJbmZvRm4gPSBhY3RpdmUuJCRhZGRTdGF0ZUluZm8oZGVmLnN0YXRlLCBkZWYucGFyYW1zKTtcbiAgICAgICAgaWYgKGRlZi5ocmVmKSBhdHRycy4kc2V0KHR5cGUuYXR0ciwgZGVmLmhyZWYpO1xuICAgICAgfVxuXG4gICAgICBzY29wZS4kd2F0Y2god2F0Y2gsIHJ1blN0YXRlUmVmTGluaywgdHJ1ZSk7XG4gICAgICBydW5TdGF0ZVJlZkxpbmsoc2NvcGUuJGV2YWwod2F0Y2gpKTtcblxuICAgICAgaWYgKCF0eXBlLmNsaWNrYWJsZSkgcmV0dXJuO1xuICAgICAgaG9va0ZuID0gY2xpY2tIb29rKGVsZW1lbnQsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVmOyB9KTtcbiAgICAgIGVsZW1lbnRbZWxlbWVudC5vbiA/ICdvbicgOiAnYmluZCddKFwiY2xpY2tcIiwgaG9va0ZuKTtcbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZWxlbWVudFtlbGVtZW50Lm9mZiA/ICdvZmYnIDogJ3VuYmluZCddKFwiY2xpY2tcIiwgaG9va0ZuKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktc3JlZi1hY3RpdmVcbiAqXG4gKiBAcmVxdWlyZXMgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICogQHJlcXVpcmVzIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVQYXJhbXNcbiAqIEByZXF1aXJlcyAkaW50ZXJwb2xhdGVcbiAqXG4gKiBAcmVzdHJpY3QgQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBkaXJlY3RpdmUgd29ya2luZyBhbG9uZ3NpZGUgdWktc3JlZiB0byBhZGQgY2xhc3NlcyB0byBhbiBlbGVtZW50IHdoZW4gdGhlXG4gKiByZWxhdGVkIHVpLXNyZWYgZGlyZWN0aXZlJ3Mgc3RhdGUgaXMgYWN0aXZlLCBhbmQgcmVtb3ZpbmcgdGhlbSB3aGVuIGl0IGlzIGluYWN0aXZlLlxuICogVGhlIHByaW1hcnkgdXNlLWNhc2UgaXMgdG8gc2ltcGxpZnkgdGhlIHNwZWNpYWwgYXBwZWFyYW5jZSBvZiBuYXZpZ2F0aW9uIG1lbnVzXG4gKiByZWx5aW5nIG9uIGB1aS1zcmVmYCwgYnkgaGF2aW5nIHRoZSBcImFjdGl2ZVwiIHN0YXRlJ3MgbWVudSBidXR0b24gYXBwZWFyIGRpZmZlcmVudCxcbiAqIGRpc3Rpbmd1aXNoaW5nIGl0IGZyb20gdGhlIGluYWN0aXZlIG1lbnUgaXRlbXMuXG4gKlxuICogdWktc3JlZi1hY3RpdmUgY2FuIGxpdmUgb24gdGhlIHNhbWUgZWxlbWVudCBhcyB1aS1zcmVmIG9yIG9uIGEgcGFyZW50IGVsZW1lbnQuIFRoZSBmaXJzdFxuICogdWktc3JlZi1hY3RpdmUgZm91bmQgYXQgdGhlIHNhbWUgbGV2ZWwgb3IgYWJvdmUgdGhlIHVpLXNyZWYgd2lsbCBiZSB1c2VkLlxuICpcbiAqIFdpbGwgYWN0aXZhdGUgd2hlbiB0aGUgdWktc3JlZidzIHRhcmdldCBzdGF0ZSBvciBhbnkgY2hpbGQgc3RhdGUgaXMgYWN0aXZlLiBJZiB5b3VcbiAqIG5lZWQgdG8gYWN0aXZhdGUgb25seSB3aGVuIHRoZSB1aS1zcmVmIHRhcmdldCBzdGF0ZSBpcyBhY3RpdmUgYW5kICpub3QqIGFueSBvZlxuICogaXQncyBjaGlsZHJlbiwgdGhlbiB5b3Ugd2lsbCB1c2VcbiAqIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXNyZWYtYWN0aXZlLWVxIHVpLXNyZWYtYWN0aXZlLWVxfVxuICpcbiAqIEBleGFtcGxlXG4gKiBHaXZlbiB0aGUgZm9sbG93aW5nIHRlbXBsYXRlOlxuICogPHByZT5cbiAqIDx1bD5cbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgY2xhc3M9XCJpdGVtXCI+XG4gKiAgICAgPGEgaHJlZiB1aS1zcmVmPVwiYXBwLnVzZXIoe3VzZXI6ICdiaWxib2JhZ2dpbnMnfSlcIj5AYmlsYm9iYWdnaW5zPC9hPlxuICogICA8L2xpPlxuICogPC91bD5cbiAqIDwvcHJlPlxuICpcbiAqXG4gKiBXaGVuIHRoZSBhcHAgc3RhdGUgaXMgXCJhcHAudXNlclwiIChvciBhbnkgY2hpbGRyZW4gc3RhdGVzKSwgYW5kIGNvbnRhaW5zIHRoZSBzdGF0ZSBwYXJhbWV0ZXIgXCJ1c2VyXCIgd2l0aCB2YWx1ZSBcImJpbGJvYmFnZ2luc1wiLFxuICogdGhlIHJlc3VsdGluZyBIVE1MIHdpbGwgYXBwZWFyIGFzIChub3RlIHRoZSAnYWN0aXZlJyBjbGFzcyk6XG4gKiA8cHJlPlxuICogPHVsPlxuICogICA8bGkgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiBjbGFzcz1cIml0ZW0gYWN0aXZlXCI+XG4gKiAgICAgPGEgdWktc3JlZj1cImFwcC51c2VyKHt1c2VyOiAnYmlsYm9iYWdnaW5zJ30pXCIgaHJlZj1cIi91c2Vycy9iaWxib2JhZ2dpbnNcIj5AYmlsYm9iYWdnaW5zPC9hPlxuICogICA8L2xpPlxuICogPC91bD5cbiAqIDwvcHJlPlxuICpcbiAqIFRoZSBjbGFzcyBuYW1lIGlzIGludGVycG9sYXRlZCAqKm9uY2UqKiBkdXJpbmcgdGhlIGRpcmVjdGl2ZXMgbGluayB0aW1lIChhbnkgZnVydGhlciBjaGFuZ2VzIHRvIHRoZVxuICogaW50ZXJwb2xhdGVkIHZhbHVlIGFyZSBpZ25vcmVkKS5cbiAqXG4gKiBNdWx0aXBsZSBjbGFzc2VzIG1heSBiZSBzcGVjaWZpZWQgaW4gYSBzcGFjZS1zZXBhcmF0ZWQgZm9ybWF0OlxuICogPHByZT5cbiAqIDx1bD5cbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPSdjbGFzczEgY2xhc3MyIGNsYXNzMyc+XG4gKiAgICAgPGEgdWktc3JlZj1cImFwcC51c2VyXCI+bGluazwvYT5cbiAqICAgPC9saT5cbiAqIDwvdWw+XG4gKiA8L3ByZT5cbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHBhc3MgdWktc3JlZi1hY3RpdmUgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlc1xuICogdG8gYW4gb2JqZWN0IGhhc2gsIHdob3NlIGtleXMgcmVwcmVzZW50IGFjdGl2ZSBjbGFzcyBuYW1lcyBhbmQgd2hvc2VcbiAqIHZhbHVlcyByZXByZXNlbnQgdGhlIHJlc3BlY3RpdmUgc3RhdGUgbmFtZXMvZ2xvYnMuXG4gKiB1aS1zcmVmLWFjdGl2ZSB3aWxsIG1hdGNoIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSAqKmluY2x1ZGVzKiogYW55IG9mXG4gKiB0aGUgc3BlY2lmaWVkIHN0YXRlIG5hbWVzL2dsb2JzLCBldmVuIHRoZSBhYnN0cmFjdCBvbmVzLlxuICpcbiAqIEBFeGFtcGxlXG4gKiBHaXZlbiB0aGUgZm9sbG93aW5nIHRlbXBsYXRlLCB3aXRoIFwiYWRtaW5cIiBiZWluZyBhbiBhYnN0cmFjdCBzdGF0ZTpcbiAqIDxwcmU+XG4gKiA8ZGl2IHVpLXNyZWYtYWN0aXZlPVwieydhY3RpdmUnOiAnYWRtaW4uKid9XCI+XG4gKiAgIDxhIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgdWktc3JlZj1cImFkbWluLnJvbGVzXCI+Um9sZXM8L2E+XG4gKiA8L2Rpdj5cbiAqIDwvcHJlPlxuICpcbiAqIFdoZW4gdGhlIGN1cnJlbnQgc3RhdGUgaXMgXCJhZG1pbi5yb2xlc1wiIHRoZSBcImFjdGl2ZVwiIGNsYXNzIHdpbGwgYmUgYXBwbGllZFxuICogdG8gYm90aCB0aGUgPGRpdj4gYW5kIDxhPiBlbGVtZW50cy4gSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB0aGUgc3RhdGVcbiAqIG5hbWVzL2dsb2JzIHBhc3NlZCB0byB1aS1zcmVmLWFjdGl2ZSBzaGFkb3cgdGhlIHN0YXRlIHByb3ZpZGVkIGJ5IHVpLXNyZWYuXG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXNyZWYtYWN0aXZlLWVxXG4gKlxuICogQHJlcXVpcmVzIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUGFyYW1zXG4gKiBAcmVxdWlyZXMgJGludGVycG9sYXRlXG4gKlxuICogQHJlc3RyaWN0IEFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBzYW1lIGFzIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXNyZWYtYWN0aXZlIHVpLXNyZWYtYWN0aXZlfSBidXQgd2lsbCBvbmx5IGFjdGl2YXRlXG4gKiB3aGVuIHRoZSBleGFjdCB0YXJnZXQgc3RhdGUgdXNlZCBpbiB0aGUgYHVpLXNyZWZgIGlzIGFjdGl2ZTsgbm8gY2hpbGQgc3RhdGVzLlxuICpcbiAqL1xuJFN0YXRlUmVmQWN0aXZlRGlyZWN0aXZlLiRpbmplY3QgPSBbJyRzdGF0ZScsICckc3RhdGVQYXJhbXMnLCAnJGludGVycG9sYXRlJ107XG5mdW5jdGlvbiAkU3RhdGVSZWZBY3RpdmVEaXJlY3RpdmUoJHN0YXRlLCAkc3RhdGVQYXJhbXMsICRpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4gIHtcbiAgICByZXN0cmljdDogXCJBXCIsXG4gICAgY29udHJvbGxlcjogWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJywgJyR0aW1lb3V0JywgZnVuY3Rpb24gKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJHRpbWVvdXQpIHtcbiAgICAgIHZhciBzdGF0ZXMgPSBbXSwgYWN0aXZlQ2xhc3NlcyA9IHt9LCBhY3RpdmVFcUNsYXNzLCB1aVNyZWZBY3RpdmU7XG5cbiAgICAgIC8vIFRoZXJlIHByb2JhYmx5IGlzbid0IG11Y2ggcG9pbnQgaW4gJG9ic2VydmluZyB0aGlzXG4gICAgICAvLyB1aVNyZWZBY3RpdmUgYW5kIHVpU3JlZkFjdGl2ZUVxIHNoYXJlIHRoZSBzYW1lIGRpcmVjdGl2ZSBvYmplY3Qgd2l0aCBzb21lXG4gICAgICAvLyBzbGlnaHQgZGlmZmVyZW5jZSBpbiBsb2dpYyByb3V0aW5nXG4gICAgICBhY3RpdmVFcUNsYXNzID0gJGludGVycG9sYXRlKCRhdHRycy51aVNyZWZBY3RpdmVFcSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHVpU3JlZkFjdGl2ZSA9ICRzY29wZS4kZXZhbCgkYXR0cnMudWlTcmVmQWN0aXZlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy4gdWlTcmVmQWN0aXZlIGlzIG5vdCBhIHZhbGlkIGV4cHJlc3Npb24uXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyAkaW50ZXJwb2xhdGUgYmVsb3dcbiAgICAgIH1cbiAgICAgIHVpU3JlZkFjdGl2ZSA9IHVpU3JlZkFjdGl2ZSB8fCAkaW50ZXJwb2xhdGUoJGF0dHJzLnVpU3JlZkFjdGl2ZSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG4gICAgICBpZiAoaXNPYmplY3QodWlTcmVmQWN0aXZlKSkge1xuICAgICAgICBmb3JFYWNoKHVpU3JlZkFjdGl2ZSwgZnVuY3Rpb24oc3RhdGVPck5hbWUsIGFjdGl2ZUNsYXNzKSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHN0YXRlT3JOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHJlZiA9IHBhcnNlU3RhdGVSZWYoc3RhdGVPck5hbWUsICRzdGF0ZS5jdXJyZW50Lm5hbWUpO1xuICAgICAgICAgICAgYWRkU3RhdGUocmVmLnN0YXRlLCAkc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwciksIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyB1aVNyZWYgdG8gY29tbXVuaWNhdGUgd2l0aCB1aVNyZWZBY3RpdmVbRXF1YWxzXVxuICAgICAgdGhpcy4kJGFkZFN0YXRlSW5mbyA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgbmV3UGFyYW1zKSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgZ290IGFuIGV4cGxpY2l0IHN0YXRlIHByb3ZpZGVkIGJ5IHVpLXNyZWYtYWN0aXZlLCBzbyB3ZVxuICAgICAgICAvLyBzaGFkb3cgdGhlIG9uZSB0aGF0IGNvbWVzIGZyb20gdWktc3JlZlxuICAgICAgICBpZiAoaXNPYmplY3QodWlTcmVmQWN0aXZlKSAmJiBzdGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVyZWdpc3RlciA9IGFkZFN0YXRlKG5ld1N0YXRlLCBuZXdQYXJhbXMsIHVpU3JlZkFjdGl2ZSk7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gZGVyZWdpc3RlcjtcbiAgICAgIH07XG5cbiAgICAgICRzY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN1Y2Nlc3MnLCB1cGRhdGUpO1xuXG4gICAgICBmdW5jdGlvbiBhZGRTdGF0ZShzdGF0ZU5hbWUsIHN0YXRlUGFyYW1zLCBhY3RpdmVDbGFzcykge1xuICAgICAgICB2YXIgc3RhdGUgPSAkc3RhdGUuZ2V0KHN0YXRlTmFtZSwgc3RhdGVDb250ZXh0KCRlbGVtZW50KSk7XG4gICAgICAgIHZhciBzdGF0ZUhhc2ggPSBjcmVhdGVTdGF0ZUhhc2goc3RhdGVOYW1lLCBzdGF0ZVBhcmFtcyk7XG5cbiAgICAgICAgdmFyIHN0YXRlSW5mbyA9IHtcbiAgICAgICAgICBzdGF0ZTogc3RhdGUgfHwgeyBuYW1lOiBzdGF0ZU5hbWUgfSxcbiAgICAgICAgICBwYXJhbXM6IHN0YXRlUGFyYW1zLFxuICAgICAgICAgIGhhc2g6IHN0YXRlSGFzaFxuICAgICAgICB9O1xuXG4gICAgICAgIHN0YXRlcy5wdXNoKHN0YXRlSW5mbyk7XG4gICAgICAgIGFjdGl2ZUNsYXNzZXNbc3RhdGVIYXNoXSA9IGFjdGl2ZUNsYXNzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVTdGF0ZSgpIHtcbiAgICAgICAgICB2YXIgaWR4ID0gc3RhdGVzLmluZGV4T2Yoc3RhdGVJbmZvKTtcbiAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkgc3RhdGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbcGFyYW1zXVxuICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBjcmVhdGVTdGF0ZUhhc2goc3RhdGUsIHBhcmFtcykge1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhdGUgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUgKyB0b0pzb24ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSAkc2NvcGUuJGV2YWwocGFyYW1zKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUgKyB0b0pzb24ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSByb3V0ZSBzdGF0ZVxuICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhbnlNYXRjaChzdGF0ZXNbaV0uc3RhdGUsIHN0YXRlc1tpXS5wYXJhbXMpKSB7XG4gICAgICAgICAgICBhZGRDbGFzcygkZWxlbWVudCwgYWN0aXZlQ2xhc3Nlc1tzdGF0ZXNbaV0uaGFzaF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcygkZWxlbWVudCwgYWN0aXZlQ2xhc3Nlc1tzdGF0ZXNbaV0uaGFzaF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChleGFjdE1hdGNoKHN0YXRlc1tpXS5zdGF0ZSwgc3RhdGVzW2ldLnBhcmFtcykpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKCRlbGVtZW50LCBhY3RpdmVFcUNsYXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoJGVsZW1lbnQsIGFjdGl2ZUVxQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKSB7ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHsgZWwuYWRkQ2xhc3MoY2xhc3NOYW1lKTsgfSk7IH1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHsgZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTsgfVxuICAgICAgZnVuY3Rpb24gYW55TWF0Y2goc3RhdGUsIHBhcmFtcykgeyByZXR1cm4gJHN0YXRlLmluY2x1ZGVzKHN0YXRlLm5hbWUsIHBhcmFtcyk7IH1cbiAgICAgIGZ1bmN0aW9uIGV4YWN0TWF0Y2goc3RhdGUsIHBhcmFtcykgeyByZXR1cm4gJHN0YXRlLmlzKHN0YXRlLm5hbWUsIHBhcmFtcyk7IH1cblxuICAgICAgdXBkYXRlKCk7XG4gICAgfV1cbiAgfTtcbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gIC5kaXJlY3RpdmUoJ3VpU3JlZicsICRTdGF0ZVJlZkRpcmVjdGl2ZSlcbiAgLmRpcmVjdGl2ZSgndWlTcmVmQWN0aXZlJywgJFN0YXRlUmVmQWN0aXZlRGlyZWN0aXZlKVxuICAuZGlyZWN0aXZlKCd1aVNyZWZBY3RpdmVFcScsICRTdGF0ZVJlZkFjdGl2ZURpcmVjdGl2ZSlcbiAgLmRpcmVjdGl2ZSgndWlTdGF0ZScsICRTdGF0ZVJlZkR5bmFtaWNEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5maWx0ZXI6aXNTdGF0ZVxuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUcmFuc2xhdGVzIHRvIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfaXMgJHN0YXRlLmlzKFwic3RhdGVOYW1lXCIpfS5cbiAqL1xuJElzU3RhdGVGaWx0ZXIuJGluamVjdCA9IFsnJHN0YXRlJ107XG5mdW5jdGlvbiAkSXNTdGF0ZUZpbHRlcigkc3RhdGUpIHtcbiAgdmFyIGlzRmlsdGVyID0gZnVuY3Rpb24gKHN0YXRlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gJHN0YXRlLmlzKHN0YXRlLCBwYXJhbXMpO1xuICB9O1xuICBpc0ZpbHRlci4kc3RhdGVmdWwgPSB0cnVlO1xuICByZXR1cm4gaXNGaWx0ZXI7XG59XG5cbi8qKlxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgdWkucm91dGVyLnN0YXRlLmZpbHRlcjppbmNsdWRlZEJ5U3RhdGVcbiAqXG4gKiBAcmVxdWlyZXMgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVHJhbnNsYXRlcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNtZXRob2RzX2luY2x1ZGVzICRzdGF0ZS5pbmNsdWRlcygnZnVsbE9yUGFydGlhbFN0YXRlTmFtZScpfS5cbiAqL1xuJEluY2x1ZGVkQnlTdGF0ZUZpbHRlci4kaW5qZWN0ID0gWyckc3RhdGUnXTtcbmZ1bmN0aW9uICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIoJHN0YXRlKSB7XG4gIHZhciBpbmNsdWRlc0ZpbHRlciA9IGZ1bmN0aW9uIChzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICRzdGF0ZS5pbmNsdWRlcyhzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfTtcbiAgaW5jbHVkZXNGaWx0ZXIuJHN0YXRlZnVsID0gdHJ1ZTtcbiAgcmV0dXJuICBpbmNsdWRlc0ZpbHRlcjtcbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gIC5maWx0ZXIoJ2lzU3RhdGUnLCAkSXNTdGF0ZUZpbHRlcilcbiAgLmZpbHRlcignaW5jbHVkZWRCeVN0YXRlJywgJEluY2x1ZGVkQnlTdGF0ZUZpbHRlcik7XG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhci11aS1yb3V0ZXIvcmVsZWFzZS9hbmd1bGFyLXVpLXJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\r\n\r\nangular.module('Authentication',[])\r\n  \r\n.factory('AuthenticationService',\r\n    function (Base64, $http, $cookieStore, $rootScope, $timeout,SiteEssentials) {\r\n        var service = {};\r\n \r\n        service.Login = function (username, password, callback,scope) {\r\n \r\n          \r\n            var parameters={ email: username, password: password };\r\n        $http({\r\n                url:'api/login',\r\n                method:'POST',\r\n                data:parameters \r\n            }).then(function (response) {\r\n                console.log(response);\r\n               \r\n                callback(response);\r\n            },function(response){\r\n                scope.error=response.data.message;\r\n                console.log(response);\r\n                scope.loginChecking=false;\r\n                SiteEssentials.responsCheck(response);\r\n            });\r\n \r\n        };\r\n  \r\n        service.SetCredentials = function (username, password,user_data) {\r\n            var authdata = Base64.encode(username + ':' + password);\r\n            \r\n            $rootScope.globals = {};\r\n            $rootScope.globals.currentUser=user_data;\r\n\r\n            $rootScope.globals.currentUser['username']=username;\r\n            $rootScope.globals.currentUser['authdata']=authdata;\r\n             $http.defaults.headers.common.Authorization = 'Bearer ' + user_data.token;\r\n            // $http.defaults.headers.common['Authorization'] = 'Basic ' + authdata; // jshint ignore:line\r\n            $cookieStore.put('globals', $rootScope.globals);\r\n        };\r\n  \r\n        service.ClearCredentials = function () {\r\n            $rootScope.globals = {};\r\n            $cookieStore.remove('globals');\r\n            $http.defaults.headers.common.Authorization = 'Bearer ';\r\n        };\r\n  \r\n        return service;\r\n    })\r\n  \r\n.factory('Base64', function () {\r\n    /* jshint ignore:start */\r\n  \r\n    var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n  \r\n    return {\r\n        encode: function (input) {\r\n            var output = \"\";\r\n            var chr1, chr2, chr3 = \"\";\r\n            var enc1, enc2, enc3, enc4 = \"\";\r\n            var i = 0;\r\n  \r\n            do {\r\n                chr1 = input.charCodeAt(i++);\r\n                chr2 = input.charCodeAt(i++);\r\n                chr3 = input.charCodeAt(i++);\r\n  \r\n                enc1 = chr1 >> 2;\r\n                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n                enc4 = chr3 & 63;\r\n  \r\n                if (isNaN(chr2)) {\r\n                    enc3 = enc4 = 64;\r\n                } else if (isNaN(chr3)) {\r\n                    enc4 = 64;\r\n                }\r\n  \r\n                output = output +\r\n                    keyStr.charAt(enc1) +\r\n                    keyStr.charAt(enc2) +\r\n                    keyStr.charAt(enc3) +\r\n                    keyStr.charAt(enc4);\r\n                chr1 = chr2 = chr3 = \"\";\r\n                enc1 = enc2 = enc3 = enc4 = \"\";\r\n            } while (i < input.length);\r\n  \r\n            return output;\r\n        },\r\n  \r\n        decode: function (input) {\r\n            var output = \"\";\r\n            var chr1, chr2, chr3 = \"\";\r\n            var enc1, enc2, enc3, enc4 = \"\";\r\n            var i = 0;\r\n  \r\n            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\r\n            var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\r\n            if (base64test.exec(input)) {\r\n                window.alert(\"There were invalid base64 characters in the input text.\\n\" +\r\n                    \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\\n\" +\r\n                    \"Expect errors in decoding.\");\r\n            }\r\n            input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\r\n  \r\n            do {\r\n                enc1 = keyStr.indexOf(input.charAt(i++));\r\n                enc2 = keyStr.indexOf(input.charAt(i++));\r\n                enc3 = keyStr.indexOf(input.charAt(i++));\r\n                enc4 = keyStr.indexOf(input.charAt(i++));\r\n  \r\n                chr1 = (enc1 << 2) | (enc2 >> 4);\r\n                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\r\n                chr3 = ((enc3 & 3) << 6) | enc4;\r\n  \r\n                output = output + String.fromCharCode(chr1);\r\n  \r\n                if (enc3 != 64) {\r\n                    output = output + String.fromCharCode(chr2);\r\n                }\r\n                if (enc4 != 64) {\r\n                    output = output + String.fromCharCode(chr3);\r\n                }\r\n  \r\n                chr1 = chr2 = chr3 = \"\";\r\n                enc1 = enc2 = enc3 = enc4 = \"\";\r\n  \r\n            } while (i < input.length);\r\n  \r\n            return output;\r\n        }\r\n    };\r\n  \r\n    /* jshint ignore:end */\r\n}).controller('LoginController',\r\n    function ($scope, $rootScope, $location, AuthenticationService,$window,$mdDialog,\r\n        ShowSimpleToast,$http,SiteEssentials,$state) {\r\n        // reset login status\r\n        AuthenticationService.ClearCredentials();\r\n        var state=$state.current.name;\r\n        if(state=='login.validate'){\r\n            $scope.validating=true;\r\n            $scope.reseting_password=false;\r\n        }else if(state=='login.reset_password'){\r\n            $scope.reseting_password=true;\r\n            $scope.validating=false;\r\n        }else{\r\n            $scope.reseting_password=false;\r\n            $scope.validating=false;\r\n        }\r\n        $rootScope.loggedin=false;\r\n        $rootScope.body='login_body';\r\n        $rootScope.page_title=' School | login';\r\n        $scope.password_type='password';\r\n        \r\n        $scope.toggleShow=function(){\r\n            if($scope.password_type=='password'){\r\n                $scope.password_type='text';\r\n            }else{\r\n                $scope.password_type='password';\r\n            }\r\n        }\r\n        $scope.login = function () {\r\n            $scope.loginChecking = true;\r\n\r\n            AuthenticationService.Login($scope.user.email, $scope.user.password, \r\n                function(response) {\r\n                // console.log(response);\r\n                if(response.data.success) {\r\n                    \r\n                    $scope.loginChecking = false;\r\n                    \r\n                    $scope.user=response.data.user_info;\r\n                    AuthenticationService.SetCredentials($scope.user.email,\r\n                    $scope.user.password,$scope.user);\r\n\r\n                    console.log($rootScope.globals);\r\n                    $location.path('/profile');\r\n                } else {\r\n                    $scope.error = response.data.message;\r\n                    $scope.loginChecking = false;\r\n\r\n                }\r\n            },$scope);\r\n        };\r\n        $scope.cancel_forget=function(response){\r\n            $scope.reseting_password=false;\r\n            $scope.$parent.reseting_password=false;\r\n            $scope.$parent.validating=false;\r\n            $scope.validating=false;\r\n        }\r\n        $scope.askToken=function(email){\r\n            var data={};\r\n            data.email=email;\r\n            var next='login.validate';\r\n            $scope.loginChecking=true;\r\n            $scope.$parent.loginChecking=true;\r\n            $http({url:'api/password/forget',data:data,method:'POST'}).then(function(response){\r\n                $scope.loginChecking = false;\r\n            $scope.$parent.loginChecking=false;\r\n\r\n                console.log(response);\r\n                if(response.data.success){\r\n                    if($state.current.name!=next){ $state.go('login.validate'); }\r\n                    else { $state.reload('login.validate'); }\r\n                    $scope.validating=true;\r\n                    ShowSimpleToast.show(response.data.message);\r\n                }else{\r\n                    ShowSimpleToast.show(response.data.message);\r\n                }\r\n            },function(response){\r\n                 $scope.loginChecking = false;\r\n            $scope.$parent.loginChecking=false;\r\n\r\n                 SiteEssentials.responsCheck(response);\r\n                 $scope.cancel_forget();\r\n            })\r\n        }\r\n        $scope.forget_password=function(ev){\r\n            if(!$scope.user){ $scope.user=[]; }\r\n             var confirm = $mdDialog.prompt()\r\n                  .title('Enter your email address')\r\n                  .textContent('An email with a token  will be sent to your email address if you are registered with us.')\r\n                  .placeholder('Email')\r\n                  .ariaLabel('email')\r\n                  .initialValue($scope.user.email)\r\n                  .targetEvent(ev)\r\n                  .ok('Send email')\r\n                  .cancel('Cancel');\r\n\r\n                $mdDialog.show(confirm).then(function(result) {\r\n                  $scope.user.email=result;\r\n                  console.log($scope.user.email);\r\n                  $scope.askToken($scope.user.email);\r\n                }, function() {\r\n                  $scope.status = false;\r\n                });\r\n        }\r\n\r\n        $scope.validate=function(pin){\r\n            var data={};\r\n            data.token=pin;\r\n            var next='login.reset_password';\r\n            $scope.$parent.loginChecking=true;\r\n            $http({url:'api/password/validate',data:data,method:'POST'}).then(function(response){\r\n                console.log(response)\r\n                $scope.$parent.loginChecking=false;\r\n                if(response.data.success){\r\n                    $scope.validating=false;\r\n                    $scope.reseting_password=true;\r\n                    if($state.current.name==next){ $state.reload(next); }\r\n                    else { $state.go(next); }\r\n                    \r\n                    $scope.user.id=response.data.id;\r\n                    ShowSimpleToast.show(response.data.message);\r\n                }else{\r\n                    ShowSimpleToast.show(response.data.message);\r\n                }\r\n            })\r\n        }\r\n        $scope.changePassword=function(password,id){\r\n            var data={};\r\n            data.user_id=id;\r\n            data.password=password;\r\n            $scope.$parent.loginChecking=true;\r\n            $http({url:'api/password/reset',data:data,method:'POST'}).then(function(response){\r\n                console.log(response);\r\n                $scope.$parent.loginChecking=false;\r\n               $scope.cancel_forget();\r\n               $state.go('login');\r\n               ShowSimpleToast.show(response.data.message);\r\n            })\r\n        }\r\n\r\n\r\n    });//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL2FuZ3VsYXIuYXV0aGVudGljYXRpb24uanM/OThhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgnQXV0aGVudGljYXRpb24nLFtdKVxyXG4gIFxyXG4uZmFjdG9yeSgnQXV0aGVudGljYXRpb25TZXJ2aWNlJyxcclxuICAgIGZ1bmN0aW9uIChCYXNlNjQsICRodHRwLCAkY29va2llU3RvcmUsICRyb290U2NvcGUsICR0aW1lb3V0LFNpdGVFc3NlbnRpYWxzKSB7XHJcbiAgICAgICAgdmFyIHNlcnZpY2UgPSB7fTtcclxuIFxyXG4gICAgICAgIHNlcnZpY2UuTG9naW4gPSBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkLCBjYWxsYmFjayxzY29wZSkge1xyXG4gXHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnM9eyBlbWFpbDogdXNlcm5hbWUsIHBhc3N3b3JkOiBwYXNzd29yZCB9O1xyXG4gICAgICAgICRodHRwKHtcclxuICAgICAgICAgICAgICAgIHVybDonYXBpL2xvZ2luJyxcclxuICAgICAgICAgICAgICAgIG1ldGhvZDonUE9TVCcsXHJcbiAgICAgICAgICAgICAgICBkYXRhOnBhcmFtZXRlcnMgXHJcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9LGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgICAgICAgICAgIHNjb3BlLmVycm9yPXJlc3BvbnNlLmRhdGEubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLmxvZ2luQ2hlY2tpbmc9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBTaXRlRXNzZW50aWFscy5yZXNwb25zQ2hlY2socmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuIFxyXG4gICAgICAgIH07XHJcbiAgXHJcbiAgICAgICAgc2VydmljZS5TZXRDcmVkZW50aWFscyA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsdXNlcl9kYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBhdXRoZGF0YSA9IEJhc2U2NC5lbmNvZGUodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmdsb2JhbHMgPSB7fTtcclxuICAgICAgICAgICAgJHJvb3RTY29wZS5nbG9iYWxzLmN1cnJlbnRVc2VyPXVzZXJfZGF0YTtcclxuXHJcbiAgICAgICAgICAgICRyb290U2NvcGUuZ2xvYmFscy5jdXJyZW50VXNlclsndXNlcm5hbWUnXT11c2VybmFtZTtcclxuICAgICAgICAgICAgJHJvb3RTY29wZS5nbG9iYWxzLmN1cnJlbnRVc2VyWydhdXRoZGF0YSddPWF1dGhkYXRhO1xyXG4gICAgICAgICAgICAgJGh0dHAuZGVmYXVsdHMuaGVhZGVycy5jb21tb24uQXV0aG9yaXphdGlvbiA9ICdCZWFyZXIgJyArIHVzZXJfZGF0YS50b2tlbjtcclxuICAgICAgICAgICAgLy8gJGh0dHAuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ0F1dGhvcml6YXRpb24nXSA9ICdCYXNpYyAnICsgYXV0aGRhdGE7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICAkY29va2llU3RvcmUucHV0KCdnbG9iYWxzJywgJHJvb3RTY29wZS5nbG9iYWxzKTtcclxuICAgICAgICB9O1xyXG4gIFxyXG4gICAgICAgIHNlcnZpY2UuQ2xlYXJDcmVkZW50aWFscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgJHJvb3RTY29wZS5nbG9iYWxzID0ge307XHJcbiAgICAgICAgICAgICRjb29raWVTdG9yZS5yZW1vdmUoJ2dsb2JhbHMnKTtcclxuICAgICAgICAgICAgJGh0dHAuZGVmYXVsdHMuaGVhZGVycy5jb21tb24uQXV0aG9yaXphdGlvbiA9ICdCZWFyZXIgJztcclxuICAgICAgICB9O1xyXG4gIFxyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlO1xyXG4gICAgfSlcclxuICBcclxuLmZhY3RvcnkoJ0Jhc2U2NCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuICBcclxuICAgIHZhciBrZXlTdHIgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xyXG4gIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcclxuICAgICAgICAgICAgdmFyIGNocjEsIGNocjIsIGNocjMgPSBcIlwiO1xyXG4gICAgICAgICAgICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNCA9IFwiXCI7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICBcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgY2hyMSA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICAgICAgICAgIGNocjIgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgICAgICAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xyXG4gIFxyXG4gICAgICAgICAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcclxuICAgICAgICAgICAgICAgIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xyXG4gICAgICAgICAgICAgICAgZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpO1xyXG4gICAgICAgICAgICAgICAgZW5jNCA9IGNocjMgJiA2MztcclxuICBcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihjaHIyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGNocjMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jNCA9IDY0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICtcclxuICAgICAgICAgICAgICAgICAgICBrZXlTdHIuY2hhckF0KGVuYzEpICtcclxuICAgICAgICAgICAgICAgICAgICBrZXlTdHIuY2hhckF0KGVuYzIpICtcclxuICAgICAgICAgICAgICAgICAgICBrZXlTdHIuY2hhckF0KGVuYzMpICtcclxuICAgICAgICAgICAgICAgICAgICBrZXlTdHIuY2hhckF0KGVuYzQpO1xyXG4gICAgICAgICAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSBcIlwiO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKTtcclxuICBcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9LFxyXG4gIFxyXG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xyXG4gICAgICAgICAgICB2YXIgY2hyMSwgY2hyMiwgY2hyMyA9IFwiXCI7XHJcbiAgICAgICAgICAgIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0ID0gXCJcIjtcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gIFxyXG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IEEtWiwgYS16LCAwLTksICssIC8sIG9yID1cclxuICAgICAgICAgICAgdmFyIGJhc2U2NHRlc3QgPSAvW15BLVphLXowLTlcXCtcXC9cXD1dL2c7XHJcbiAgICAgICAgICAgIGlmIChiYXNlNjR0ZXN0LmV4ZWMoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWxlcnQoXCJUaGVyZSB3ZXJlIGludmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0IHRleHQuXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiVmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMgYXJlIEEtWiwgYS16LCAwLTksICcrJywgJy8nLGFuZCAnPSdcXG5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3QgZXJyb3JzIGluIGRlY29kaW5nLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcclxuICBcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgZW5jMSA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICAgICAgICAgICAgICAgIGVuYzIgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICBlbmMzID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xyXG4gICAgICAgICAgICAgICAgZW5jNCA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICBcclxuICAgICAgICAgICAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xyXG4gICAgICAgICAgICAgICAgY2hyMiA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xyXG4gICAgICAgICAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcclxuICBcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMSk7XHJcbiAgXHJcbiAgICAgICAgICAgICAgICBpZiAoZW5jMyAhPSA2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5jNCAhPSA2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgICAgICAgICBjaHIxID0gY2hyMiA9IGNocjMgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgZW5jMSA9IGVuYzIgPSBlbmMzID0gZW5jNCA9IFwiXCI7XHJcbiAgXHJcbiAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpO1xyXG4gIFxyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgXHJcbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xyXG59KS5jb250cm9sbGVyKCdMb2dpbkNvbnRyb2xsZXInLFxyXG4gICAgZnVuY3Rpb24gKCRzY29wZSwgJHJvb3RTY29wZSwgJGxvY2F0aW9uLCBBdXRoZW50aWNhdGlvblNlcnZpY2UsJHdpbmRvdywkbWREaWFsb2csXHJcbiAgICAgICAgU2hvd1NpbXBsZVRvYXN0LCRodHRwLFNpdGVFc3NlbnRpYWxzLCRzdGF0ZSkge1xyXG4gICAgICAgIC8vIHJlc2V0IGxvZ2luIHN0YXR1c1xyXG4gICAgICAgIEF1dGhlbnRpY2F0aW9uU2VydmljZS5DbGVhckNyZWRlbnRpYWxzKCk7XHJcbiAgICAgICAgdmFyIHN0YXRlPSRzdGF0ZS5jdXJyZW50Lm5hbWU7XHJcbiAgICAgICAgaWYoc3RhdGU9PSdsb2dpbi52YWxpZGF0ZScpe1xyXG4gICAgICAgICAgICAkc2NvcGUudmFsaWRhdGluZz10cnVlO1xyXG4gICAgICAgICAgICAkc2NvcGUucmVzZXRpbmdfcGFzc3dvcmQ9ZmFsc2U7XHJcbiAgICAgICAgfWVsc2UgaWYoc3RhdGU9PSdsb2dpbi5yZXNldF9wYXNzd29yZCcpe1xyXG4gICAgICAgICAgICAkc2NvcGUucmVzZXRpbmdfcGFzc3dvcmQ9dHJ1ZTtcclxuICAgICAgICAgICAgJHNjb3BlLnZhbGlkYXRpbmc9ZmFsc2U7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICRzY29wZS5yZXNldGluZ19wYXNzd29yZD1mYWxzZTtcclxuICAgICAgICAgICAgJHNjb3BlLnZhbGlkYXRpbmc9ZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRyb290U2NvcGUubG9nZ2VkaW49ZmFsc2U7XHJcbiAgICAgICAgJHJvb3RTY29wZS5ib2R5PSdsb2dpbl9ib2R5JztcclxuICAgICAgICAkcm9vdFNjb3BlLnBhZ2VfdGl0bGU9JyBTY2hvb2wgfCBsb2dpbic7XHJcbiAgICAgICAgJHNjb3BlLnBhc3N3b3JkX3R5cGU9J3Bhc3N3b3JkJztcclxuICAgICAgICBcclxuICAgICAgICAkc2NvcGUudG9nZ2xlU2hvdz1mdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZigkc2NvcGUucGFzc3dvcmRfdHlwZT09J3Bhc3N3b3JkJyl7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUucGFzc3dvcmRfdHlwZT0ndGV4dCc7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLnBhc3N3b3JkX3R5cGU9J3Bhc3N3b3JkJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAkc2NvcGUubG9naW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5sb2dpbkNoZWNraW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uU2VydmljZS5Mb2dpbigkc2NvcGUudXNlci5lbWFpbCwgJHNjb3BlLnVzZXIucGFzc3dvcmQsIFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIGlmKHJlc3BvbnNlLmRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5sb2dpbkNoZWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnVzZXI9cmVzcG9uc2UuZGF0YS51c2VyX2luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgQXV0aGVudGljYXRpb25TZXJ2aWNlLlNldENyZWRlbnRpYWxzKCRzY29wZS51c2VyLmVtYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS51c2VyLnBhc3N3b3JkLCRzY29wZS51c2VyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJHJvb3RTY29wZS5nbG9iYWxzKTtcclxuICAgICAgICAgICAgICAgICAgICAkbG9jYXRpb24ucGF0aCgnL3Byb2ZpbGUnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVycm9yID0gcmVzcG9uc2UuZGF0YS5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5sb2dpbkNoZWNraW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCRzY29wZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAkc2NvcGUuY2FuY2VsX2ZvcmdldD1mdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICAgICAgICRzY29wZS5yZXNldGluZ19wYXNzd29yZD1mYWxzZTtcclxuICAgICAgICAgICAgJHNjb3BlLiRwYXJlbnQucmVzZXRpbmdfcGFzc3dvcmQ9ZmFsc2U7XHJcbiAgICAgICAgICAgICRzY29wZS4kcGFyZW50LnZhbGlkYXRpbmc9ZmFsc2U7XHJcbiAgICAgICAgICAgICRzY29wZS52YWxpZGF0aW5nPWZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkc2NvcGUuYXNrVG9rZW49ZnVuY3Rpb24oZW1haWwpe1xyXG4gICAgICAgICAgICB2YXIgZGF0YT17fTtcclxuICAgICAgICAgICAgZGF0YS5lbWFpbD1lbWFpbDtcclxuICAgICAgICAgICAgdmFyIG5leHQ9J2xvZ2luLnZhbGlkYXRlJztcclxuICAgICAgICAgICAgJHNjb3BlLmxvZ2luQ2hlY2tpbmc9dHJ1ZTtcclxuICAgICAgICAgICAgJHNjb3BlLiRwYXJlbnQubG9naW5DaGVja2luZz10cnVlO1xyXG4gICAgICAgICAgICAkaHR0cCh7dXJsOidhcGkvcGFzc3dvcmQvZm9yZ2V0JyxkYXRhOmRhdGEsbWV0aG9kOidQT1NUJ30pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmxvZ2luQ2hlY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgJHNjb3BlLiRwYXJlbnQubG9naW5DaGVja2luZz1mYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBpZihyZXNwb25zZS5kYXRhLnN1Y2Nlc3Mpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCRzdGF0ZS5jdXJyZW50Lm5hbWUhPW5leHQpJHN0YXRlLmdvKCdsb2dpbi52YWxpZGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgJHN0YXRlLnJlbG9hZCgnbG9naW4udmFsaWRhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudmFsaWRhdGluZz10cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIFNob3dTaW1wbGVUb2FzdC5zaG93KHJlc3BvbnNlLmRhdGEubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBTaG93U2ltcGxlVG9hc3Quc2hvdyhyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgICAgICAgICAgICAkc2NvcGUubG9naW5DaGVja2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAkc2NvcGUuJHBhcmVudC5sb2dpbkNoZWNraW5nPWZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICBTaXRlRXNzZW50aWFscy5yZXNwb25zQ2hlY2socmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICRzY29wZS5jYW5jZWxfZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgICRzY29wZS5mb3JnZXRfcGFzc3dvcmQ9ZnVuY3Rpb24oZXYpe1xyXG4gICAgICAgICAgICBpZighJHNjb3BlLnVzZXIpJHNjb3BlLnVzZXI9W107XHJcbiAgICAgICAgICAgICB2YXIgY29uZmlybSA9ICRtZERpYWxvZy5wcm9tcHQoKVxyXG4gICAgICAgICAgICAgICAgICAudGl0bGUoJ0VudGVyIHlvdXIgZW1haWwgYWRkcmVzcycpXHJcbiAgICAgICAgICAgICAgICAgIC50ZXh0Q29udGVudCgnQW4gZW1haWwgd2l0aCBhIHRva2VuICB3aWxsIGJlIHNlbnQgdG8geW91ciBlbWFpbCBhZGRyZXNzIGlmIHlvdSBhcmUgcmVnaXN0ZXJlZCB3aXRoIHVzLicpXHJcbiAgICAgICAgICAgICAgICAgIC5wbGFjZWhvbGRlcignRW1haWwnKVxyXG4gICAgICAgICAgICAgICAgICAuYXJpYUxhYmVsKCdlbWFpbCcpXHJcbiAgICAgICAgICAgICAgICAgIC5pbml0aWFsVmFsdWUoJHNjb3BlLnVzZXIuZW1haWwpXHJcbiAgICAgICAgICAgICAgICAgIC50YXJnZXRFdmVudChldilcclxuICAgICAgICAgICAgICAgICAgLm9rKCdTZW5kIGVtYWlsJylcclxuICAgICAgICAgICAgICAgICAgLmNhbmNlbCgnQ2FuY2VsJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgJG1kRGlhbG9nLnNob3coY29uZmlybSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnVzZXIuZW1haWw9cmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygkc2NvcGUudXNlci5lbWFpbCk7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5hc2tUb2tlbigkc2NvcGUudXNlci5lbWFpbCk7XHJcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkc2NvcGUudmFsaWRhdGU9ZnVuY3Rpb24ocGluKXtcclxuICAgICAgICAgICAgdmFyIGRhdGE9e307XHJcbiAgICAgICAgICAgIGRhdGEudG9rZW49cGluO1xyXG4gICAgICAgICAgICB2YXIgbmV4dD0nbG9naW4ucmVzZXRfcGFzc3dvcmQnO1xyXG4gICAgICAgICAgICAkc2NvcGUuJHBhcmVudC5sb2dpbkNoZWNraW5nPXRydWU7XHJcbiAgICAgICAgICAgICRodHRwKHt1cmw6J2FwaS9wYXNzd29yZC92YWxpZGF0ZScsZGF0YTpkYXRhLG1ldGhvZDonUE9TVCd9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKVxyXG4gICAgICAgICAgICAgICAgJHNjb3BlLiRwYXJlbnQubG9naW5DaGVja2luZz1mYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmKHJlc3BvbnNlLmRhdGEuc3VjY2Vzcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnZhbGlkYXRpbmc9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlc2V0aW5nX3Bhc3N3b3JkPXRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoJHN0YXRlLmN1cnJlbnQubmFtZT09bmV4dCkkc3RhdGUucmVsb2FkKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgJHN0YXRlLmdvKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS51c2VyLmlkPXJlc3BvbnNlLmRhdGEuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgU2hvd1NpbXBsZVRvYXN0LnNob3cocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIFNob3dTaW1wbGVUb2FzdC5zaG93KHJlc3BvbnNlLmRhdGEubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgICRzY29wZS5jaGFuZ2VQYXNzd29yZD1mdW5jdGlvbihwYXNzd29yZCxpZCl7XHJcbiAgICAgICAgICAgIHZhciBkYXRhPXt9O1xyXG4gICAgICAgICAgICBkYXRhLnVzZXJfaWQ9aWQ7XHJcbiAgICAgICAgICAgIGRhdGEucGFzc3dvcmQ9cGFzc3dvcmQ7XHJcbiAgICAgICAgICAgICRzY29wZS4kcGFyZW50LmxvZ2luQ2hlY2tpbmc9dHJ1ZTtcclxuICAgICAgICAgICAgJGh0dHAoe3VybDonYXBpL3Bhc3N3b3JkL3Jlc2V0JyxkYXRhOmRhdGEsbWV0aG9kOidQT1NUJ30pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLiRwYXJlbnQubG9naW5DaGVja2luZz1mYWxzZTtcclxuICAgICAgICAgICAgICAgJHNjb3BlLmNhbmNlbF9mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdsb2dpbicpO1xyXG4gICAgICAgICAgICAgICBTaG93U2ltcGxlVG9hc3Quc2hvdyhyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJlc291cmNlcy9hc3NldHMvanMvYW5ndWxhci5hdXRoZW50aWNhdGlvbi5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports) {

eval("angular.module('ticker', [])\r\n    .controller('tickerCtrl',function($scope, $timeout, $interval) {\r\n        $scope.boxes = [\r\n            {title: 'কুমিল্লা জিলা স্কুল',img:'/img/ticker/1.jpg',url:''},\r\n            {title: 'মর্ডান হাই স্কুল',img:'/img/ticker/2.jpg',url:''},\r\n            {title: 'রেসিডেন্সিয়াল স্কুল',img:'/img/ticker/3.jpg',url:''},\r\n            {title: 'পুলিশ লাইন হাই স্কুল',img:'/img/ticker/4.jpg',url:''},\r\n            {title: 'হোচ্চামিয়া হাই স্কুল',img:'/img/ticker/5.jpg',url:''},\r\n            {title: 'সার্ক চাইল্ড কিন্টার গার্তেন',img:'/img/ticker/6.jpg',url:''},\r\n            {title: 'নোটিশ',img:'/img/ticker/7.jpg',url:''},\r\n            {title: 'রিপোর্ট',img:'/img/ticker/8.jpg',url:''},\r\n            {title: 'Box 9',img:'/img/ticker/9.jpg',url:''},\r\n            {title: 'Box 10',img:'/img/ticker/10.jpg',url:''}\r\n        ];\r\n        $scope.moving = false;\r\n\r\n        $scope.moveLeft = function() {\r\n            $scope.moving = true;\r\n            $timeout($scope.switchFirst, 1000);\r\n        };\r\n        $scope.switchFirst = function() {\r\n            $scope.boxes.push($scope.boxes.shift());\r\n            $scope.moving = false;\r\n            $scope.$apply();\r\n        };\r\n\r\n        $interval($scope.moveLeft, 5000);\r\n\r\n    });//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL2FuZ3VsYXIudGlja2VyLmpzP2I2ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiYW5ndWxhci5tb2R1bGUoJ3RpY2tlcicsIFtdKVxyXG4gICAgLmNvbnRyb2xsZXIoJ3RpY2tlckN0cmwnLGZ1bmN0aW9uKCRzY29wZSwgJHRpbWVvdXQsICRpbnRlcnZhbCkge1xyXG4gICAgICAgICRzY29wZS5ib3hlcyA9IFtcclxuICAgICAgICAgICAge3RpdGxlOiAn4KaV4KeB4Kau4Ka/4Kay4KeN4Kay4Ka+IOCmnOCmv+CmsuCmviDgprjgp43gppXgp4HgprInLGltZzonL2ltZy90aWNrZXIvMS5qcGcnLHVybDonJ30sXHJcbiAgICAgICAgICAgIHt0aXRsZTogJ+CmruCmsOCnjeCmoeCmvuCmqCDgprngpr7gpocg4Ka44KeN4KaV4KeB4KayJyxpbWc6Jy9pbWcvdGlja2VyLzIuanBnJyx1cmw6Jyd9LFxyXG4gICAgICAgICAgICB7dGl0bGU6ICfgprDgp4fgprjgpr/gpqHgp4fgpqjgp43gprjgpr/gp5/gpr7gprIg4Ka44KeN4KaV4KeB4KayJyxpbWc6Jy9pbWcvdGlja2VyLzMuanBnJyx1cmw6Jyd9LFxyXG4gICAgICAgICAgICB7dGl0bGU6ICfgpqrgp4HgprLgpr/gprYg4Kay4Ka+4KaH4KaoIOCmueCmvuCmhyDgprjgp43gppXgp4HgprInLGltZzonL2ltZy90aWNrZXIvNC5qcGcnLHVybDonJ30sXHJcbiAgICAgICAgICAgIHt0aXRsZTogJ+CmueCni+CmmuCnjeCmmuCmvuCmruCmv+Cnn+CmviDgprngpr7gpocg4Ka44KeN4KaV4KeB4KayJyxpbWc6Jy9pbWcvdGlja2VyLzUuanBnJyx1cmw6Jyd9LFxyXG4gICAgICAgICAgICB7dGl0bGU6ICfgprjgpr7gprDgp43gppUg4Kaa4Ka+4KaH4Kay4KeN4KahIOCmleCmv+CmqOCnjeCmn+CmvuCmsCDgppfgpr7gprDgp43gpqTgp4fgpqgnLGltZzonL2ltZy90aWNrZXIvNi5qcGcnLHVybDonJ30sXHJcbiAgICAgICAgICAgIHt0aXRsZTogJ+CmqOCni+Cmn+Cmv+CmticsaW1nOicvaW1nL3RpY2tlci83LmpwZycsdXJsOicnfSxcclxuICAgICAgICAgICAge3RpdGxlOiAn4Kaw4Ka/4Kaq4KeL4Kaw4KeN4KafJyxpbWc6Jy9pbWcvdGlja2VyLzguanBnJyx1cmw6Jyd9LFxyXG4gICAgICAgICAgICB7dGl0bGU6ICdCb3ggOScsaW1nOicvaW1nL3RpY2tlci85LmpwZycsdXJsOicnfSxcclxuICAgICAgICAgICAge3RpdGxlOiAnQm94IDEwJyxpbWc6Jy9pbWcvdGlja2VyLzEwLmpwZycsdXJsOicnfVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgJHNjb3BlLm1vdmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAkc2NvcGUubW92ZUxlZnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJHNjb3BlLm1vdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICR0aW1lb3V0KCRzY29wZS5zd2l0Y2hGaXJzdCwgMTAwMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAkc2NvcGUuc3dpdGNoRmlyc3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJHNjb3BlLmJveGVzLnB1c2goJHNjb3BlLmJveGVzLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAkc2NvcGUubW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkaW50ZXJ2YWwoJHNjb3BlLm1vdmVMZWZ0LCA1MDAwKTtcclxuXHJcbiAgICB9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy9hbmd1bGFyLnRpY2tlci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * classie v1.0.1\r\n * class helper functions\r\n * from bonzo https://github.com/ded/bonzo\r\n * MIT license\r\n * \r\n * classie.has( elem, 'my-class' ) -> true/false\r\n * classie.add( elem, 'my-new-class' )\r\n * classie.remove( elem, 'my-unwanted-class' )\r\n * classie.toggle( elem, 'my-class' )\r\n */\r\n\r\n/*jshint browser: true, strict: true, undef: true, unused: true */\r\n/*global define: false, module: false */\r\n\r\n( function( window ) {\r\n\r\n'use strict';\r\n\r\n// class helper functions from bonzo https://github.com/ded/bonzo\r\n\r\nfunction classReg( className ) {\r\n  return new RegExp(\"(^|\\\\s+)\" + className + \"(\\\\s+|$)\");\r\n}\r\n\r\n// classList support for class management\r\n// altho to be fair, the api sucks because it won't accept multiple classes at once\r\nvar hasClass, addClass, removeClass;\r\n\r\nif ( 'classList' in document.documentElement ) {\r\n  hasClass = function( elem, c ) {\r\n    return elem.classList.contains( c );\r\n  };\r\n  addClass = function( elem, c ) {\r\n    elem.classList.add( c );\r\n  };\r\n  removeClass = function( elem, c ) {\r\n    elem.classList.remove( c );\r\n  };\r\n}\r\nelse {\r\n  hasClass = function( elem, c ) {\r\n    return classReg( c ).test( elem.className );\r\n  };\r\n  addClass = function( elem, c ) {\r\n    if ( !hasClass( elem, c ) ) {\r\n      elem.className = elem.className + ' ' + c;\r\n    }\r\n  };\r\n  removeClass = function( elem, c ) {\r\n    elem.className = elem.className.replace( classReg( c ), ' ' );\r\n  };\r\n}\r\n\r\nfunction toggleClass( elem, c ) {\r\n  var fn = hasClass( elem, c ) ? removeClass : addClass;\r\n  fn( elem, c );\r\n}\r\n\r\nvar classie = {\r\n  // full names\r\n  hasClass: hasClass,\r\n  addClass: addClass,\r\n  removeClass: removeClass,\r\n  toggleClass: toggleClass,\r\n  // short names\r\n  has: hasClass,\r\n  add: addClass,\r\n  remove: removeClass,\r\n  toggle: toggleClass\r\n};\r\n\r\n// transport\r\nif ( true ) {\r\n  // AMD\r\n  !(__WEBPACK_AMD_DEFINE_FACTORY__ = (classie), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n} else if ( typeof exports === 'object' ) {\r\n  // CommonJS\r\n  module.exports = classie;\r\n} else {\r\n  // browser global\r\n  window.classie = classie;\r\n}\r\n\r\n})( window );//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL2NsYXNzaWUuanM/Yzg1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogY2xhc3NpZSB2MS4wLjFcclxuICogY2xhc3MgaGVscGVyIGZ1bmN0aW9uc1xyXG4gKiBmcm9tIGJvbnpvIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvYm9uem9cclxuICogTUlUIGxpY2Vuc2VcclxuICogXHJcbiAqIGNsYXNzaWUuaGFzKCBlbGVtLCAnbXktY2xhc3MnICkgLT4gdHJ1ZS9mYWxzZVxyXG4gKiBjbGFzc2llLmFkZCggZWxlbSwgJ215LW5ldy1jbGFzcycgKVxyXG4gKiBjbGFzc2llLnJlbW92ZSggZWxlbSwgJ215LXVud2FudGVkLWNsYXNzJyApXHJcbiAqIGNsYXNzaWUudG9nZ2xlKCBlbGVtLCAnbXktY2xhc3MnIClcclxuICovXHJcblxyXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSAqL1xyXG5cclxuKCBmdW5jdGlvbiggd2luZG93ICkge1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gY2xhc3MgaGVscGVyIGZ1bmN0aW9ucyBmcm9tIGJvbnpvIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvYm9uem9cclxuXHJcbmZ1bmN0aW9uIGNsYXNzUmVnKCBjbGFzc05hbWUgKSB7XHJcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoXnxcXFxccyspXCIgKyBjbGFzc05hbWUgKyBcIihcXFxccyt8JClcIik7XHJcbn1cclxuXHJcbi8vIGNsYXNzTGlzdCBzdXBwb3J0IGZvciBjbGFzcyBtYW5hZ2VtZW50XHJcbi8vIGFsdGhvIHRvIGJlIGZhaXIsIHRoZSBhcGkgc3Vja3MgYmVjYXVzZSBpdCB3b24ndCBhY2NlcHQgbXVsdGlwbGUgY2xhc3NlcyBhdCBvbmNlXHJcbnZhciBoYXNDbGFzcywgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzO1xyXG5cclxuaWYgKCAnY2xhc3NMaXN0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKSB7XHJcbiAgaGFzQ2xhc3MgPSBmdW5jdGlvbiggZWxlbSwgYyApIHtcclxuICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyggYyApO1xyXG4gIH07XHJcbiAgYWRkQ2xhc3MgPSBmdW5jdGlvbiggZWxlbSwgYyApIHtcclxuICAgIGVsZW0uY2xhc3NMaXN0LmFkZCggYyApO1xyXG4gIH07XHJcbiAgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiggZWxlbSwgYyApIHtcclxuICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSggYyApO1xyXG4gIH07XHJcbn1cclxuZWxzZSB7XHJcbiAgaGFzQ2xhc3MgPSBmdW5jdGlvbiggZWxlbSwgYyApIHtcclxuICAgIHJldHVybiBjbGFzc1JlZyggYyApLnRlc3QoIGVsZW0uY2xhc3NOYW1lICk7XHJcbiAgfTtcclxuICBhZGRDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG4gICAgaWYgKCAhaGFzQ2xhc3MoIGVsZW0sIGMgKSApIHtcclxuICAgICAgZWxlbS5jbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZSArICcgJyArIGM7XHJcbiAgICB9XHJcbiAgfTtcclxuICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKCBlbGVtLCBjICkge1xyXG4gICAgZWxlbS5jbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5yZXBsYWNlKCBjbGFzc1JlZyggYyApLCAnICcgKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b2dnbGVDbGFzcyggZWxlbSwgYyApIHtcclxuICB2YXIgZm4gPSBoYXNDbGFzcyggZWxlbSwgYyApID8gcmVtb3ZlQ2xhc3MgOiBhZGRDbGFzcztcclxuICBmbiggZWxlbSwgYyApO1xyXG59XHJcblxyXG52YXIgY2xhc3NpZSA9IHtcclxuICAvLyBmdWxsIG5hbWVzXHJcbiAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxyXG4gIGFkZENsYXNzOiBhZGRDbGFzcyxcclxuICByZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXHJcbiAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxyXG4gIC8vIHNob3J0IG5hbWVzXHJcbiAgaGFzOiBoYXNDbGFzcyxcclxuICBhZGQ6IGFkZENsYXNzLFxyXG4gIHJlbW92ZTogcmVtb3ZlQ2xhc3MsXHJcbiAgdG9nZ2xlOiB0b2dnbGVDbGFzc1xyXG59O1xyXG5cclxuLy8gdHJhbnNwb3J0XHJcbmlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG4gIC8vIEFNRFxyXG4gIGRlZmluZSggY2xhc3NpZSApO1xyXG59IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XHJcbiAgLy8gQ29tbW9uSlNcclxuICBtb2R1bGUuZXhwb3J0cyA9IGNsYXNzaWU7XHJcbn0gZWxzZSB7XHJcbiAgLy8gYnJvd3NlciBnbG9iYWxcclxuICB3aW5kb3cuY2xhc3NpZSA9IGNsYXNzaWU7XHJcbn1cclxuXHJcbn0pKCB3aW5kb3cgKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy9jbGFzc2llLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports) {

eval("var components=angular.module('components',['ticker','simpleAngularTicker'])\r\n.directive('menu',function($interval,superServices,SiteEssentials,$rootScope){\r\n    return{\r\n        templateUrl:'getView/home.menu',\r\n        controller:'menuCtrl',\r\n        link:function(scope,elem,attr){\r\n\r\n\r\n            \r\n    \r\n            scope.drop=[];\r\n            scope.interval=5000;\r\n           \r\n            for(i=0;i<10;i++){\r\n                scope.drop[i]=false;\r\n            }\r\n\r\n            \r\n\r\n            scope.setCover=function(){\r\n                scope.index=0;\r\n                total=scope.cover.length;\r\n                \r\n\r\n                $interval(function(){\r\n                    \r\n                    index=scope.index;\r\n                    if(index==total-1){\r\n                        scope.index=0;\r\n                    }else{\r\n                        scope.index++;\r\n                    }\r\n\r\n                    scope.cover[index].active=true;\r\n\r\n                    if(index==0){\r\n                        scope.cover[total-1].active=false;\r\n                    }else{\r\n                        scope.cover[index-1].active=false;\r\n                    }\r\n                },scope.interval);\r\n\r\n                $rootScope.globals.siteLoaded=true;\r\n                scope.coverLoaded=true;\r\n            }\r\n\r\n            scope.setVisible=function(index){\r\n                scope.drop[index]=!scope.drop[index];\r\n                \r\n                angular.forEach(scope.drop,function(value,key){\r\n\r\n                    if(key!=index){\r\n                        scope.drop[key]=false;\r\n                    }\r\n                });\r\n            };\r\n            \r\n            var success=function(response){\r\n                if(response.data.success){\r\n\r\n                    console.log(response);\r\n                    scope.home_menu=SiteEssentials.generateMenu(response.data.menu);\r\n                    console.log(scope.home_menu);\r\n                    scope.cover=response.data.sliders;\r\n                    scope.cover[0].active=true;\r\n                    scope.setCover();\r\n                }\r\n            }\r\n            var failed=function(response){\r\n                console.log(repsonse);\r\n                SiteEssentials.responsCheck(response);\r\n            }\r\n           \r\n            superServices.loadHomeMenu(scope,success,failed);\r\n           \r\n            $('body').click(function(event){\r\n                \r\n                var classes=event.target.className.split(' ');\r\n                console.log(classes[0]);\r\n                if(classes[0]!='dropdown-toggle'){\r\n                      angular.forEach(scope.drop,function(value,key){\r\n                            scope.drop[key]=false;\r\n                       \r\n                    });  \r\n                }\r\n                \r\n            });\r\n        }\r\n    }\r\n}).directive('sidebar',function(){\r\n    return{\r\n        replace:true,\r\n        controller:'sidebarCtrl',\r\n        templateUrl:'getView/home.side-bar',\r\n        link:function(scope){\r\n\r\n        }\r\n    }\r\n}).directive('boxTicker',function(){\r\n    return{\r\n        templateUrl:'getView/home.ticker',\r\n        link:function(scope,elem,attr){\r\n            \r\n        }\r\n    }\r\n\r\n}).directive('newsTicker',function(){\r\n    return{\r\n        templateUrl:'getView/home.news-ticker',\r\n        scope:{\r\n            news:'=?'\r\n        },\r\n        link:function(scope){\r\n            console.log(scope.news);\r\n            scope.myTicker=scope.news;\r\n        }\r\n    }\r\n\r\n\r\n}).directive('backToTop',function($window,scrollMe){\r\n    return{\r\n        templateUrl:'getView/back-to-top',\r\n        link:function(scope,elem){\r\n            elem.fadeOut();\r\n\r\n            scope.goTop=function(){\r\n                scrollMe.goTop();\r\n            }\r\n\r\n            angular.element($window).bind('scroll', function(event) {\r\n                /* Act on the event */\r\n                menu=angular.element($('menu')).height();\r\n                offset=this.pageYOffset;\r\n                // console.log(menu)\r\n                maxheight=$(window).height();\r\n                if(offset>menu){\r\n                    elem.fadeIn();\r\n                    scope.$apply();\r\n                }else{\r\n                    elem.fadeOut();\r\n                }\r\n                // console.log(maxheight);\r\n            });\r\n        }\r\n    }\r\n}).directive('footer',function(){\r\n    return{\r\n        templateUrl:'getView/home.foot'\r\n    }\r\n}).directive('homePage',function(){\r\n    return{\r\n        templateUrl:'getView/home.homepage'\r\n    }\r\n}).directive('preload',function(){\r\n    return{\r\n\r\n        link:function(scope,elem,attr){\r\n            elem.ready(function(){\r\n                var src=attr.srcImage;\r\n                var type=attr.type;\r\n                if(type!='video')\r\n                {\r\n                    var img=new Image();\r\n                    img.src=src;\r\n\r\n                    $(img).on('load',function(){\r\n                        \r\n                      var  t_src='url(\"'+this.src+'\")';\r\n                      var  m_src=decodeURI(t_src);\r\n\r\n                   if(type=='background'){\r\n                     \r\n                     elem[0].style.backgroundImage=t_src;\r\n                     attr.src=this.src;\r\n                        \r\n                   }else{\r\n                    elem.find('img').attr({\r\n                        src: this.src,\r\n                    });\r\n                   }\r\n\r\n                        elem.find('.progress-loader').hide();\r\n                    });\r\n\r\n                    $(img).on('error',function(){\r\n                        if(type=='background'){\r\n                            elem[0].style.backgroundImage='url(https://dummyimage.com/600x400/ddd/1d1d1f&text=no+image+found)';\r\n                            attr.src='https://dummyimage.com/600x400/ddd/1d1d1f&text=no+image+found';\r\n                        }else{\r\n                            elem.find('img').attr({src:'https://dummyimage.com/600x400/ddd/1d1d1f&text=no+image+found'});\r\n                        }\r\n                        elem.find('.progress-loader').hide();\r\n                    })\r\n                    \r\n                \r\n                }else{\r\n                    console.log('video_found');\r\n                    elem.find('source').attr('src', src);\r\n                    elem.find('.progress-loader').hide();\r\n                }\r\n\r\n               })\r\n        }\r\n    }\r\n}).directive('loader',function(){\r\n    return{\r\n        templateUrl:'getView/template.loader',\r\n        scope:{\r\n            size:'=?',\r\n            color:'=?'\r\n        },\r\n        link:function(scope,elem,attr){\r\n            \r\n        }\r\n    }\r\n}).directive('searchModule',function(){\r\n    return{\r\n        link:function(scope,elem,attr){\r\n            scope.toggleSearch=function(){\r\n                scope.search_expand=!scope.search_expand;\r\n                if(scope.search_expand){\r\n                    elem.focus();\r\n                }else{\r\n                    scope.$parent.actions.search_query='';\r\n                }\r\n            }\r\n        }\r\n    }\r\n}).directive('addNewContent',function($state,$mdDialog){\r\n    return{\r\n        scope:{\r\n            url:'=?',\r\n            title:'=?',\r\n            submitFunction:'=?',\r\n            listContent:'=?'\r\n        },\r\n        link:function(scope,elem,attr){\r\n            scope.hide=function(){\r\n                $mdDialog.hide();\r\n            }\r\n\r\n        }\r\n    }\r\n})\r\n.directive('updateContent',function($state,$mdDialog){\r\n    return{\r\n        link:function(scope,elem,attr){\r\n\r\n        }\r\n    }\r\n})\r\n.directive('actions',function(){\r\n    return{\r\n        templateUrl:'getView/template.actions.action_all',\r\n        scope:{\r\n            title:'=?',\r\n            type:'='\r\n        },\r\n        controller:'actionsCtrl',\r\n        link:function(scope,elem,attr){\r\n\r\n        }\r\n    }\r\n})\r\n\r\n\r\n .directive('equalTo',function() {\r\n    return {\r\n        require: \"ngModel\",\r\n        scope: {\r\n            otherModelValue: \"=compareTo\"\r\n        },\r\n        link: function(scope, element, attributes, ngModel) {\r\n             \r\n            ngModel.$validators.compareTo = function(modelValue) {\r\n                return modelValue == scope.otherModelValue;\r\n            };\r\n \r\n            scope.$watch(\"otherModelValue\", function() {\r\n                ngModel.$validate();\r\n            });\r\n        }\r\n    };\r\n})\r\n\r\n\r\n.directive('ngGallery',function($q,$timeout,SiteEssentials){\r\n        return{\r\n            restrict:'EA',\r\n            templateUrl:'getView/template.gallery',\r\n            scope:{\r\n                'images':'=?',\r\n                'type':'@'\r\n            },\r\n            link:function(scope,elem,attr){\r\n                var keys_codes = {\r\n                    enter: 13,\r\n                    esc: 27,\r\n                    left: 37,\r\n                    right: 39\r\n                };\r\n                \r\n                \r\n                console.log(scope.images);\r\n                scope.gallery=scope.images;\r\n                var $body = $('body');\r\n                var $thumbwrapper = angular.element(elem[0].querySelectorAll('.ng-thumbnails-wrapper'));\r\n                var $thumbnails = angular.element(elem[0].querySelectorAll('.ng-thumbnails'));\r\n\r\n                scope.index = 0;\r\n                scope.opened = false;\r\n\r\n                scope.thumb_wrapper_width = 0;\r\n                scope.thumbs_width = 0;\r\n\r\n                scope.openGallery = function (i) {\r\n                    if (typeof i !== undefined) {\r\n                        scope.index = i;\r\n                        showImage(scope.index);\r\n                    }\r\n                    scope.opened = true;\r\n                    if (scope.hideOverflow) {\r\n                        $('body').css({overflow: 'hidden'});\r\n                    }\r\n\r\n                    $timeout(function () {\r\n                        var calculatedWidth = calculateThumbsWidth();\r\n                        scope.thumbs_width = calculatedWidth.width;\r\n                        //Add 1px, otherwise some browsers move the last image into a new line\r\n                        var thumbnailsWidth = calculatedWidth.width + 1;\r\n                        $thumbnails.css({width: thumbnailsWidth + 'px'});\r\n                        $thumbwrapper.css({width: calculatedWidth.visible_width + 'px'});\r\n                        smartScroll(scope.index);\r\n                    });\r\n                };\r\n                var loadImage = function (i) {\r\n                    var deferred = $q.defer();\r\n                    var image = new Image();\r\n\r\n                    image.onload = function () {\r\n                        scope.loading = false;\r\n                        if (typeof this.complete === false || this.naturalWidth === 0) {\r\n                            deferred.reject();\r\n                        }\r\n                        deferred.resolve(image);\r\n                    };\r\n\r\n                    image.onerror = function () {\r\n                        deferred.reject();\r\n                    };\r\n\r\n                    image.src = scope.gallery[i].file;\r\n                    scope.loading = true;\r\n                    console.log(image);\r\n\r\n                    return deferred.promise;\r\n                };\r\n\r\n                var showImage = function (i) {\r\n                    loadImage(scope.index).then(function (resp) {\r\n                        scope.img = resp.src;\r\n                        smartScroll(scope.index);\r\n                    });\r\n                    scope.description = scope.gallery[i].type+' created at '+SiteEssentials.getDate(scope.gallery[i].created_at) || '';\r\n                };\r\n                scope.showImageDownloadButton = function () {\r\n                    if (scope.gallery[scope.index] == null || scope.gallery[scope.index].downloadSrc == null) { return }\r\n                    var image = scope.gallery[scope.index];\r\n                    return angular.isDefined(image.downloadSrc) && 0 < image.downloadSrc.length;\r\n                };\r\n\r\n                scope.getImageDownloadSrc = function () {\r\n                    if (scope.gallery[scope.index] == null || scope.gallery[scope.index].downloadSrc == null) { return }\r\n                    return scope.gallery[scope.index].downloadSrc;\r\n                };\r\n\r\n                scope.changeImage = function (i) {\r\n                    scope.index = i;\r\n                    showImage(i);\r\n                };\r\n\r\n                scope.nextImage = function () {\r\n                    scope.index += 1;\r\n                    if (scope.index === scope.gallery.length) {\r\n                        scope.index = 0;\r\n                    }\r\n                    showImage(scope.index);\r\n                };\r\n\r\n                scope.prevImage = function () {\r\n                    scope.index -= 1;\r\n                    if (scope.index < 0) {\r\n                        scope.index = scope.gallery.length - 1;\r\n                    }\r\n                    showImage(scope.index);\r\n                };\r\n\r\n                scope.closeGallery = function () {\r\n                    scope.opened = false;\r\n                    if (scope.hideOverflow) {\r\n                        $('body').css({overflow: ''});\r\n                    }\r\n                };\r\n                scope.sortme=function(type){\r\n                    scope.imageType=type;\r\n                    console.log(type);\r\n                }\r\n\r\n                $body.bind('keydown', function (event) {\r\n                    if (!scope.opened) {\r\n                        return;\r\n                    }\r\n                    var which = event.which;\r\n                    if (which === keys_codes.esc) {\r\n                        scope.closeGallery();\r\n                    } else if (which === keys_codes.right || which === keys_codes.enter) {\r\n                        scope.nextImage();\r\n                    } else if (which === keys_codes.left) {\r\n                        scope.prevImage();\r\n                    }\r\n\r\n                    scope.$apply();\r\n                });\r\n\r\n                var calculateThumbsWidth = function () {\r\n                    var width = 0,\r\n                        visible_width = 0;\r\n                    angular.forEach($thumbnails.find('img'), function (thumb) {\r\n                        width += thumb.clientWidth;\r\n                        width += 10; // margin-right\r\n                        visible_width = thumb.clientWidth + 10;\r\n                    });\r\n                    return {\r\n                        width: width,\r\n                        visible_width: visible_width * scope.thumbsNum\r\n                    };\r\n                };\r\n\r\n                var smartScroll = function (index) {\r\n                    $timeout(function () {\r\n                        var len = scope.images.length,\r\n                            width = scope.thumbs_width,\r\n                            item_scroll = parseInt(width / len, 10),\r\n                            i = index + 1,\r\n                            s = Math.ceil(len / i);\r\n\r\n                        $thumbwrapper[0].scrollLeft = 0;\r\n                        $thumbwrapper[0].scrollLeft = i * item_scroll - (s * item_scroll);\r\n                    }, 100);\r\n                };\r\n                scope.galleryLoaded=true;\r\n\r\n            }\r\n        }\r\n    })\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncomponents.factory('scrollMe',function(){\r\n    func={};\r\n    func.goTop=function(){\r\n        angular.element('body,html').animate({ scrollTop: 0 }, \"slow\");\r\n    }\r\n    return func;\r\n})//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL2hvbWUuY29tcG9uZW50cy5qcz9hYjRjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21wb25lbnRzPWFuZ3VsYXIubW9kdWxlKCdjb21wb25lbnRzJyxbJ3RpY2tlcicsJ3NpbXBsZUFuZ3VsYXJUaWNrZXInXSlcclxuLmRpcmVjdGl2ZSgnbWVudScsZnVuY3Rpb24oJGludGVydmFsLHN1cGVyU2VydmljZXMsU2l0ZUVzc2VudGlhbHMsJHJvb3RTY29wZSl7XHJcbiAgICByZXR1cm57XHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvaG9tZS5tZW51JyxcclxuICAgICAgICBjb250cm9sbGVyOidtZW51Q3RybCcsXHJcbiAgICAgICAgbGluazpmdW5jdGlvbihzY29wZSxlbGVtLGF0dHIpe1xyXG5cclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgXHJcbiAgICAgICAgICAgIHNjb3BlLmRyb3A9W107XHJcbiAgICAgICAgICAgIHNjb3BlLmludGVydmFsPTUwMDA7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvcihpPTA7aTwxMDtpKyspe1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuZHJvcFtpXT1mYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICBzY29wZS5zZXRDb3Zlcj1mdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuaW5kZXg9MDtcclxuICAgICAgICAgICAgICAgIHRvdGFsPXNjb3BlLmNvdmVyLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgICRpbnRlcnZhbChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4PXNjb3BlLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4PT10b3RhbC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuaW5kZXg9MDtcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmNvdmVyW2luZGV4XS5hY3RpdmU9dHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXg9PTApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5jb3Zlclt0b3RhbC0xXS5hY3RpdmU9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmNvdmVyW2luZGV4LTFdLmFjdGl2ZT1mYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LHNjb3BlLmludGVydmFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmdsb2JhbHMuc2l0ZUxvYWRlZD10cnVlO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuY292ZXJMb2FkZWQ9dHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2NvcGUuc2V0VmlzaWJsZT1mdW5jdGlvbihpbmRleCl7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5kcm9wW2luZGV4XT0hc2NvcGUuZHJvcFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzY29wZS5kcm9wLGZ1bmN0aW9uKHZhbHVlLGtleSl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGtleSE9aW5kZXgpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5kcm9wW2tleV09ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgc3VjY2Vzcz1mdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICAgICAgICAgICBpZihyZXNwb25zZS5kYXRhLnN1Y2Nlc3Mpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuaG9tZV9tZW51PVNpdGVFc3NlbnRpYWxzLmdlbmVyYXRlTWVudShyZXNwb25zZS5kYXRhLm1lbnUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNjb3BlLmhvbWVfbWVudSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuY292ZXI9cmVzcG9uc2UuZGF0YS5zbGlkZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmNvdmVyWzBdLmFjdGl2ZT10cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnNldENvdmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZhaWxlZD1mdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXBzb25zZSk7XHJcbiAgICAgICAgICAgICAgICBTaXRlRXNzZW50aWFscy5yZXNwb25zQ2hlY2socmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHN1cGVyU2VydmljZXMubG9hZEhvbWVNZW51KHNjb3BlLHN1Y2Nlc3MsZmFpbGVkKTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgJCgnYm9keScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzZXM9ZXZlbnQudGFyZ2V0LmNsYXNzTmFtZS5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coY2xhc3Nlc1swXSk7XHJcbiAgICAgICAgICAgICAgICBpZihjbGFzc2VzWzBdIT0nZHJvcGRvd24tdG9nZ2xlJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2NvcGUuZHJvcCxmdW5jdGlvbih2YWx1ZSxrZXkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZHJvcFtrZXldPWZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH0pOyAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KS5kaXJlY3RpdmUoJ3NpZGViYXInLGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm57XHJcbiAgICAgICAgcmVwbGFjZTp0cnVlLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6J3NpZGViYXJDdHJsJyxcclxuICAgICAgICB0ZW1wbGF0ZVVybDonZ2V0Vmlldy9ob21lLnNpZGUtYmFyJyxcclxuICAgICAgICBsaW5rOmZ1bmN0aW9uKHNjb3BlKXtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KS5kaXJlY3RpdmUoJ2JveFRpY2tlcicsZnVuY3Rpb24oKXtcclxuICAgIHJldHVybntcclxuICAgICAgICB0ZW1wbGF0ZVVybDonZ2V0Vmlldy9ob21lLnRpY2tlcicsXHJcbiAgICAgICAgbGluazpmdW5jdGlvbihzY29wZSxlbGVtLGF0dHIpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KS5kaXJlY3RpdmUoJ25ld3NUaWNrZXInLGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm57XHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvaG9tZS5uZXdzLXRpY2tlcicsXHJcbiAgICAgICAgc2NvcGU6e1xyXG4gICAgICAgICAgICBuZXdzOic9PydcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6ZnVuY3Rpb24oc2NvcGUpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzY29wZS5uZXdzKTtcclxuICAgICAgICAgICAgc2NvcGUubXlUaWNrZXI9c2NvcGUubmV3cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxufSkuZGlyZWN0aXZlKCdiYWNrVG9Ub3AnLGZ1bmN0aW9uKCR3aW5kb3csc2Nyb2xsTWUpe1xyXG4gICAgcmV0dXJue1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOidnZXRWaWV3L2JhY2stdG8tdG9wJyxcclxuICAgICAgICBsaW5rOmZ1bmN0aW9uKHNjb3BlLGVsZW0pe1xyXG4gICAgICAgICAgICBlbGVtLmZhZGVPdXQoKTtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLmdvVG9wPWZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxNZS5nb1RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdykuYmluZCgnc2Nyb2xsJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8qIEFjdCBvbiB0aGUgZXZlbnQgKi9cclxuICAgICAgICAgICAgICAgIG1lbnU9YW5ndWxhci5lbGVtZW50KCQoJ21lbnUnKSkuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ9dGhpcy5wYWdlWU9mZnNldDtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG1lbnUpXHJcbiAgICAgICAgICAgICAgICBtYXhoZWlnaHQ9JCh3aW5kb3cpLmhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgaWYob2Zmc2V0Pm1lbnUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uZmFkZUluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtLmZhZGVPdXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG1heGhlaWdodCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSkuZGlyZWN0aXZlKCdmb290ZXInLGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm57XHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvaG9tZS5mb290J1xyXG4gICAgfVxyXG59KS5kaXJlY3RpdmUoJ2hvbWVQYWdlJyxmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJue1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOidnZXRWaWV3L2hvbWUuaG9tZXBhZ2UnXHJcbiAgICB9XHJcbn0pLmRpcmVjdGl2ZSgncHJlbG9hZCcsZnVuY3Rpb24oKXtcclxuICAgIHJldHVybntcclxuXHJcbiAgICAgICAgbGluazpmdW5jdGlvbihzY29wZSxlbGVtLGF0dHIpe1xyXG4gICAgICAgICAgICBlbGVtLnJlYWR5KGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3JjPWF0dHIuc3JjSW1hZ2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZT1hdHRyLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZih0eXBlIT0ndmlkZW8nKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWc9bmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLnNyYz1zcmM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICQoaW1nKS5vbignbG9hZCcsZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgIHRfc3JjPSd1cmwoXCInK3RoaXMuc3JjKydcIiknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyICBtX3NyYz1kZWNvZGVVUkkodF9zcmMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgIGlmKHR5cGU9PSdiYWNrZ3JvdW5kJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICBlbGVtWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZT10X3NyYztcclxuICAgICAgICAgICAgICAgICAgICAgYXR0ci5zcmM9dGhpcy5zcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5maW5kKCdpbWcnKS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiB0aGlzLnNyYyxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZmluZCgnLnByb2dyZXNzLWxvYWRlcicpLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJChpbWcpLm9uKCdlcnJvcicsZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZT09J2JhY2tncm91bmQnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bMF0uc3R5bGUuYmFja2dyb3VuZEltYWdlPSd1cmwoaHR0cHM6Ly9kdW1teWltYWdlLmNvbS82MDB4NDAwL2RkZC8xZDFkMWYmdGV4dD1ubytpbWFnZStmb3VuZCknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5zcmM9J2h0dHBzOi8vZHVtbXlpbWFnZS5jb20vNjAweDQwMC9kZGQvMWQxZDFmJnRleHQ9bm8raW1hZ2UrZm91bmQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZmluZCgnaW1nJykuYXR0cih7c3JjOidodHRwczovL2R1bW15aW1hZ2UuY29tLzYwMHg0MDAvZGRkLzFkMWQxZiZ0ZXh0PW5vK2ltYWdlK2ZvdW5kJ30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZmluZCgnLnByb2dyZXNzLWxvYWRlcicpLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndmlkZW9fZm91bmQnKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtLmZpbmQoJ3NvdXJjZScpLmF0dHIoJ3NyYycsIHNyYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5maW5kKCcucHJvZ3Jlc3MtbG9hZGVyJykuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pLmRpcmVjdGl2ZSgnbG9hZGVyJyxmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJue1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOidnZXRWaWV3L3RlbXBsYXRlLmxvYWRlcicsXHJcbiAgICAgICAgc2NvcGU6e1xyXG4gICAgICAgICAgICBzaXplOic9PycsXHJcbiAgICAgICAgICAgIGNvbG9yOic9PydcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6ZnVuY3Rpb24oc2NvcGUsZWxlbSxhdHRyKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KS5kaXJlY3RpdmUoJ3NlYXJjaE1vZHVsZScsZnVuY3Rpb24oKXtcclxuICAgIHJldHVybntcclxuICAgICAgICBsaW5rOmZ1bmN0aW9uKHNjb3BlLGVsZW0sYXR0cil7XHJcbiAgICAgICAgICAgIHNjb3BlLnRvZ2dsZVNlYXJjaD1mdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuc2VhcmNoX2V4cGFuZD0hc2NvcGUuc2VhcmNoX2V4cGFuZDtcclxuICAgICAgICAgICAgICAgIGlmKHNjb3BlLnNlYXJjaF9leHBhbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiRwYXJlbnQuYWN0aW9ucy5zZWFyY2hfcXVlcnk9Jyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pLmRpcmVjdGl2ZSgnYWRkTmV3Q29udGVudCcsZnVuY3Rpb24oJHN0YXRlLCRtZERpYWxvZyl7XHJcbiAgICByZXR1cm57XHJcbiAgICAgICAgc2NvcGU6e1xyXG4gICAgICAgICAgICB1cmw6Jz0/JyxcclxuICAgICAgICAgICAgdGl0bGU6Jz0/JyxcclxuICAgICAgICAgICAgc3VibWl0RnVuY3Rpb246Jz0/JyxcclxuICAgICAgICAgICAgbGlzdENvbnRlbnQ6Jz0/J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazpmdW5jdGlvbihzY29wZSxlbGVtLGF0dHIpe1xyXG4gICAgICAgICAgICBzY29wZS5oaWRlPWZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAkbWREaWFsb2cuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSlcclxuLmRpcmVjdGl2ZSgndXBkYXRlQ29udGVudCcsZnVuY3Rpb24oJHN0YXRlLCRtZERpYWxvZyl7XHJcbiAgICByZXR1cm57XHJcbiAgICAgICAgbGluazpmdW5jdGlvbihzY29wZSxlbGVtLGF0dHIpe1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pXHJcbi5kaXJlY3RpdmUoJ2FjdGlvbnMnLGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm57XHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvdGVtcGxhdGUuYWN0aW9ucy5hY3Rpb25fYWxsJyxcclxuICAgICAgICBzY29wZTp7XHJcbiAgICAgICAgICAgIHRpdGxlOic9PycsXHJcbiAgICAgICAgICAgIHR5cGU6Jz0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250cm9sbGVyOidhY3Rpb25zQ3RybCcsXHJcbiAgICAgICAgbGluazpmdW5jdGlvbihzY29wZSxlbGVtLGF0dHIpe1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pXHJcblxyXG5cclxuIC5kaXJlY3RpdmUoJ2VxdWFsVG8nLGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXF1aXJlOiBcIm5nTW9kZWxcIixcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBvdGhlck1vZGVsVmFsdWU6IFwiPWNvbXBhcmVUb1wiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cmlidXRlcywgbmdNb2RlbCkge1xyXG4gICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIG5nTW9kZWwuJHZhbGlkYXRvcnMuY29tcGFyZVRvID0gZnVuY3Rpb24obW9kZWxWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsVmFsdWUgPT0gc2NvcGUub3RoZXJNb2RlbFZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gXHJcbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaChcIm90aGVyTW9kZWxWYWx1ZVwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIG5nTW9kZWwuJHZhbGlkYXRlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pXHJcblxyXG5cclxuLmRpcmVjdGl2ZSgnbmdHYWxsZXJ5JyxmdW5jdGlvbigkcSwkdGltZW91dCxTaXRlRXNzZW50aWFscyl7XHJcbiAgICAgICAgcmV0dXJue1xyXG4gICAgICAgICAgICByZXN0cmljdDonRUEnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDonZ2V0Vmlldy90ZW1wbGF0ZS5nYWxsZXJ5JyxcclxuICAgICAgICAgICAgc2NvcGU6e1xyXG4gICAgICAgICAgICAgICAgJ2ltYWdlcyc6Jz0/JyxcclxuICAgICAgICAgICAgICAgICd0eXBlJzonQCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluazpmdW5jdGlvbihzY29wZSxlbGVtLGF0dHIpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXNfY29kZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50ZXI6IDEzLFxyXG4gICAgICAgICAgICAgICAgICAgIGVzYzogMjcsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMzcsXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDM5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNjb3BlLmltYWdlcyk7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5nYWxsZXJ5PXNjb3BlLmltYWdlcztcclxuICAgICAgICAgICAgICAgIHZhciAkYm9keSA9ICQoJ2JvZHknKTtcclxuICAgICAgICAgICAgICAgIHZhciAkdGh1bWJ3cmFwcGVyID0gYW5ndWxhci5lbGVtZW50KGVsZW1bMF0ucXVlcnlTZWxlY3RvckFsbCgnLm5nLXRodW1ibmFpbHMtd3JhcHBlcicpKTtcclxuICAgICAgICAgICAgICAgIHZhciAkdGh1bWJuYWlscyA9IGFuZ3VsYXIuZWxlbWVudChlbGVtWzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJy5uZy10aHVtYm5haWxzJykpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLmluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIHNjb3BlLm9wZW5lZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLnRodW1iX3dyYXBwZXJfd2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUudGh1bWJzX3dpZHRoID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZS5vcGVuR2FsbGVyeSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93SW1hZ2Uoc2NvcGUuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5vcGVuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5oaWRlT3ZlcmZsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnYm9keScpLmNzcyh7b3ZlcmZsb3c6ICdoaWRkZW4nfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkV2lkdGggPSBjYWxjdWxhdGVUaHVtYnNXaWR0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS50aHVtYnNfd2lkdGggPSBjYWxjdWxhdGVkV2lkdGgud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQWRkIDFweCwgb3RoZXJ3aXNlIHNvbWUgYnJvd3NlcnMgbW92ZSB0aGUgbGFzdCBpbWFnZSBpbnRvIGEgbmV3IGxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRodW1ibmFpbHNXaWR0aCA9IGNhbGN1bGF0ZWRXaWR0aC53aWR0aCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aHVtYm5haWxzLmNzcyh7d2lkdGg6IHRodW1ibmFpbHNXaWR0aCArICdweCd9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHRodW1id3JhcHBlci5jc3Moe3dpZHRoOiBjYWxjdWxhdGVkV2lkdGgudmlzaWJsZV93aWR0aCArICdweCd9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc21hcnRTY3JvbGwoc2NvcGUuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBsb2FkSW1hZ2UgPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29tcGxldGUgPT09IGZhbHNlIHx8IHRoaXMubmF0dXJhbFdpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGltYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBzY29wZS5nYWxsZXJ5W2ldLmZpbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW1hZ2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNob3dJbWFnZSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZEltYWdlKHNjb3BlLmluZGV4KS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmltZyA9IHJlc3Auc3JjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbWFydFNjcm9sbChzY29wZS5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZGVzY3JpcHRpb24gPSBzY29wZS5nYWxsZXJ5W2ldLnR5cGUrJyBjcmVhdGVkIGF0ICcrU2l0ZUVzc2VudGlhbHMuZ2V0RGF0ZShzY29wZS5nYWxsZXJ5W2ldLmNyZWF0ZWRfYXQpIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLnNob3dJbWFnZURvd25sb2FkQnV0dG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5nYWxsZXJ5W3Njb3BlLmluZGV4XSA9PSBudWxsIHx8IHNjb3BlLmdhbGxlcnlbc2NvcGUuaW5kZXhdLmRvd25sb2FkU3JjID09IG51bGwpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IHNjb3BlLmdhbGxlcnlbc2NvcGUuaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZChpbWFnZS5kb3dubG9hZFNyYykgJiYgMCA8IGltYWdlLmRvd25sb2FkU3JjLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUuZ2V0SW1hZ2VEb3dubG9hZFNyYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUuZ2FsbGVyeVtzY29wZS5pbmRleF0gPT0gbnVsbCB8fCBzY29wZS5nYWxsZXJ5W3Njb3BlLmluZGV4XS5kb3dubG9hZFNyYyA9PSBudWxsKSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZ2FsbGVyeVtzY29wZS5pbmRleF0uZG93bmxvYWRTcmM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLmNoYW5nZUltYWdlID0gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvd0ltYWdlKGkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZS5uZXh0SW1hZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuaW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUuaW5kZXggPT09IHNjb3BlLmdhbGxlcnkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvd0ltYWdlKHNjb3BlLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUucHJldkltYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmluZGV4IC09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5pbmRleCA9IHNjb3BlLmdhbGxlcnkubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvd0ltYWdlKHNjb3BlLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUuY2xvc2VHYWxsZXJ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm9wZW5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5oaWRlT3ZlcmZsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnYm9keScpLmNzcyh7b3ZlcmZsb3c6ICcnfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLnNvcnRtZT1mdW5jdGlvbih0eXBlKXtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5pbWFnZVR5cGU9dHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAkYm9keS5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZS5vcGVuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2hpY2ggPSBldmVudC53aGljaDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2hpY2ggPT09IGtleXNfY29kZXMuZXNjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmNsb3NlR2FsbGVyeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2hpY2ggPT09IGtleXNfY29kZXMucmlnaHQgfHwgd2hpY2ggPT09IGtleXNfY29kZXMuZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubmV4dEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aGljaCA9PT0ga2V5c19jb2Rlcy5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRlVGh1bWJzV2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZV93aWR0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCR0aHVtYm5haWxzLmZpbmQoJ2ltZycpLCBmdW5jdGlvbiAodGh1bWIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gdGh1bWIuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IDEwOyAvLyBtYXJnaW4tcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZV93aWR0aCA9IHRodW1iLmNsaWVudFdpZHRoICsgMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlX3dpZHRoOiB2aXNpYmxlX3dpZHRoICogc2NvcGUudGh1bWJzTnVtXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNtYXJ0U2Nyb2xsID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gc2NvcGUuaW1hZ2VzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc2NvcGUudGh1bWJzX3dpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbV9zY3JvbGwgPSBwYXJzZUludCh3aWR0aCAvIGxlbiwgMTApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGluZGV4ICsgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBNYXRoLmNlaWwobGVuIC8gaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGh1bWJ3cmFwcGVyWzBdLnNjcm9sbExlZnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGh1bWJ3cmFwcGVyWzBdLnNjcm9sbExlZnQgPSBpICogaXRlbV9zY3JvbGwgLSAocyAqIGl0ZW1fc2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLmdhbGxlcnlMb2FkZWQ9dHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbXBvbmVudHMuZmFjdG9yeSgnc2Nyb2xsTWUnLGZ1bmN0aW9uKCl7XHJcbiAgICBmdW5jPXt9O1xyXG4gICAgZnVuYy5nb1RvcD1mdW5jdGlvbigpe1xyXG4gICAgICAgIGFuZ3VsYXIuZWxlbWVudCgnYm9keSxodG1sJykuYW5pbWF0ZSh7IHNjcm9sbFRvcDogMCB9LCBcInNsb3dcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuYztcclxufSlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy9ob21lLmNvbXBvbmVudHMuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports) {

eval("var app=angular.module('mainHome',['components','ui.router','ngSanitize','ngFileUpload','angularTrix',\r\n    'ngCookies','ngMessages','super-controllers','Authentication','super-factory',\r\n            \"com.2fdevs.videogular\",\r\n            \"com.2fdevs.videogular.plugins.controls\"]);\r\n\r\n\r\n\r\napp.config(function($stateProvider,$interpolateProvider,$urlRouterProvider,$mdIconProvider){\r\n    \r\n    var home_state=[{\r\n        name:'home',\r\n        title:'Home',\r\n        templateUrl:'getView/home.homepage',\r\n        controller:'homeCtrl',\r\n        url:'/',\r\n        role:'all',\r\n        resolve:{\r\n            \r\n        }\r\n    },\r\n    {\r\n        controller:function($scope){\r\n            console.log($scope);\r\n        },\r\n        title:'Contact',\r\n        name:'contact',\r\n        role:'all',\r\n        templateUrl:'getView/home.contact',\r\n        url:'/contact'\r\n    },\r\n    {\r\n        name:'gallery',\r\n        title:'Galelry',\r\n        role:'all',\r\n        url:'/gallery/:type',\r\n        templateUrl:'getView/home.template.gallery',\r\n        controller:'galleryCtrl',\r\n        resolve:{\r\n            Gallery:function($stateParams,superServices){\r\n                return superServices.getContent('gallery','gallaries',$stateParams.type);\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'posts',\r\n        title:'Posts',\r\n        role:'all',\r\n        controller:'HomePostCtrl',\r\n        url:'/posts/:id',\r\n        templateUrl:'getView/home.template.single_post',\r\n        resolve:{\r\n            Post:function($stateParams,superServices){\r\n                \r\n                return superServices.getContent('post','posts',$stateParams.id);\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'employees',\r\n        title:'Employees',\r\n        controller:'employeeCtrl',\r\n        role:'all',\r\n        url:'/employees/:type',\r\n        templateUrl:'getView/home.template.employees',\r\n        resolve:{\r\n            Employees:function($stateParams,superServices){\r\n                return superServices.getContent('employee/category','employees',$stateParams.type);\r\n            }\r\n        }\r\n    },{\r\n        name:'institution',\r\n        title:'Institution',\r\n        role:'all',\r\n        controller:function($scope,Schools,$state,$stateParams){\r\n            $scope.type=$stateParams.type;\r\n            $scope.schools=Schools;\r\n        },\r\n        url:'/institution/:type',\r\n        templateUrl:'getView/home.template.schools',\r\n        resolve:{\r\n            Schools:function($stateParams,superServices){\r\n                return superServices.getContent('school/category','schools',$stateParams.type);\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'login',\r\n        title:'Login',\r\n        controller:'LoginController',\r\n        url:'/login',\r\n        role:'all',\r\n        templateUrl:'getView/home.login'\r\n    },\r\n    {\r\n        name:'login.validate',\r\n        title:'Validate',\r\n        url:'/validate',\r\n        role:'all',\r\n        controller:'LoginController',\r\n        templateUrl:'getView/home.template.validate_token',\r\n    },\r\n    {\r\n        name:'login.reset_password',\r\n        title:'Reset Password',\r\n        url:'/reset_password',\r\n        role:'all',\r\n        controller:'LoginController',\r\n        templateUrl:'getView/home.template.reset_password'\r\n    },\r\n    {\r\n        name:'profile',\r\n        controller:'profileCtrl',\r\n        url:'/profile',\r\n        role:'all',\r\n        title:'profile',\r\n        templateUrl:'getView/profile.dashboard',\r\n        resolve:{\r\n            Menu:function(superServices){\r\n                \r\n                return superServices.getMenu('profile');\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.reports',\r\n        title:'Reports',\r\n        controller:'reportCtrl',\r\n        url:'/reports',\r\n        role:'all',\r\n        templateUrl:'getView/profile.reports',\r\n        resolve:{\r\n            ReportMenu:function(superServices){\r\n               return superServices.getContent('questions/menu','menu');\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.reports.form',\r\n        title:'Reports',\r\n        url:'/:name',\r\n        role:'general_user',\r\n        controller:'formCtrl',\r\n        templateUrl:'getView/profile.reports.form_view',\r\n        resolve:{\r\n            Questions:function(superServices,$stateParams){\r\n                return superServices.getReportForm($stateParams);\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.notice',\r\n        title:'Notice',\r\n        controller:'noticeCtrl',\r\n        url:'/notice',\r\n        role:'all',\r\n        templateUrl:'getView/profile.notice',\r\n        resolve:{\r\n            Notice:function(superServices){\r\n                return superServices.getContent('notice','notices');\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.schools',\r\n        title:'Schools',\r\n        role:'admin',\r\n        controller:'schoolCtrl',\r\n        url:'/schools',\r\n        templateUrl:'getView/profile.schools',\r\n        resolve:{\r\n            Schools:function(superServices){\r\n                return superServices.getSchools();\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.settings',\r\n        title:'Settings',\r\n        controller:'innerContentCtrl',\r\n        url:'/settings',\r\n        templateUrl:'getView/profile.settings'\r\n    },\r\n    {\r\n        name:'profile.home_contents',\r\n        controller:'webContentsCtrl',\r\n        title:'Home Contents',\r\n        role:'admin',\r\n        url:'/home_contents',\r\n        templateUrl:'getView/profile.home_contents',\r\n        resolve:{\r\n            HomeContents:function(superServices){\r\n               \r\n                return superServices.getMenu('home_contents');\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.home_contents.posts',\r\n        controller:'contentCtrl',\r\n        url:'/posts',\r\n        title:'Posts',\r\n        role:'admin',\r\n        templateUrl:'getView/profile.home_contents.posts',\r\n        resolve:{\r\n            Contents:function(superServices){\r\n                return superServices.getContent('post','posts');\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.home_contents.links',\r\n        controller:'contentCtrl',\r\n        url:'/links',\r\n        role:'admin',\r\n        title:'Important Links',\r\n        templateUrl:'getView/profile.home_contents.links',\r\n        resolve:{\r\n            Contents:function(superServices){\r\n                return superServices.getContent('link','links');\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.home_contents.slider',\r\n        controller:'contentCtrl',\r\n        title:'Slider',\r\n        role:'admin',\r\n        url:'/slider',\r\n        templateUrl:'getView/profile.home_contents.slider',\r\n        resolve:{\r\n            Contents:function(superServices){\r\n                return superServices.getContent('slider','sliders');\r\n            }\r\n        }\r\n    },,\r\n    {\r\n        name:'profile.home_contents.gallery',\r\n        controller:'contentCtrl',\r\n        title:'Gallery',\r\n        url:'/gallery',\r\n        role:'admin',\r\n        templateUrl:'getView/profile.home_contents.gallery',\r\n        resolve:{\r\n            Contents:function(superServices){\r\n                return superServices.getContent('gallery','gallaries');\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.home_contents.employees',\r\n        controller:'contentCtrl',\r\n        title:'Employees',\r\n        url:'/employees',\r\n        role:'admin',\r\n        templateUrl:'getView/profile.home_contents.employees',\r\n        resolve:{\r\n            Contents:function(superServices){\r\n                return superServices.getContent('employee','employees');\r\n            }\r\n        }\r\n    },\r\n    {\r\n        name:'profile.class',\r\n        controller:'classCtrl',\r\n        title:'Classes',\r\n        url:'/class',\r\n        role:'general_user',\r\n        templateUrl:'getView/profile.class.class',\r\n        resolve:{\r\n            Classes:function(superServices){\r\n                return superServices.getClasses();\r\n            },\r\n            Attendance:function(superServices){\r\n                return superServices.getAttendance();\r\n            }\r\n        }\r\n    }\r\n    ]\r\n\r\n    $urlRouterProvider.otherwise('/');\r\n    \r\n    angular.forEach(home_state,function(value,key){\r\n        $stateProvider.state(value);\r\n    })\r\n    \r\n    $interpolateProvider.startSymbol('<%');\r\n    $interpolateProvider.endSymbol('%>');\r\n});\r\n\r\napp.controller('homeCtrl',  function($scope,$http,$location,$state,superServices){\r\n    // console.log($scope);\r\n    $scope.information=null;\r\n    $scope.homePage=null\r\n    superServices.loadHomepageContent($scope,'information');\r\n    $scope.$watch('information',function(value){\r\n        if(value){\r\n            $scope.homeLoaded=true;\r\n            $scope.homePage=value;\r\n        }\r\n    })\r\n});\r\n\r\napp.run(function($rootScope,$http,$cookieStore,$location,$stateParams\r\n    ,SiteEssentials,$state,$interval,superServices,ShowSimpleToast){\r\n   // keep user logged in after page refresh\r\n       \r\n        $rootScope.globals = $cookieStore.get('globals') || {};\r\n        \r\n        if ($rootScope.globals.currentUser) {\r\n            $http.defaults.headers.common['Authorization'] = 'Bearer ' + $rootScope.globals.currentUser.token; // jshint ignore:line\r\n\r\n        }\r\n\r\n        $rootScope.notification=$interval(function(){\r\n                if ($rootScope.globals.currentUser) \r\n                    { superServices.checkNotice(); }\r\n            },6000);\r\n        \r\n        $rootScope.nav={};\r\n        // console.log($rootScope);\r\n        \r\n        $rootScope.$on('$stateChangeStart', function (event, toState) {\r\n            \r\n               SiteEssentials.goTop();\r\n\r\n                // console.log(toState);\r\n                var state=toState.name.split('.');\r\n                $rootScope.data=[];\r\n                $rootScope.site=[];\r\n                $rootScope.nav.state=state;\r\n                $rootScope.nav.current_state=state[0];\r\n                $rootScope.nav.current_state_secendary=typeof state[1]!=undefined?state[1]:null;\r\n                $rootScope.nav.item=[];\r\n                $rootScope.school_data=[];\r\n                $rootScope.globals.current_state=$state;\r\n                $rootScope.nav.title=toState.title;\r\n                $rootScope.globals.title_bar=toState.title;\r\n                \r\n                if(!$rootScope.globals.currentUser&&state[0]=='profile'){\r\n                    $state.go('home');\r\n                    ShowSimpleToast.show('you must be lost ');\r\n               }else{\r\n                if($rootScope.globals.currentUser){\r\n                    role=$rootScope.globals.currentUser.role;\r\n                    if(toState.role!='all'&&toState.role!=role){\r\n                        $state.go('home');\r\n\r\n                    }\r\n                }\r\n               }\r\n                \r\n                if(state.length>1&&state[0]=='profile'){\r\n                    angular.element(document.getElementById('body')).addClass('no_scroll');\r\n                }else{\r\n                    angular.element(document.getElementById('body')).removeClass('no_scroll');\r\n                }\r\n\r\n               switch (toState.name) {\r\n                    case 'home':\r\n                        $rootScope.site.title='একাডেমিক সুপারভিশন';break;\r\n                    case 'contact':\r\n                        $rootScope.site.title='যোগাযোগ';break;\r\n                    case 'gallery':\r\n                        $rootScope.site.title='গ্যালারী';\r\n                    default:\r\n                        $rootScope.site.title= 'একাডেমিক সুপারভিশন';\r\n               }\r\n                \r\n                // console.log($rootScope.nav)\r\n            \r\n        });\r\n        \r\n        $rootScope.$on('$locationChangeStart', function (event, next, current){\r\n\r\n            var page=$location.path().split('/');\r\n            console.log(next);\r\n            \r\n            if(!$rootScope.globals.currentUser){\r\n                $rootScope.login_page=true;\r\n                $rootScope.body='login_body';\r\n                $rootScope.isLoggedin=false;\r\n                if(page[1]=='profile'){\r\n                    $location.path('/login');\r\n                }\r\n\r\n\r\n            }else{\r\n                if(page[1]=='login')\r\n                   {\r\n                    logout= confirm('Are you sure ? you will be logged out from this session...');\r\n                     if(!logout){ $location.path('/') }\r\n                   }\r\n\r\n                $rootScope.login_page=false;\r\n                $rootScope.isLoggedin=true;\r\n                $rootScope.body=\"home_body\"\r\n            }\r\n        });\r\n  \r\n})//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL2hvbWUuanM/NTcyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBwPWFuZ3VsYXIubW9kdWxlKCdtYWluSG9tZScsWydjb21wb25lbnRzJywndWkucm91dGVyJywnbmdTYW5pdGl6ZScsJ25nRmlsZVVwbG9hZCcsJ2FuZ3VsYXJUcml4JyxcclxuICAgICduZ0Nvb2tpZXMnLCduZ01lc3NhZ2VzJywnc3VwZXItY29udHJvbGxlcnMnLCdBdXRoZW50aWNhdGlvbicsJ3N1cGVyLWZhY3RvcnknLFxyXG4gICAgICAgICAgICBcImNvbS4yZmRldnMudmlkZW9ndWxhclwiLFxyXG4gICAgICAgICAgICBcImNvbS4yZmRldnMudmlkZW9ndWxhci5wbHVnaW5zLmNvbnRyb2xzXCJdKTtcclxuXHJcblxyXG5cclxuYXBwLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwkaW50ZXJwb2xhdGVQcm92aWRlciwkdXJsUm91dGVyUHJvdmlkZXIsJG1kSWNvblByb3ZpZGVyKXtcclxuICAgIFxyXG4gICAgdmFyIGhvbWVfc3RhdGU9W3tcclxuICAgICAgICBuYW1lOidob21lJyxcclxuICAgICAgICB0aXRsZTonSG9tZScsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvaG9tZS5ob21lcGFnZScsXHJcbiAgICAgICAgY29udHJvbGxlcjonaG9tZUN0cmwnLFxyXG4gICAgICAgIHVybDonLycsXHJcbiAgICAgICAgcm9sZTonYWxsJyxcclxuICAgICAgICByZXNvbHZlOntcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBjb250cm9sbGVyOmZ1bmN0aW9uKCRzY29wZSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCRzY29wZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aXRsZTonQ29udGFjdCcsXHJcbiAgICAgICAgbmFtZTonY29udGFjdCcsXHJcbiAgICAgICAgcm9sZTonYWxsJyxcclxuICAgICAgICB0ZW1wbGF0ZVVybDonZ2V0Vmlldy9ob21lLmNvbnRhY3QnLFxyXG4gICAgICAgIHVybDonL2NvbnRhY3QnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6J2dhbGxlcnknLFxyXG4gICAgICAgIHRpdGxlOidHYWxlbHJ5JyxcclxuICAgICAgICByb2xlOidhbGwnLFxyXG4gICAgICAgIHVybDonL2dhbGxlcnkvOnR5cGUnLFxyXG4gICAgICAgIHRlbXBsYXRlVXJsOidnZXRWaWV3L2hvbWUudGVtcGxhdGUuZ2FsbGVyeScsXHJcbiAgICAgICAgY29udHJvbGxlcjonZ2FsbGVyeUN0cmwnLFxyXG4gICAgICAgIHJlc29sdmU6e1xyXG4gICAgICAgICAgICBHYWxsZXJ5OmZ1bmN0aW9uKCRzdGF0ZVBhcmFtcyxzdXBlclNlcnZpY2VzKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlclNlcnZpY2VzLmdldENvbnRlbnQoJ2dhbGxlcnknLCdnYWxsYXJpZXMnLCRzdGF0ZVBhcmFtcy50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZToncG9zdHMnLFxyXG4gICAgICAgIHRpdGxlOidQb3N0cycsXHJcbiAgICAgICAgcm9sZTonYWxsJyxcclxuICAgICAgICBjb250cm9sbGVyOidIb21lUG9zdEN0cmwnLFxyXG4gICAgICAgIHVybDonL3Bvc3RzLzppZCcsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvaG9tZS50ZW1wbGF0ZS5zaW5nbGVfcG9zdCcsXHJcbiAgICAgICAgcmVzb2x2ZTp7XHJcbiAgICAgICAgICAgIFBvc3Q6ZnVuY3Rpb24oJHN0YXRlUGFyYW1zLHN1cGVyU2VydmljZXMpe1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXJTZXJ2aWNlcy5nZXRDb250ZW50KCdwb3N0JywncG9zdHMnLCRzdGF0ZVBhcmFtcy5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6J2VtcGxveWVlcycsXHJcbiAgICAgICAgdGl0bGU6J0VtcGxveWVlcycsXHJcbiAgICAgICAgY29udHJvbGxlcjonZW1wbG95ZWVDdHJsJyxcclxuICAgICAgICByb2xlOidhbGwnLFxyXG4gICAgICAgIHVybDonL2VtcGxveWVlcy86dHlwZScsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvaG9tZS50ZW1wbGF0ZS5lbXBsb3llZXMnLFxyXG4gICAgICAgIHJlc29sdmU6e1xyXG4gICAgICAgICAgICBFbXBsb3llZXM6ZnVuY3Rpb24oJHN0YXRlUGFyYW1zLHN1cGVyU2VydmljZXMpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyU2VydmljZXMuZ2V0Q29udGVudCgnZW1wbG95ZWUvY2F0ZWdvcnknLCdlbXBsb3llZXMnLCRzdGF0ZVBhcmFtcy50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0se1xyXG4gICAgICAgIG5hbWU6J2luc3RpdHV0aW9uJyxcclxuICAgICAgICB0aXRsZTonSW5zdGl0dXRpb24nLFxyXG4gICAgICAgIHJvbGU6J2FsbCcsXHJcbiAgICAgICAgY29udHJvbGxlcjpmdW5jdGlvbigkc2NvcGUsU2Nob29scywkc3RhdGUsJHN0YXRlUGFyYW1zKXtcclxuICAgICAgICAgICAgJHNjb3BlLnR5cGU9JHN0YXRlUGFyYW1zLnR5cGU7XHJcbiAgICAgICAgICAgICRzY29wZS5zY2hvb2xzPVNjaG9vbHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cmw6Jy9pbnN0aXR1dGlvbi86dHlwZScsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvaG9tZS50ZW1wbGF0ZS5zY2hvb2xzJyxcclxuICAgICAgICByZXNvbHZlOntcclxuICAgICAgICAgICAgU2Nob29sczpmdW5jdGlvbigkc3RhdGVQYXJhbXMsc3VwZXJTZXJ2aWNlcyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXJTZXJ2aWNlcy5nZXRDb250ZW50KCdzY2hvb2wvY2F0ZWdvcnknLCdzY2hvb2xzJywkc3RhdGVQYXJhbXMudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6J2xvZ2luJyxcclxuICAgICAgICB0aXRsZTonTG9naW4nLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6J0xvZ2luQ29udHJvbGxlcicsXHJcbiAgICAgICAgdXJsOicvbG9naW4nLFxyXG4gICAgICAgIHJvbGU6J2FsbCcsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvaG9tZS5sb2dpbidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTonbG9naW4udmFsaWRhdGUnLFxyXG4gICAgICAgIHRpdGxlOidWYWxpZGF0ZScsXHJcbiAgICAgICAgdXJsOicvdmFsaWRhdGUnLFxyXG4gICAgICAgIHJvbGU6J2FsbCcsXHJcbiAgICAgICAgY29udHJvbGxlcjonTG9naW5Db250cm9sbGVyJyxcclxuICAgICAgICB0ZW1wbGF0ZVVybDonZ2V0Vmlldy9ob21lLnRlbXBsYXRlLnZhbGlkYXRlX3Rva2VuJyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTonbG9naW4ucmVzZXRfcGFzc3dvcmQnLFxyXG4gICAgICAgIHRpdGxlOidSZXNldCBQYXNzd29yZCcsXHJcbiAgICAgICAgdXJsOicvcmVzZXRfcGFzc3dvcmQnLFxyXG4gICAgICAgIHJvbGU6J2FsbCcsXHJcbiAgICAgICAgY29udHJvbGxlcjonTG9naW5Db250cm9sbGVyJyxcclxuICAgICAgICB0ZW1wbGF0ZVVybDonZ2V0Vmlldy9ob21lLnRlbXBsYXRlLnJlc2V0X3Bhc3N3b3JkJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOidwcm9maWxlJyxcclxuICAgICAgICBjb250cm9sbGVyOidwcm9maWxlQ3RybCcsXHJcbiAgICAgICAgdXJsOicvcHJvZmlsZScsXHJcbiAgICAgICAgcm9sZTonYWxsJyxcclxuICAgICAgICB0aXRsZToncHJvZmlsZScsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvcHJvZmlsZS5kYXNoYm9hcmQnLFxyXG4gICAgICAgIHJlc29sdmU6e1xyXG4gICAgICAgICAgICBNZW51OmZ1bmN0aW9uKHN1cGVyU2VydmljZXMpe1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXJTZXJ2aWNlcy5nZXRNZW51KCdwcm9maWxlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6J3Byb2ZpbGUucmVwb3J0cycsXHJcbiAgICAgICAgdGl0bGU6J1JlcG9ydHMnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6J3JlcG9ydEN0cmwnLFxyXG4gICAgICAgIHVybDonL3JlcG9ydHMnLFxyXG4gICAgICAgIHJvbGU6J2FsbCcsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvcHJvZmlsZS5yZXBvcnRzJyxcclxuICAgICAgICByZXNvbHZlOntcclxuICAgICAgICAgICAgUmVwb3J0TWVudTpmdW5jdGlvbihzdXBlclNlcnZpY2VzKXtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyU2VydmljZXMuZ2V0Q29udGVudCgncXVlc3Rpb25zL21lbnUnLCdtZW51Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6J3Byb2ZpbGUucmVwb3J0cy5mb3JtJyxcclxuICAgICAgICB0aXRsZTonUmVwb3J0cycsXHJcbiAgICAgICAgdXJsOicvOm5hbWUnLFxyXG4gICAgICAgIHJvbGU6J2dlbmVyYWxfdXNlcicsXHJcbiAgICAgICAgY29udHJvbGxlcjonZm9ybUN0cmwnLFxyXG4gICAgICAgIHRlbXBsYXRlVXJsOidnZXRWaWV3L3Byb2ZpbGUucmVwb3J0cy5mb3JtX3ZpZXcnLFxyXG4gICAgICAgIHJlc29sdmU6e1xyXG4gICAgICAgICAgICBRdWVzdGlvbnM6ZnVuY3Rpb24oc3VwZXJTZXJ2aWNlcywkc3RhdGVQYXJhbXMpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyU2VydmljZXMuZ2V0UmVwb3J0Rm9ybSgkc3RhdGVQYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOidwcm9maWxlLm5vdGljZScsXHJcbiAgICAgICAgdGl0bGU6J05vdGljZScsXHJcbiAgICAgICAgY29udHJvbGxlcjonbm90aWNlQ3RybCcsXHJcbiAgICAgICAgdXJsOicvbm90aWNlJyxcclxuICAgICAgICByb2xlOidhbGwnLFxyXG4gICAgICAgIHRlbXBsYXRlVXJsOidnZXRWaWV3L3Byb2ZpbGUubm90aWNlJyxcclxuICAgICAgICByZXNvbHZlOntcclxuICAgICAgICAgICAgTm90aWNlOmZ1bmN0aW9uKHN1cGVyU2VydmljZXMpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyU2VydmljZXMuZ2V0Q29udGVudCgnbm90aWNlJywnbm90aWNlcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOidwcm9maWxlLnNjaG9vbHMnLFxyXG4gICAgICAgIHRpdGxlOidTY2hvb2xzJyxcclxuICAgICAgICByb2xlOidhZG1pbicsXHJcbiAgICAgICAgY29udHJvbGxlcjonc2Nob29sQ3RybCcsXHJcbiAgICAgICAgdXJsOicvc2Nob29scycsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvcHJvZmlsZS5zY2hvb2xzJyxcclxuICAgICAgICByZXNvbHZlOntcclxuICAgICAgICAgICAgU2Nob29sczpmdW5jdGlvbihzdXBlclNlcnZpY2VzKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlclNlcnZpY2VzLmdldFNjaG9vbHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZToncHJvZmlsZS5zZXR0aW5ncycsXHJcbiAgICAgICAgdGl0bGU6J1NldHRpbmdzJyxcclxuICAgICAgICBjb250cm9sbGVyOidpbm5lckNvbnRlbnRDdHJsJyxcclxuICAgICAgICB1cmw6Jy9zZXR0aW5ncycsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvcHJvZmlsZS5zZXR0aW5ncydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZToncHJvZmlsZS5ob21lX2NvbnRlbnRzJyxcclxuICAgICAgICBjb250cm9sbGVyOid3ZWJDb250ZW50c0N0cmwnLFxyXG4gICAgICAgIHRpdGxlOidIb21lIENvbnRlbnRzJyxcclxuICAgICAgICByb2xlOidhZG1pbicsXHJcbiAgICAgICAgdXJsOicvaG9tZV9jb250ZW50cycsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvcHJvZmlsZS5ob21lX2NvbnRlbnRzJyxcclxuICAgICAgICByZXNvbHZlOntcclxuICAgICAgICAgICAgSG9tZUNvbnRlbnRzOmZ1bmN0aW9uKHN1cGVyU2VydmljZXMpe1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlclNlcnZpY2VzLmdldE1lbnUoJ2hvbWVfY29udGVudHMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZToncHJvZmlsZS5ob21lX2NvbnRlbnRzLnBvc3RzJyxcclxuICAgICAgICBjb250cm9sbGVyOidjb250ZW50Q3RybCcsXHJcbiAgICAgICAgdXJsOicvcG9zdHMnLFxyXG4gICAgICAgIHRpdGxlOidQb3N0cycsXHJcbiAgICAgICAgcm9sZTonYWRtaW4nLFxyXG4gICAgICAgIHRlbXBsYXRlVXJsOidnZXRWaWV3L3Byb2ZpbGUuaG9tZV9jb250ZW50cy5wb3N0cycsXHJcbiAgICAgICAgcmVzb2x2ZTp7XHJcbiAgICAgICAgICAgIENvbnRlbnRzOmZ1bmN0aW9uKHN1cGVyU2VydmljZXMpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyU2VydmljZXMuZ2V0Q29udGVudCgncG9zdCcsJ3Bvc3RzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6J3Byb2ZpbGUuaG9tZV9jb250ZW50cy5saW5rcycsXHJcbiAgICAgICAgY29udHJvbGxlcjonY29udGVudEN0cmwnLFxyXG4gICAgICAgIHVybDonL2xpbmtzJyxcclxuICAgICAgICByb2xlOidhZG1pbicsXHJcbiAgICAgICAgdGl0bGU6J0ltcG9ydGFudCBMaW5rcycsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvcHJvZmlsZS5ob21lX2NvbnRlbnRzLmxpbmtzJyxcclxuICAgICAgICByZXNvbHZlOntcclxuICAgICAgICAgICAgQ29udGVudHM6ZnVuY3Rpb24oc3VwZXJTZXJ2aWNlcyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXJTZXJ2aWNlcy5nZXRDb250ZW50KCdsaW5rJywnbGlua3MnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZToncHJvZmlsZS5ob21lX2NvbnRlbnRzLnNsaWRlcicsXHJcbiAgICAgICAgY29udHJvbGxlcjonY29udGVudEN0cmwnLFxyXG4gICAgICAgIHRpdGxlOidTbGlkZXInLFxyXG4gICAgICAgIHJvbGU6J2FkbWluJyxcclxuICAgICAgICB1cmw6Jy9zbGlkZXInLFxyXG4gICAgICAgIHRlbXBsYXRlVXJsOidnZXRWaWV3L3Byb2ZpbGUuaG9tZV9jb250ZW50cy5zbGlkZXInLFxyXG4gICAgICAgIHJlc29sdmU6e1xyXG4gICAgICAgICAgICBDb250ZW50czpmdW5jdGlvbihzdXBlclNlcnZpY2VzKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlclNlcnZpY2VzLmdldENvbnRlbnQoJ3NsaWRlcicsJ3NsaWRlcnMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sLFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6J3Byb2ZpbGUuaG9tZV9jb250ZW50cy5nYWxsZXJ5JyxcclxuICAgICAgICBjb250cm9sbGVyOidjb250ZW50Q3RybCcsXHJcbiAgICAgICAgdGl0bGU6J0dhbGxlcnknLFxyXG4gICAgICAgIHVybDonL2dhbGxlcnknLFxyXG4gICAgICAgIHJvbGU6J2FkbWluJyxcclxuICAgICAgICB0ZW1wbGF0ZVVybDonZ2V0Vmlldy9wcm9maWxlLmhvbWVfY29udGVudHMuZ2FsbGVyeScsXHJcbiAgICAgICAgcmVzb2x2ZTp7XHJcbiAgICAgICAgICAgIENvbnRlbnRzOmZ1bmN0aW9uKHN1cGVyU2VydmljZXMpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyU2VydmljZXMuZ2V0Q29udGVudCgnZ2FsbGVyeScsJ2dhbGxhcmllcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOidwcm9maWxlLmhvbWVfY29udGVudHMuZW1wbG95ZWVzJyxcclxuICAgICAgICBjb250cm9sbGVyOidjb250ZW50Q3RybCcsXHJcbiAgICAgICAgdGl0bGU6J0VtcGxveWVlcycsXHJcbiAgICAgICAgdXJsOicvZW1wbG95ZWVzJyxcclxuICAgICAgICByb2xlOidhZG1pbicsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvcHJvZmlsZS5ob21lX2NvbnRlbnRzLmVtcGxveWVlcycsXHJcbiAgICAgICAgcmVzb2x2ZTp7XHJcbiAgICAgICAgICAgIENvbnRlbnRzOmZ1bmN0aW9uKHN1cGVyU2VydmljZXMpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyU2VydmljZXMuZ2V0Q29udGVudCgnZW1wbG95ZWUnLCdlbXBsb3llZXMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZToncHJvZmlsZS5jbGFzcycsXHJcbiAgICAgICAgY29udHJvbGxlcjonY2xhc3NDdHJsJyxcclxuICAgICAgICB0aXRsZTonQ2xhc3NlcycsXHJcbiAgICAgICAgdXJsOicvY2xhc3MnLFxyXG4gICAgICAgIHJvbGU6J2dlbmVyYWxfdXNlcicsXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6J2dldFZpZXcvcHJvZmlsZS5jbGFzcy5jbGFzcycsXHJcbiAgICAgICAgcmVzb2x2ZTp7XHJcbiAgICAgICAgICAgIENsYXNzZXM6ZnVuY3Rpb24oc3VwZXJTZXJ2aWNlcyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXJTZXJ2aWNlcy5nZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIEF0dGVuZGFuY2U6ZnVuY3Rpb24oc3VwZXJTZXJ2aWNlcyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXJTZXJ2aWNlcy5nZXRBdHRlbmRhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBdXHJcblxyXG4gICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnLycpO1xyXG4gICAgXHJcbiAgICBhbmd1bGFyLmZvckVhY2goaG9tZV9zdGF0ZSxmdW5jdGlvbih2YWx1ZSxrZXkpe1xyXG4gICAgICAgICRzdGF0ZVByb3ZpZGVyLnN0YXRlKHZhbHVlKTtcclxuICAgIH0pXHJcbiAgICBcclxuICAgICRpbnRlcnBvbGF0ZVByb3ZpZGVyLnN0YXJ0U3ltYm9sKCc8JScpO1xyXG4gICAgJGludGVycG9sYXRlUHJvdmlkZXIuZW5kU3ltYm9sKCclPicpO1xyXG59KTtcclxuXHJcbmFwcC5jb250cm9sbGVyKCdob21lQ3RybCcsICBmdW5jdGlvbigkc2NvcGUsJGh0dHAsJGxvY2F0aW9uLCRzdGF0ZSxzdXBlclNlcnZpY2VzKXtcclxuICAgIC8vIGNvbnNvbGUubG9nKCRzY29wZSk7XHJcbiAgICAkc2NvcGUuaW5mb3JtYXRpb249bnVsbDtcclxuICAgICRzY29wZS5ob21lUGFnZT1udWxsXHJcbiAgICBzdXBlclNlcnZpY2VzLmxvYWRIb21lcGFnZUNvbnRlbnQoJHNjb3BlLCdpbmZvcm1hdGlvbicpO1xyXG4gICAgJHNjb3BlLiR3YXRjaCgnaW5mb3JtYXRpb24nLGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICBpZih2YWx1ZSl7XHJcbiAgICAgICAgICAgICRzY29wZS5ob21lTG9hZGVkPXRydWU7XHJcbiAgICAgICAgICAgICRzY29wZS5ob21lUGFnZT12YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59KTtcclxuXHJcbmFwcC5ydW4oZnVuY3Rpb24oJHJvb3RTY29wZSwkaHR0cCwkY29va2llU3RvcmUsJGxvY2F0aW9uLCRzdGF0ZVBhcmFtc1xyXG4gICAgLFNpdGVFc3NlbnRpYWxzLCRzdGF0ZSwkaW50ZXJ2YWwsc3VwZXJTZXJ2aWNlcyxTaG93U2ltcGxlVG9hc3Qpe1xyXG4gICAvLyBrZWVwIHVzZXIgbG9nZ2VkIGluIGFmdGVyIHBhZ2UgcmVmcmVzaFxyXG4gICAgICAgXHJcbiAgICAgICAgJHJvb3RTY29wZS5nbG9iYWxzID0gJGNvb2tpZVN0b3JlLmdldCgnZ2xvYmFscycpIHx8IHt9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICgkcm9vdFNjb3BlLmdsb2JhbHMuY3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgJGh0dHAuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ0F1dGhvcml6YXRpb24nXSA9ICdCZWFyZXIgJyArICRyb290U2NvcGUuZ2xvYmFscy5jdXJyZW50VXNlci50b2tlbjsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJHJvb3RTY29wZS5ub3RpZmljYXRpb249JGludGVydmFsKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS5nbG9iYWxzLmN1cnJlbnRVc2VyKSBcclxuICAgICAgICAgICAgICAgICAgICBzdXBlclNlcnZpY2VzLmNoZWNrTm90aWNlKCk7XHJcbiAgICAgICAgICAgIH0sNjAwMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgJHJvb3RTY29wZS5uYXY9e307XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJHJvb3RTY29wZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgJHJvb3RTY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50LCB0b1N0YXRlKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBTaXRlRXNzZW50aWFscy5nb1RvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRvU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlPXRvU3RhdGUubmFtZS5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5kYXRhPVtdO1xyXG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaXRlPVtdO1xyXG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5uYXYuc3RhdGU9c3RhdGU7XHJcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLm5hdi5jdXJyZW50X3N0YXRlPXN0YXRlWzBdO1xyXG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5uYXYuY3VycmVudF9zdGF0ZV9zZWNlbmRhcnk9dHlwZW9mIHN0YXRlWzFdIT11bmRlZmluZWQ/c3RhdGVbMV06bnVsbDtcclxuICAgICAgICAgICAgICAgICRyb290U2NvcGUubmF2Lml0ZW09W107XHJcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNjaG9vbF9kYXRhPVtdO1xyXG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5nbG9iYWxzLmN1cnJlbnRfc3RhdGU9JHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5uYXYudGl0bGU9dG9TdGF0ZS50aXRsZTtcclxuICAgICAgICAgICAgICAgICRyb290U2NvcGUuZ2xvYmFscy50aXRsZV9iYXI9dG9TdGF0ZS50aXRsZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoISRyb290U2NvcGUuZ2xvYmFscy5jdXJyZW50VXNlciYmc3RhdGVbMF09PSdwcm9maWxlJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdob21lJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgU2hvd1NpbXBsZVRvYXN0LnNob3coJ3lvdSBtdXN0IGJlIGxvc3QgJyk7XHJcbiAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaWYoJHJvb3RTY29wZS5nbG9iYWxzLmN1cnJlbnRVc2VyKXtcclxuICAgICAgICAgICAgICAgICAgICByb2xlPSRyb290U2NvcGUuZ2xvYmFscy5jdXJyZW50VXNlci5yb2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRvU3RhdGUucm9sZSE9J2FsbCcmJnRvU3RhdGUucm9sZSE9cm9sZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnaG9tZScpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoc3RhdGUubGVuZ3RoPjEmJnN0YXRlWzBdPT0ncHJvZmlsZScpe1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9keScpKS5hZGRDbGFzcygnbm9fc2Nyb2xsJyk7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JvZHknKSkucmVtb3ZlQ2xhc3MoJ25vX3Njcm9sbCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgc3dpdGNoICh0b1N0YXRlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdob21lJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaXRlLnRpdGxlPSfgpo/gppXgpr7gpqHgp4fgpq7gpr/gppUg4Ka44KeB4Kaq4Ka+4Kaw4Kat4Ka/4Ka24KaoJzticmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250YWN0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaXRlLnRpdGxlPSfgpq/gp4vgppfgpr7gpq/gp4vgppcnO2JyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dhbGxlcnknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNpdGUudGl0bGU9J+Cml+CnjeCmr+CmvuCmsuCmvuCmsOCngCc7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaXRlLnRpdGxlPSAn4KaP4KaV4Ka+4Kah4KeH4Kau4Ka/4KaVIOCmuOCngeCmquCmvuCmsOCmreCmv+CmtuCmqCc7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJHJvb3RTY29wZS5uYXYpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgICRyb290U2NvcGUuJG9uKCckbG9jYXRpb25DaGFuZ2VTdGFydCcsIGZ1bmN0aW9uIChldmVudCwgbmV4dCwgY3VycmVudCl7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFnZT0kbG9jYXRpb24ucGF0aCgpLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5leHQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYoISRyb290U2NvcGUuZ2xvYmFscy5jdXJyZW50VXNlcil7XHJcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZ2luX3BhZ2U9dHJ1ZTtcclxuICAgICAgICAgICAgICAgICRyb290U2NvcGUuYm9keT0nbG9naW5fYm9keSc7XHJcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmlzTG9nZ2VkaW49ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZihwYWdlWzFdPT0ncHJvZmlsZScpe1xyXG4gICAgICAgICAgICAgICAgICAgICRsb2NhdGlvbi5wYXRoKCcvbG9naW4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKHBhZ2VbMV09PSdsb2dpbicpXHJcbiAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nb3V0PSBjb25maXJtKCdBcmUgeW91IHN1cmUgPyB5b3Ugd2lsbCBiZSBsb2dnZWQgb3V0IGZyb20gdGhpcyBzZXNzaW9uLi4uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKCFsb2dvdXQpJGxvY2F0aW9uLnBhdGgoJy8nKVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9naW5fcGFnZT1mYWxzZTtcclxuICAgICAgICAgICAgICAgICRyb290U2NvcGUuaXNMb2dnZWRpbj10cnVlO1xyXG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5ib2R5PVwiaG9tZV9ib2R5XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gIFxyXG59KVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL2hvbWUuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\r\n\r\nangular.module('super-controllers',[])\r\n\r\n\r\n.controller('menuCtrl',function($scope,$http,$location,$state,SiteEssentials,superServices,$rootScope){\r\n    $scope.menu=false;\r\n    \r\n    $scope.logout=function(){\r\n        superServices.logout();\r\n    }\r\n    $scope.$watch('coverLoaded',function(value){\r\n        if(value){\r\n            $rootScope.globals.siteLoaded=true;\r\n            console.log($rootScope);\r\n        }\r\n    })\r\n})\r\n.controller('sidebarCtrl',function($scope,SiteEssentials,superServices){\r\n    $scope.sidebarLoading=true;\r\n    var success=function(response){\r\n        $scope.sidebarLoading=false;\r\n        if(response.data.success){\r\n            $scope.sidebarLoading=false;\r\n            $scope.sidebar=response.data.sidebar;\r\n            $scope.bani=response.data.sidebar['বানী'];\r\n            $scope.khobor=response.data.sidebar['খবর'];\r\n            console.log($scope)\r\n        }\r\n    }\r\n    var failed=function(response){\r\n        $scope.sidebarLoading=false;\r\n        SiteEssentials.responsCheck(response);\r\n    }\r\n    superServices.loadSideBar($scope,success,failed);\r\n\r\n})\r\n.controller('employeeCtrl',function($scope,SiteEssentials,superServices,Employees,$stateParams){\r\n    $scope.employees=Employees;\r\n    $scope.type=$stateParams.type;\r\n\r\n\r\n})\r\n.controller('galleryCtrl', function($scope,Gallery,$stateParams,superServices,$sce){\r\n    $scope.gallery=Gallery;\r\n    $scope.type=$stateParams.type;\r\n    if($scope.type=='video'){\r\n        $scope.video_config=[];\r\n        angular.forEach($scope.gallery,function(value,key){\r\n            $scope.video_config[key]={\r\n                sources:[{src:$sce.trustAsResourceUrl(value.file),type:'video/mp4'}],\r\n                tracks: [\r\n                    {\r\n                        src: \"http://www.videogular.com/assets/subs/pale-blue-dot.vtt\",\r\n                        kind: \"subtitles\",\r\n                        srclang: \"en\",\r\n                        label: \"English\",\r\n                        default: \"\"\r\n                    }\r\n                ]\r\n            }\r\n            \r\n        })\r\n    }\r\n    $scope.videoLoad=true;\r\n\r\n})\r\n\r\n.controller('HomePostCtrl',function($scope,Post,SiteEssentials,$rootScope){\r\n    $scope.post=Post;\r\n    $rootScope.site.title=$scope.post!=null?$scope.post.type:$rootScope.site.title;\r\n    \r\n    $scope.getDate=function(date){\r\n        return SiteEssentials.getDate(date);\r\n    }\r\n\r\n})\r\n\r\n.controller('profileCtrl',function($scope,$rootScope,$http,SiteEssentials,superServices,Menu,$state){\r\n    // console.log($rootScope.nav)\r\n    $scope.menu=Menu;\r\n    \r\n    $scope.open=function(item,index){\r\n        $rootScope.nav.profile_index=index;\r\n        $rootScope.nav.item=item;\r\n        $rootScope.nav.loading=true;\r\n        $state.go(item.name);\r\n    }\r\n    $scope.goback=function(){\r\n        var states=$rootScope.nav.state;\r\n        var back_state=states[0];\r\n\r\n        for(var i=1;i<states.length-1;i++){\r\n            back_state+='.'+states[i];\r\n        }\r\n        if(back_state!=''){\r\n            $state.go(back_state);\r\n        }else{\r\n            $state.go($rootScope.nav.current_state);\r\n        }\r\n    }\r\n  $scope.createactions=function(){\r\n        $scope.actions=[];\r\n        $scope.actions.search_query='';\r\n        console.log($scope.actions)\r\n    }\r\n\r\n})\r\n\r\n.controller('innerContentCtrl',function($scope,$http,SiteEssentials,superServices,$rootScope,$state,ShowSimpleToast,Menu){\r\n    // add expanding element/placeholder \r\n     var i=-1;\r\n     $scope.createactions=function(){\r\n        $scope.actions=[];\r\n        $scope.search_query=[];\r\n        console.log($scope.actions)\r\n     }\r\n     $rootScope.nav.item=Menu.find(function(item){\r\n        i++;\r\n        return item.name==$state.current.name\r\n     });\r\n     $rootScope.nav.profile_index=i;\r\n})\r\n\r\n.controller('schoolCtrl',function($scope,SiteEssentials,superServices,\r\n    $rootScope,ShowSimpleToast,Schools,Menu,$state){\r\n    $scope.schools=[];\r\n    $scope.categories=['স্কুল','কলেজ','মাদ্রাসা'];\r\n    $scope.types=['বালক','বালিকা','কো-এডুকেসন'];\r\n    $scope.managements=['সরকারী','বেসরকারী','অন্যান্য'];\r\n    var i=-1;\r\n    $rootScope.nav.item=Menu.find(function(item){\r\n        i++;\r\n        return item.name==$state.current.name\r\n     });\r\n    $rootScope.nav.profile_index=i;\r\n    \r\n    if(Schools){\r\n\r\n        $scope.schools=Schools\r\n        console.log(Schools);\r\n    }\r\n    $scope.expand=function(index){\r\n\r\n        SiteEssentials.expand($scope.schools,index,'expand');\r\n    }\r\n    $scope.editSchool=function(){\r\n        \r\n    }\r\n    $scope.delete=function(ev,item_name,url,id){\r\n        superServices.deleteContent(ev,item_name,url,id);\r\n    }\r\n    $scope.submitForm=function(form,data,url,name,key){\r\n\r\n        superServices.addNewContent(data,url,name,key,$scope);\r\n    }\r\n    $scope.showEdit=function(ev,name,data,data_index,key,category_path){\r\n        console.log(data)\r\n        superServices.showModelEdit(ev,$scope,name,data_index,key);\r\n    }\r\n    \r\n}).controller('actionsCtrl',function($scope,$rootScope,$mdDialog,$state,ShowSimpleToast){\r\n  \r\n    $scope.search=function(query){\r\n        $scope.$parent.actions.search_query=query;\r\n        console.log(query);\r\n    }\r\n    $scope.addNew=function(ev,type){\r\n        if(type==null){\r\n            type='';\r\n        }\r\n         $mdDialog.show({\r\n          templateUrl: 'getView/'+$state.current.name+'.add'+type,\r\n          parent: angular.element(document.body),\r\n          targetEvent: ev,\r\n          controller:'addNewCtrl',\r\n          clickOutsideToClose: false,\r\n          fullscreen:true\r\n        }).then(function(data,key,value){\r\n            \r\n            if(data){\r\n                ShowSimpleToast.show(data.message);\r\n            }\r\n        });\r\n    }\r\n  \r\n    \r\n    \r\n})\r\n.controller('addNewCtrl',function($scope,$mdDialog,$rootScope,superServices,$state){\r\n     \r\n     if($state.current.name=='profile.schools'){\r\n\r\n        $scope.categories=['স্কুল','কলেজ','মাদ্রাসা'];\r\n        $scope.types=['বালক','বালিকা','কো-এডুকেসন'];\r\n        $scope.managements=['সরকারী','বেসরকারী','অন্যান্য'];\r\n     }\r\n    \r\n    $scope.hide=function(){\r\n        $mdDialog.hide();\r\n    }\r\n    $scope.loadCategory=function(link){\r\n         return superServices.loadCategory($scope,link);\r\n    }\r\n    $scope.submitForm=function(form,data,url,name,key){\r\n\r\n        superServices.addNewContent(data,url,name,key,$scope);\r\n    }\r\n    $scope.cancelImg=function(images,index){\r\n        images.splice(index,1);\r\n        console.log(images);\r\n    }\r\n    if($rootScope.school_data!=undefined){\r\n       $scope.attendance=$rootScope.school_data.classes;\r\n    }\r\n   \r\n   console.log($scope.attendance);\r\n   $scope.submitAttendance=function(form,attendance){\r\n    var data=[];\r\n     data['attendance']=attendance;\r\n    var url='attendance';\r\n        superServices.addNewContent(data,url,null,null,$scope);\r\n   }\r\n   \r\n})\r\n\r\n.controller('webContentsCtrl',function($state,$scope,$rootScope,HomeContents,Menu,SiteEssentials,superServices){\r\n    $scope.home_contents=HomeContents;\r\n    var i=0;\r\n    $rootScope.nav.item=Menu.find(function(item){\r\n        i++;\r\n        return item.name==$state.current.name\r\n     });\r\n    $rootScope.nav.profile_index=i;\r\n     $scope.search=function(query){\r\n        $scope.$parent.actions.search_query=query;\r\n        console.log(query);\r\n    }\r\n     $scope.search=function(query){\r\n        $scope.$parent.actions.search_query=query;\r\n        console.log(query);\r\n    }\r\n})\r\n.controller('contentCtrl',function($state,$scope,$rootScope,HomeContents,Contents,SiteEssentials,superServices,ShowSimpleToast){\r\n    \r\n    $scope.home_contents=HomeContents;\r\n    var states=$rootScope.nav.state;\r\n    var index=states.length-1;\r\n    $scope[states[index]]=Contents;\r\n    var i=-1;\r\n    \r\n    $rootScope.nav.item=HomeContents.find(function(content){\r\n        i++;\r\n        return content.name==$state.current.name;\r\n    })\r\n    $rootScope.nav.profile_index=i;\r\n\r\n    $scope.search=function(query){\r\n        $scope.$parent.actions.search_query=query;\r\n        console.log(query);\r\n    }\r\n    $scope.expand=function(index,content,data,double,key){\r\n        console.log(key);\r\n        SiteEssentials.expand($scope[content],index,'expand',double,key);\r\n        // console.log($scope[content]);\r\n    }\r\n    $scope.delete=function(ev,item_name,url,id){\r\n        superServices.deleteContent(ev,item_name,url,id);\r\n    }\r\n    \r\n    $scope.showEdit=function(ev,name,data,data_index,key,category_path){\r\n\r\n        if(!$scope.categories)\r\n            { superServices.loadCategory($scope,category_path+'/category'); }\r\n       \r\n        if(name=='links'||name=='employees'){\r\n            superServices.showLinkEdit($scope,name,data_index,key);\r\n        }else{\r\n            superServices.showModelEdit(ev,$scope,name,data_index,key);\r\n        }\r\n    }\r\n    $scope.getDate=function(date){\r\n        return SiteEssentials.getDate(date);\r\n    }\r\n    $scope.submitEditForm=function(form,data,link){\r\n        if(!form.$invalid)\r\n        { superServices.submitEditForm($scope,data,link); }\r\n    }\r\n})\r\n\r\n\r\n.controller('editModelCtrl',function($scope,$rootScope,$mdDialog,superServices,SiteEssentials,$state){\r\n    $scope.data=[];\r\n\r\n    $scope.data.editContent=$rootScope.data.editContent;\r\n    console.log($scope);\r\n\r\n    var category_path='post';\r\n\r\n     if(!$scope.categories&&$rootScope.nav.state[1]=='home_contents')\r\n            { superServices.loadCategory($scope,category_path+'/category'); }\r\n     if($state.current.name=='profile.schools'){\r\n\r\n        $scope.categories=['স্কুল','কলেজ','মাদ্রাসা'];\r\n        $scope.types=['বালক','বালিকা','কো-এডুকেসন'];\r\n        $scope.managements=['সরকারী','বেসরকারী','অন্যান্য'];\r\n     }\r\n    $scope.hide=function(){\r\n        $mdDialog.hide();\r\n    }\r\n    $scope.submitEditForm=function(form,data,link){\r\n        if(!form.$invalid){\r\n            superServices.submitEditForm($scope,data,link,true);\r\n        }\r\n    }\r\n    $scope.loadCategory=function(link){\r\n        return superServices.loadCategory($scope,link);\r\n    }\r\n    $scope.getDate=function(date){\r\n        return SiteEssentials.getDate(date);\r\n    }\r\n    \r\n})\r\n\r\n.controller('classCtrl',function($scope,$rootScope,Classes,Attendance,Menu,$state,superServices,SiteEssentials){\r\n    console.log(Classes)\r\n    console.log(Attendance);\r\n    var i=-1;\r\n     $scope.createactions=function(){\r\n        $scope.actions=[];\r\n        $scope.search_query=[];\r\n        console.log($scope.actions)\r\n     }\r\n\r\n     $rootScope.nav.item=Menu.find(function(item){\r\n        i++;\r\n        return item.name==$state.current.name\r\n     });\r\n\r\n    $rootScope.nav.profile_index=i;\r\n    $rootScope.school_data=[];\r\n    $rootScope.school_data.classes=Classes.classes;\r\n    $rootScope.school_data.attendance=Attendance.attendance;\r\n    $scope.classes=Classes.classes;\r\n    $scope.attendance=Attendance.attendance;\r\n    $scope.classLoaded=true;\r\n    $scope.is_attendance_taken=Classes.isAttendanceTaken;\r\n\r\n    $scope.search=function(query){\r\n        $scope.$parent.actions.search_query=query;\r\n        console.log(query);\r\n    }\r\n\r\n    $scope.expand=function(index,content,data,double,key){\r\n        console.log(key);\r\n        SiteEssentials.expand($scope[content],index,'expand',double,key);\r\n        // console.log($scope[content]);\r\n    }\r\n    $scope.delete=function(ev,item_name,url,id){\r\n        superServices.deleteContent(ev,item_name,url,id);\r\n    }\r\n    \r\n    $scope.showEdit=function(ev,name,data,data_index,key,category_path){\r\n            superServices.showModelEdit(ev,$scope,name,data_index);\r\n    }\r\n    $scope.getDate=function(date){\r\n        return SiteEssentials.getDate(date);\r\n    }\r\n    $scope.submitEditForm=function(form,data,link){\r\n        if(!form.$invalid)\r\n        { superServices.submitEditForm($scope,data,link); }\r\n    }\r\n\r\n})\r\n.controller('noticeCtrl',function($scope,Menu,$state,Notice,$rootScope,superServices,SiteEssentials){\r\n    console.log(Notice);\r\n    $scope.notices=Notice;\r\n    var i=-1;\r\n     $scope.createactions=function(){\r\n        $scope.actions=[];\r\n        $scope.search_query=[];\r\n        console.log($scope.actions)\r\n     }\r\n\r\n     $rootScope.nav.item=Menu.find(function(item){\r\n        i++;\r\n        return item.name==$state.current.name\r\n     });\r\n\r\n    $rootScope.nav.profile_index=i;\r\n    \r\n    $scope.search=function(query){\r\n        $scope.$parent.actions.search_query=query;\r\n        console.log(query);\r\n    }\r\n\r\n    $scope.expand=function(index,content,data,double,key){\r\n        console.log(key);\r\n        SiteEssentials.expand($scope[content],index,'expand',double,key);\r\n        // console.log($scope[content]);\r\n    }\r\n    $scope.delete=function(ev,item_name,url,id){\r\n        superServices.deleteContent(ev,item_name,url,id);\r\n    }\r\n    \r\n    $scope.showEdit=function(ev,name,data,data_index,key,category_path){\r\n\r\n     \r\n            superServices.showModelEdit(ev,$scope,name,data_index);\r\n       \r\n    }\r\n    $scope.getDate=function(date){\r\n        return SiteEssentials.getDate(date);\r\n    }\r\n    $scope.submitEditForm=function(form,data,link){\r\n        if(!form.$invalid)\r\n        { superServices.submitEditForm($scope,data,link); }\r\n    }\r\n\r\n})\r\n\r\n.controller('reportCtrl',function($scope,$rootScope,ReportMenu,superServices,$state){\r\n    console.log(ReportMenu);\r\n\r\n    $scope.state=$state;\r\n\r\n    $scope.report_menu=ReportMenu;\r\n    $scope.openReport=function(item){\r\n        \r\n        $state.go(\"profile.reports.form\",{'name':item.url});\r\n\r\n    }\r\n})\r\n.controller('formCtrl',function($scope,$rootScope,Questions,$state,$stateParams,superServices){\r\n    \r\n    $scope.name=$stateParams.name;\r\n    $scope.view='/getView/profile.reports.'+$scope.name;\r\n    $scope.form=Questions.form;\r\n    $rootScope.nav.title=$scope.form.title.value;\r\n    $scope.submitAnswer=function(form,report,type){\r\n        if(form.$invalid){ return; }\r\n\r\n        var answers=superServices.getAnswers(report,type);\r\n        console.log(answers);\r\n        superServices.submitAnswer($scope,answers);\r\n\r\n    }\r\n\r\n\r\n})//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL3N1cGVydmlzaW9uLmNvbnRyb2xsZXJzLmpzPzA4MzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3N1cGVyLWNvbnRyb2xsZXJzJyxbXSlcclxuXHJcblxyXG4uY29udHJvbGxlcignbWVudUN0cmwnLGZ1bmN0aW9uKCRzY29wZSwkaHR0cCwkbG9jYXRpb24sJHN0YXRlLFNpdGVFc3NlbnRpYWxzLHN1cGVyU2VydmljZXMsJHJvb3RTY29wZSl7XHJcbiAgICAkc2NvcGUubWVudT1mYWxzZTtcclxuICAgIFxyXG4gICAgJHNjb3BlLmxvZ291dD1mdW5jdGlvbigpe1xyXG4gICAgICAgIHN1cGVyU2VydmljZXMubG9nb3V0KCk7XHJcbiAgICB9XHJcbiAgICAkc2NvcGUuJHdhdGNoKCdjb3ZlckxvYWRlZCcsZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgIGlmKHZhbHVlKXtcclxuICAgICAgICAgICAgJHJvb3RTY29wZS5nbG9iYWxzLnNpdGVMb2FkZWQ9dHJ1ZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJHJvb3RTY29wZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxufSlcclxuLmNvbnRyb2xsZXIoJ3NpZGViYXJDdHJsJyxmdW5jdGlvbigkc2NvcGUsU2l0ZUVzc2VudGlhbHMsc3VwZXJTZXJ2aWNlcyl7XHJcbiAgICAkc2NvcGUuc2lkZWJhckxvYWRpbmc9dHJ1ZTtcclxuICAgIHZhciBzdWNjZXNzPWZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgICAkc2NvcGUuc2lkZWJhckxvYWRpbmc9ZmFsc2U7XHJcbiAgICAgICAgaWYocmVzcG9uc2UuZGF0YS5zdWNjZXNzKXtcclxuICAgICAgICAgICAgJHNjb3BlLnNpZGViYXJMb2FkaW5nPWZhbHNlO1xyXG4gICAgICAgICAgICAkc2NvcGUuc2lkZWJhcj1yZXNwb25zZS5kYXRhLnNpZGViYXI7XHJcbiAgICAgICAgICAgICRzY29wZS5iYW5pPXJlc3BvbnNlLmRhdGEuc2lkZWJhclsn4Kas4Ka+4Kao4KeAJ107XHJcbiAgICAgICAgICAgICRzY29wZS5raG9ib3I9cmVzcG9uc2UuZGF0YS5zaWRlYmFyWyfgppbgpqzgprAnXTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJHNjb3BlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBmYWlsZWQ9ZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAgICRzY29wZS5zaWRlYmFyTG9hZGluZz1mYWxzZTtcclxuICAgICAgICBTaXRlRXNzZW50aWFscy5yZXNwb25zQ2hlY2socmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgc3VwZXJTZXJ2aWNlcy5sb2FkU2lkZUJhcigkc2NvcGUsc3VjY2VzcyxmYWlsZWQpO1xyXG5cclxufSlcclxuLmNvbnRyb2xsZXIoJ2VtcGxveWVlQ3RybCcsZnVuY3Rpb24oJHNjb3BlLFNpdGVFc3NlbnRpYWxzLHN1cGVyU2VydmljZXMsRW1wbG95ZWVzLCRzdGF0ZVBhcmFtcyl7XHJcbiAgICAkc2NvcGUuZW1wbG95ZWVzPUVtcGxveWVlcztcclxuICAgICRzY29wZS50eXBlPSRzdGF0ZVBhcmFtcy50eXBlO1xyXG5cclxuXHJcbn0pXHJcbi5jb250cm9sbGVyKCdnYWxsZXJ5Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSxHYWxsZXJ5LCRzdGF0ZVBhcmFtcyxzdXBlclNlcnZpY2VzLCRzY2Upe1xyXG4gICAgJHNjb3BlLmdhbGxlcnk9R2FsbGVyeTtcclxuICAgICRzY29wZS50eXBlPSRzdGF0ZVBhcmFtcy50eXBlO1xyXG4gICAgaWYoJHNjb3BlLnR5cGU9PSd2aWRlbycpe1xyXG4gICAgICAgICRzY29wZS52aWRlb19jb25maWc9W107XHJcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5nYWxsZXJ5LGZ1bmN0aW9uKHZhbHVlLGtleSl7XHJcbiAgICAgICAgICAgICRzY29wZS52aWRlb19jb25maWdba2V5XT17XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VzOlt7c3JjOiRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKHZhbHVlLmZpbGUpLHR5cGU6J3ZpZGVvL21wNCd9XSxcclxuICAgICAgICAgICAgICAgIHRyYWNrczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBcImh0dHA6Ly93d3cudmlkZW9ndWxhci5jb20vYXNzZXRzL3N1YnMvcGFsZS1ibHVlLWRvdC52dHRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzdWJ0aXRsZXNcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjbGFuZzogXCJlblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJFbmdsaXNoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiXCJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgICRzY29wZS52aWRlb0xvYWQ9dHJ1ZTtcclxuXHJcbn0pXHJcblxyXG4uY29udHJvbGxlcignSG9tZVBvc3RDdHJsJyxmdW5jdGlvbigkc2NvcGUsUG9zdCxTaXRlRXNzZW50aWFscywkcm9vdFNjb3BlKXtcclxuICAgICRzY29wZS5wb3N0PVBvc3Q7XHJcbiAgICAkcm9vdFNjb3BlLnNpdGUudGl0bGU9JHNjb3BlLnBvc3QhPW51bGw/JHNjb3BlLnBvc3QudHlwZTokcm9vdFNjb3BlLnNpdGUudGl0bGU7XHJcbiAgICBcclxuICAgICRzY29wZS5nZXREYXRlPWZ1bmN0aW9uKGRhdGUpe1xyXG4gICAgICAgIHJldHVybiBTaXRlRXNzZW50aWFscy5nZXREYXRlKGRhdGUpO1xyXG4gICAgfVxyXG5cclxufSlcclxuXHJcbi5jb250cm9sbGVyKCdwcm9maWxlQ3RybCcsZnVuY3Rpb24oJHNjb3BlLCRyb290U2NvcGUsJGh0dHAsU2l0ZUVzc2VudGlhbHMsc3VwZXJTZXJ2aWNlcyxNZW51LCRzdGF0ZSl7XHJcbiAgICAvLyBjb25zb2xlLmxvZygkcm9vdFNjb3BlLm5hdilcclxuICAgICRzY29wZS5tZW51PU1lbnU7XHJcbiAgICBcclxuICAgICRzY29wZS5vcGVuPWZ1bmN0aW9uKGl0ZW0saW5kZXgpe1xyXG4gICAgICAgICRyb290U2NvcGUubmF2LnByb2ZpbGVfaW5kZXg9aW5kZXg7XHJcbiAgICAgICAgJHJvb3RTY29wZS5uYXYuaXRlbT1pdGVtO1xyXG4gICAgICAgICRyb290U2NvcGUubmF2LmxvYWRpbmc9dHJ1ZTtcclxuICAgICAgICAkc3RhdGUuZ28oaXRlbS5uYW1lKTtcclxuICAgIH1cclxuICAgICRzY29wZS5nb2JhY2s9ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgc3RhdGVzPSRyb290U2NvcGUubmF2LnN0YXRlO1xyXG4gICAgICAgIHZhciBiYWNrX3N0YXRlPXN0YXRlc1swXTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpPTE7aTxzdGF0ZXMubGVuZ3RoLTE7aSsrKXtcclxuICAgICAgICAgICAgYmFja19zdGF0ZSs9Jy4nK3N0YXRlc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoYmFja19zdGF0ZSE9Jycpe1xyXG4gICAgICAgICAgICAkc3RhdGUuZ28oYmFja19zdGF0ZSk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICRzdGF0ZS5nbygkcm9vdFNjb3BlLm5hdi5jdXJyZW50X3N0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgJHNjb3BlLmNyZWF0ZWFjdGlvbnM9ZnVuY3Rpb24oKXtcclxuICAgICAgICAkc2NvcGUuYWN0aW9ucz1bXTtcclxuICAgICAgICAkc2NvcGUuYWN0aW9ucy5zZWFyY2hfcXVlcnk9Jyc7XHJcbiAgICAgICAgY29uc29sZS5sb2coJHNjb3BlLmFjdGlvbnMpXHJcbiAgICB9XHJcblxyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ2lubmVyQ29udGVudEN0cmwnLGZ1bmN0aW9uKCRzY29wZSwkaHR0cCxTaXRlRXNzZW50aWFscyxzdXBlclNlcnZpY2VzLCRyb290U2NvcGUsJHN0YXRlLFNob3dTaW1wbGVUb2FzdCxNZW51KXtcclxuICAgIC8vIGFkZCBleHBhbmRpbmcgZWxlbWVudC9wbGFjZWhvbGRlciBcclxuICAgICB2YXIgaT0tMTtcclxuICAgICAkc2NvcGUuY3JlYXRlYWN0aW9ucz1mdW5jdGlvbigpe1xyXG4gICAgICAgICRzY29wZS5hY3Rpb25zPVtdO1xyXG4gICAgICAgICRzY29wZS5zZWFyY2hfcXVlcnk9W107XHJcbiAgICAgICAgY29uc29sZS5sb2coJHNjb3BlLmFjdGlvbnMpXHJcbiAgICAgfVxyXG4gICAgICRyb290U2NvcGUubmF2Lml0ZW09TWVudS5maW5kKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgIGkrKztcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lPT0kc3RhdGUuY3VycmVudC5uYW1lXHJcbiAgICAgfSk7XHJcbiAgICAgJHJvb3RTY29wZS5uYXYucHJvZmlsZV9pbmRleD1pO1xyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ3NjaG9vbEN0cmwnLGZ1bmN0aW9uKCRzY29wZSxTaXRlRXNzZW50aWFscyxzdXBlclNlcnZpY2VzLFxyXG4gICAgJHJvb3RTY29wZSxTaG93U2ltcGxlVG9hc3QsU2Nob29scyxNZW51LCRzdGF0ZSl7XHJcbiAgICAkc2NvcGUuc2Nob29scz1bXTtcclxuICAgICRzY29wZS5jYXRlZ29yaWVzPVsn4Ka44KeN4KaV4KeB4KayJywn4KaV4Kay4KeH4KacJywn4Kau4Ka+4Kam4KeN4Kaw4Ka+4Ka44Ka+J107XHJcbiAgICAkc2NvcGUudHlwZXM9Wyfgpqzgpr7gprLgppUnLCfgpqzgpr7gprLgpr/gppXgpr4nLCfgppXgp4st4KaP4Kah4KeB4KaV4KeH4Ka44KaoJ107XHJcbiAgICAkc2NvcGUubWFuYWdlbWVudHM9WyfgprjgprDgppXgpr7gprDgp4AnLCfgpqzgp4fgprjgprDgppXgpr7gprDgp4AnLCfgpoXgpqjgp43gpq/gpr7gpqjgp43gpq8nXTtcclxuICAgIHZhciBpPS0xO1xyXG4gICAgJHJvb3RTY29wZS5uYXYuaXRlbT1NZW51LmZpbmQoZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU9PSRzdGF0ZS5jdXJyZW50Lm5hbWVcclxuICAgICB9KTtcclxuICAgICRyb290U2NvcGUubmF2LnByb2ZpbGVfaW5kZXg9aTtcclxuICAgIFxyXG4gICAgaWYoU2Nob29scyl7XHJcblxyXG4gICAgICAgICRzY29wZS5zY2hvb2xzPVNjaG9vbHNcclxuICAgICAgICBjb25zb2xlLmxvZyhTY2hvb2xzKTtcclxuICAgIH1cclxuICAgICRzY29wZS5leHBhbmQ9ZnVuY3Rpb24oaW5kZXgpe1xyXG5cclxuICAgICAgICBTaXRlRXNzZW50aWFscy5leHBhbmQoJHNjb3BlLnNjaG9vbHMsaW5kZXgsJ2V4cGFuZCcpO1xyXG4gICAgfVxyXG4gICAgJHNjb3BlLmVkaXRTY2hvb2w9ZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgICRzY29wZS5kZWxldGU9ZnVuY3Rpb24oZXYsaXRlbV9uYW1lLHVybCxpZCl7XHJcbiAgICAgICAgc3VwZXJTZXJ2aWNlcy5kZWxldGVDb250ZW50KGV2LGl0ZW1fbmFtZSx1cmwsaWQpO1xyXG4gICAgfVxyXG4gICAgJHNjb3BlLnN1Ym1pdEZvcm09ZnVuY3Rpb24oZm9ybSxkYXRhLHVybCxuYW1lLGtleSl7XHJcblxyXG4gICAgICAgIHN1cGVyU2VydmljZXMuYWRkTmV3Q29udGVudChkYXRhLHVybCxuYW1lLGtleSwkc2NvcGUpO1xyXG4gICAgfVxyXG4gICAgJHNjb3BlLnNob3dFZGl0PWZ1bmN0aW9uKGV2LG5hbWUsZGF0YSxkYXRhX2luZGV4LGtleSxjYXRlZ29yeV9wYXRoKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxyXG4gICAgICAgIHN1cGVyU2VydmljZXMuc2hvd01vZGVsRWRpdChldiwkc2NvcGUsbmFtZSxkYXRhX2luZGV4LGtleSk7XHJcbiAgICB9XHJcbiAgICBcclxufSkuY29udHJvbGxlcignYWN0aW9uc0N0cmwnLGZ1bmN0aW9uKCRzY29wZSwkcm9vdFNjb3BlLCRtZERpYWxvZywkc3RhdGUsU2hvd1NpbXBsZVRvYXN0KXtcclxuICBcclxuICAgICRzY29wZS5zZWFyY2g9ZnVuY3Rpb24ocXVlcnkpe1xyXG4gICAgICAgICRzY29wZS4kcGFyZW50LmFjdGlvbnMuc2VhcmNoX3F1ZXJ5PXF1ZXJ5O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHF1ZXJ5KTtcclxuICAgIH1cclxuICAgICRzY29wZS5hZGROZXc9ZnVuY3Rpb24oZXYsdHlwZSl7XHJcbiAgICAgICAgaWYodHlwZT09bnVsbCl7XHJcbiAgICAgICAgICAgIHR5cGU9Jyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAkbWREaWFsb2cuc2hvdyh7XHJcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2dldFZpZXcvJyskc3RhdGUuY3VycmVudC5uYW1lKycuYWRkJyt0eXBlLFxyXG4gICAgICAgICAgcGFyZW50OiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQuYm9keSksXHJcbiAgICAgICAgICB0YXJnZXRFdmVudDogZXYsXHJcbiAgICAgICAgICBjb250cm9sbGVyOidhZGROZXdDdHJsJyxcclxuICAgICAgICAgIGNsaWNrT3V0c2lkZVRvQ2xvc2U6IGZhbHNlLFxyXG4gICAgICAgICAgZnVsbHNjcmVlbjp0cnVlXHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihkYXRhLGtleSx2YWx1ZSl7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihkYXRhKXtcclxuICAgICAgICAgICAgICAgIFNob3dTaW1wbGVUb2FzdC5zaG93KGRhdGEubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICBcclxuICAgIFxyXG4gICAgXHJcbn0pXHJcbi5jb250cm9sbGVyKCdhZGROZXdDdHJsJyxmdW5jdGlvbigkc2NvcGUsJG1kRGlhbG9nLCRyb290U2NvcGUsc3VwZXJTZXJ2aWNlcywkc3RhdGUpe1xyXG4gICAgIFxyXG4gICAgIGlmKCRzdGF0ZS5jdXJyZW50Lm5hbWU9PSdwcm9maWxlLnNjaG9vbHMnKXtcclxuXHJcbiAgICAgICAgJHNjb3BlLmNhdGVnb3JpZXM9Wyfgprjgp43gppXgp4HgprInLCfgppXgprLgp4fgppwnLCfgpq7gpr7gpqbgp43gprDgpr7gprjgpr4nXTtcclxuICAgICAgICAkc2NvcGUudHlwZXM9Wyfgpqzgpr7gprLgppUnLCfgpqzgpr7gprLgpr/gppXgpr4nLCfgppXgp4st4KaP4Kah4KeB4KaV4KeH4Ka44KaoJ107XHJcbiAgICAgICAgJHNjb3BlLm1hbmFnZW1lbnRzPVsn4Ka44Kaw4KaV4Ka+4Kaw4KeAJywn4Kas4KeH4Ka44Kaw4KaV4Ka+4Kaw4KeAJywn4KaF4Kao4KeN4Kav4Ka+4Kao4KeN4KavJ107XHJcbiAgICAgfVxyXG4gICAgXHJcbiAgICAkc2NvcGUuaGlkZT1mdW5jdGlvbigpe1xyXG4gICAgICAgICRtZERpYWxvZy5oaWRlKCk7XHJcbiAgICB9XHJcbiAgICAkc2NvcGUubG9hZENhdGVnb3J5PWZ1bmN0aW9uKGxpbmspe1xyXG4gICAgICAgICByZXR1cm4gc3VwZXJTZXJ2aWNlcy5sb2FkQ2F0ZWdvcnkoJHNjb3BlLGxpbmspO1xyXG4gICAgfVxyXG4gICAgJHNjb3BlLnN1Ym1pdEZvcm09ZnVuY3Rpb24oZm9ybSxkYXRhLHVybCxuYW1lLGtleSl7XHJcblxyXG4gICAgICAgIHN1cGVyU2VydmljZXMuYWRkTmV3Q29udGVudChkYXRhLHVybCxuYW1lLGtleSwkc2NvcGUpO1xyXG4gICAgfVxyXG4gICAgJHNjb3BlLmNhbmNlbEltZz1mdW5jdGlvbihpbWFnZXMsaW5kZXgpe1xyXG4gICAgICAgIGltYWdlcy5zcGxpY2UoaW5kZXgsMSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coaW1hZ2VzKTtcclxuICAgIH1cclxuICAgIGlmKCRyb290U2NvcGUuc2Nob29sX2RhdGEhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAkc2NvcGUuYXR0ZW5kYW5jZT0kcm9vdFNjb3BlLnNjaG9vbF9kYXRhLmNsYXNzZXM7XHJcbiAgICB9XHJcbiAgIFxyXG4gICBjb25zb2xlLmxvZygkc2NvcGUuYXR0ZW5kYW5jZSk7XHJcbiAgICRzY29wZS5zdWJtaXRBdHRlbmRhbmNlPWZ1bmN0aW9uKGZvcm0sYXR0ZW5kYW5jZSl7XHJcbiAgICB2YXIgZGF0YT1bXTtcclxuICAgICBkYXRhWydhdHRlbmRhbmNlJ109YXR0ZW5kYW5jZTtcclxuICAgIHZhciB1cmw9J2F0dGVuZGFuY2UnO1xyXG4gICAgICAgIHN1cGVyU2VydmljZXMuYWRkTmV3Q29udGVudChkYXRhLHVybCxudWxsLG51bGwsJHNjb3BlKTtcclxuICAgfVxyXG4gICBcclxufSlcclxuXHJcbi5jb250cm9sbGVyKCd3ZWJDb250ZW50c0N0cmwnLGZ1bmN0aW9uKCRzdGF0ZSwkc2NvcGUsJHJvb3RTY29wZSxIb21lQ29udGVudHMsTWVudSxTaXRlRXNzZW50aWFscyxzdXBlclNlcnZpY2VzKXtcclxuICAgICRzY29wZS5ob21lX2NvbnRlbnRzPUhvbWVDb250ZW50cztcclxuICAgIHZhciBpPTA7XHJcbiAgICAkcm9vdFNjb3BlLm5hdi5pdGVtPU1lbnUuZmluZChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICBpKys7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZT09JHN0YXRlLmN1cnJlbnQubmFtZVxyXG4gICAgIH0pO1xyXG4gICAgJHJvb3RTY29wZS5uYXYucHJvZmlsZV9pbmRleD1pO1xyXG4gICAgICRzY29wZS5zZWFyY2g9ZnVuY3Rpb24ocXVlcnkpe1xyXG4gICAgICAgICRzY29wZS4kcGFyZW50LmFjdGlvbnMuc2VhcmNoX3F1ZXJ5PXF1ZXJ5O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHF1ZXJ5KTtcclxuICAgIH1cclxuICAgICAkc2NvcGUuc2VhcmNoPWZ1bmN0aW9uKHF1ZXJ5KXtcclxuICAgICAgICAkc2NvcGUuJHBhcmVudC5hY3Rpb25zLnNlYXJjaF9xdWVyeT1xdWVyeTtcclxuICAgICAgICBjb25zb2xlLmxvZyhxdWVyeSk7XHJcbiAgICB9XHJcbn0pXHJcbi5jb250cm9sbGVyKCdjb250ZW50Q3RybCcsZnVuY3Rpb24oJHN0YXRlLCRzY29wZSwkcm9vdFNjb3BlLEhvbWVDb250ZW50cyxDb250ZW50cyxTaXRlRXNzZW50aWFscyxzdXBlclNlcnZpY2VzLFNob3dTaW1wbGVUb2FzdCl7XHJcbiAgICBcclxuICAgICRzY29wZS5ob21lX2NvbnRlbnRzPUhvbWVDb250ZW50cztcclxuICAgIHZhciBzdGF0ZXM9JHJvb3RTY29wZS5uYXYuc3RhdGU7XHJcbiAgICB2YXIgaW5kZXg9c3RhdGVzLmxlbmd0aC0xO1xyXG4gICAgJHNjb3BlW3N0YXRlc1tpbmRleF1dPUNvbnRlbnRzO1xyXG4gICAgdmFyIGk9LTE7XHJcbiAgICBcclxuICAgICRyb290U2NvcGUubmF2Lml0ZW09SG9tZUNvbnRlbnRzLmZpbmQoZnVuY3Rpb24oY29udGVudCl7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICAgIHJldHVybiBjb250ZW50Lm5hbWU9PSRzdGF0ZS5jdXJyZW50Lm5hbWU7XHJcbiAgICB9KVxyXG4gICAgJHJvb3RTY29wZS5uYXYucHJvZmlsZV9pbmRleD1pO1xyXG5cclxuICAgICRzY29wZS5zZWFyY2g9ZnVuY3Rpb24ocXVlcnkpe1xyXG4gICAgICAgICRzY29wZS4kcGFyZW50LmFjdGlvbnMuc2VhcmNoX3F1ZXJ5PXF1ZXJ5O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHF1ZXJ5KTtcclxuICAgIH1cclxuICAgICRzY29wZS5leHBhbmQ9ZnVuY3Rpb24oaW5kZXgsY29udGVudCxkYXRhLGRvdWJsZSxrZXkpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGtleSk7XHJcbiAgICAgICAgU2l0ZUVzc2VudGlhbHMuZXhwYW5kKCRzY29wZVtjb250ZW50XSxpbmRleCwnZXhwYW5kJyxkb3VibGUsa2V5KTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygkc2NvcGVbY29udGVudF0pO1xyXG4gICAgfVxyXG4gICAgJHNjb3BlLmRlbGV0ZT1mdW5jdGlvbihldixpdGVtX25hbWUsdXJsLGlkKXtcclxuICAgICAgICBzdXBlclNlcnZpY2VzLmRlbGV0ZUNvbnRlbnQoZXYsaXRlbV9uYW1lLHVybCxpZCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgICRzY29wZS5zaG93RWRpdD1mdW5jdGlvbihldixuYW1lLGRhdGEsZGF0YV9pbmRleCxrZXksY2F0ZWdvcnlfcGF0aCl7XHJcblxyXG4gICAgICAgIGlmKCEkc2NvcGUuY2F0ZWdvcmllcylcclxuICAgICAgICAgICAgc3VwZXJTZXJ2aWNlcy5sb2FkQ2F0ZWdvcnkoJHNjb3BlLGNhdGVnb3J5X3BhdGgrJy9jYXRlZ29yeScpO1xyXG4gICAgICAgXHJcbiAgICAgICAgaWYobmFtZT09J2xpbmtzJ3x8bmFtZT09J2VtcGxveWVlcycpe1xyXG4gICAgICAgICAgICBzdXBlclNlcnZpY2VzLnNob3dMaW5rRWRpdCgkc2NvcGUsbmFtZSxkYXRhX2luZGV4LGtleSk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHN1cGVyU2VydmljZXMuc2hvd01vZGVsRWRpdChldiwkc2NvcGUsbmFtZSxkYXRhX2luZGV4LGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgJHNjb3BlLmdldERhdGU9ZnVuY3Rpb24oZGF0ZSl7XHJcbiAgICAgICAgcmV0dXJuIFNpdGVFc3NlbnRpYWxzLmdldERhdGUoZGF0ZSk7XHJcbiAgICB9XHJcbiAgICAkc2NvcGUuc3VibWl0RWRpdEZvcm09ZnVuY3Rpb24oZm9ybSxkYXRhLGxpbmspe1xyXG4gICAgICAgIGlmKCFmb3JtLiRpbnZhbGlkKVxyXG4gICAgICAgIHN1cGVyU2VydmljZXMuc3VibWl0RWRpdEZvcm0oJHNjb3BlLGRhdGEsbGluayk7XHJcbiAgICB9XHJcbn0pXHJcblxyXG5cclxuLmNvbnRyb2xsZXIoJ2VkaXRNb2RlbEN0cmwnLGZ1bmN0aW9uKCRzY29wZSwkcm9vdFNjb3BlLCRtZERpYWxvZyxzdXBlclNlcnZpY2VzLFNpdGVFc3NlbnRpYWxzLCRzdGF0ZSl7XHJcbiAgICAkc2NvcGUuZGF0YT1bXTtcclxuXHJcbiAgICAkc2NvcGUuZGF0YS5lZGl0Q29udGVudD0kcm9vdFNjb3BlLmRhdGEuZWRpdENvbnRlbnQ7XHJcbiAgICBjb25zb2xlLmxvZygkc2NvcGUpO1xyXG5cclxuICAgIHZhciBjYXRlZ29yeV9wYXRoPSdwb3N0JztcclxuXHJcbiAgICAgaWYoISRzY29wZS5jYXRlZ29yaWVzJiYkcm9vdFNjb3BlLm5hdi5zdGF0ZVsxXT09J2hvbWVfY29udGVudHMnKVxyXG4gICAgICAgICAgICBzdXBlclNlcnZpY2VzLmxvYWRDYXRlZ29yeSgkc2NvcGUsY2F0ZWdvcnlfcGF0aCsnL2NhdGVnb3J5Jyk7XHJcbiAgICAgaWYoJHN0YXRlLmN1cnJlbnQubmFtZT09J3Byb2ZpbGUuc2Nob29scycpe1xyXG5cclxuICAgICAgICAkc2NvcGUuY2F0ZWdvcmllcz1bJ+CmuOCnjeCmleCngeCmsicsJ+CmleCmsuCnh+CmnCcsJ+CmruCmvuCmpuCnjeCmsOCmvuCmuOCmviddO1xyXG4gICAgICAgICRzY29wZS50eXBlcz1bJ+CmrOCmvuCmsuCmlScsJ+CmrOCmvuCmsuCmv+CmleCmvicsJ+CmleCniy3gpo/gpqHgp4HgppXgp4fgprjgpqgnXTtcclxuICAgICAgICAkc2NvcGUubWFuYWdlbWVudHM9WyfgprjgprDgppXgpr7gprDgp4AnLCfgpqzgp4fgprjgprDgppXgpr7gprDgp4AnLCfgpoXgpqjgp43gpq/gpr7gpqjgp43gpq8nXTtcclxuICAgICB9XHJcbiAgICAkc2NvcGUuaGlkZT1mdW5jdGlvbigpe1xyXG4gICAgICAgICRtZERpYWxvZy5oaWRlKCk7XHJcbiAgICB9XHJcbiAgICAkc2NvcGUuc3VibWl0RWRpdEZvcm09ZnVuY3Rpb24oZm9ybSxkYXRhLGxpbmspe1xyXG4gICAgICAgIGlmKCFmb3JtLiRpbnZhbGlkKXtcclxuICAgICAgICAgICAgc3VwZXJTZXJ2aWNlcy5zdWJtaXRFZGl0Rm9ybSgkc2NvcGUsZGF0YSxsaW5rLHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgICRzY29wZS5sb2FkQ2F0ZWdvcnk9ZnVuY3Rpb24obGluayl7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyU2VydmljZXMubG9hZENhdGVnb3J5KCRzY29wZSxsaW5rKTtcclxuICAgIH1cclxuICAgICRzY29wZS5nZXREYXRlPWZ1bmN0aW9uKGRhdGUpe1xyXG4gICAgICAgIHJldHVybiBTaXRlRXNzZW50aWFscy5nZXREYXRlKGRhdGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbn0pXHJcblxyXG4uY29udHJvbGxlcignY2xhc3NDdHJsJyxmdW5jdGlvbigkc2NvcGUsJHJvb3RTY29wZSxDbGFzc2VzLEF0dGVuZGFuY2UsTWVudSwkc3RhdGUsc3VwZXJTZXJ2aWNlcyxTaXRlRXNzZW50aWFscyl7XHJcbiAgICBjb25zb2xlLmxvZyhDbGFzc2VzKVxyXG4gICAgY29uc29sZS5sb2coQXR0ZW5kYW5jZSk7XHJcbiAgICB2YXIgaT0tMTtcclxuICAgICAkc2NvcGUuY3JlYXRlYWN0aW9ucz1mdW5jdGlvbigpe1xyXG4gICAgICAgICRzY29wZS5hY3Rpb25zPVtdO1xyXG4gICAgICAgICRzY29wZS5zZWFyY2hfcXVlcnk9W107XHJcbiAgICAgICAgY29uc29sZS5sb2coJHNjb3BlLmFjdGlvbnMpXHJcbiAgICAgfVxyXG5cclxuICAgICAkcm9vdFNjb3BlLm5hdi5pdGVtPU1lbnUuZmluZChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICBpKys7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZT09JHN0YXRlLmN1cnJlbnQubmFtZVxyXG4gICAgIH0pO1xyXG5cclxuICAgICRyb290U2NvcGUubmF2LnByb2ZpbGVfaW5kZXg9aTtcclxuICAgICRyb290U2NvcGUuc2Nob29sX2RhdGE9W107XHJcbiAgICAkcm9vdFNjb3BlLnNjaG9vbF9kYXRhLmNsYXNzZXM9Q2xhc3Nlcy5jbGFzc2VzO1xyXG4gICAgJHJvb3RTY29wZS5zY2hvb2xfZGF0YS5hdHRlbmRhbmNlPUF0dGVuZGFuY2UuYXR0ZW5kYW5jZTtcclxuICAgICRzY29wZS5jbGFzc2VzPUNsYXNzZXMuY2xhc3NlcztcclxuICAgICRzY29wZS5hdHRlbmRhbmNlPUF0dGVuZGFuY2UuYXR0ZW5kYW5jZTtcclxuICAgICRzY29wZS5jbGFzc0xvYWRlZD10cnVlO1xyXG4gICAgJHNjb3BlLmlzX2F0dGVuZGFuY2VfdGFrZW49Q2xhc3Nlcy5pc0F0dGVuZGFuY2VUYWtlbjtcclxuXHJcbiAgICAkc2NvcGUuc2VhcmNoPWZ1bmN0aW9uKHF1ZXJ5KXtcclxuICAgICAgICAkc2NvcGUuJHBhcmVudC5hY3Rpb25zLnNlYXJjaF9xdWVyeT1xdWVyeTtcclxuICAgICAgICBjb25zb2xlLmxvZyhxdWVyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgJHNjb3BlLmV4cGFuZD1mdW5jdGlvbihpbmRleCxjb250ZW50LGRhdGEsZG91YmxlLGtleSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coa2V5KTtcclxuICAgICAgICBTaXRlRXNzZW50aWFscy5leHBhbmQoJHNjb3BlW2NvbnRlbnRdLGluZGV4LCdleHBhbmQnLGRvdWJsZSxrZXkpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCRzY29wZVtjb250ZW50XSk7XHJcbiAgICB9XHJcbiAgICAkc2NvcGUuZGVsZXRlPWZ1bmN0aW9uKGV2LGl0ZW1fbmFtZSx1cmwsaWQpe1xyXG4gICAgICAgIHN1cGVyU2VydmljZXMuZGVsZXRlQ29udGVudChldixpdGVtX25hbWUsdXJsLGlkKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgJHNjb3BlLnNob3dFZGl0PWZ1bmN0aW9uKGV2LG5hbWUsZGF0YSxkYXRhX2luZGV4LGtleSxjYXRlZ29yeV9wYXRoKXtcclxuICAgICAgICAgICAgc3VwZXJTZXJ2aWNlcy5zaG93TW9kZWxFZGl0KGV2LCRzY29wZSxuYW1lLGRhdGFfaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgJHNjb3BlLmdldERhdGU9ZnVuY3Rpb24oZGF0ZSl7XHJcbiAgICAgICAgcmV0dXJuIFNpdGVFc3NlbnRpYWxzLmdldERhdGUoZGF0ZSk7XHJcbiAgICB9XHJcbiAgICAkc2NvcGUuc3VibWl0RWRpdEZvcm09ZnVuY3Rpb24oZm9ybSxkYXRhLGxpbmspe1xyXG4gICAgICAgIGlmKCFmb3JtLiRpbnZhbGlkKVxyXG4gICAgICAgIHN1cGVyU2VydmljZXMuc3VibWl0RWRpdEZvcm0oJHNjb3BlLGRhdGEsbGluayk7XHJcbiAgICB9XHJcblxyXG59KVxyXG4uY29udHJvbGxlcignbm90aWNlQ3RybCcsZnVuY3Rpb24oJHNjb3BlLE1lbnUsJHN0YXRlLE5vdGljZSwkcm9vdFNjb3BlLHN1cGVyU2VydmljZXMsU2l0ZUVzc2VudGlhbHMpe1xyXG4gICAgY29uc29sZS5sb2coTm90aWNlKTtcclxuICAgICRzY29wZS5ub3RpY2VzPU5vdGljZTtcclxuICAgIHZhciBpPS0xO1xyXG4gICAgICRzY29wZS5jcmVhdGVhY3Rpb25zPWZ1bmN0aW9uKCl7XHJcbiAgICAgICAgJHNjb3BlLmFjdGlvbnM9W107XHJcbiAgICAgICAgJHNjb3BlLnNlYXJjaF9xdWVyeT1bXTtcclxuICAgICAgICBjb25zb2xlLmxvZygkc2NvcGUuYWN0aW9ucylcclxuICAgICB9XHJcblxyXG4gICAgICRyb290U2NvcGUubmF2Lml0ZW09TWVudS5maW5kKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgIGkrKztcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lPT0kc3RhdGUuY3VycmVudC5uYW1lXHJcbiAgICAgfSk7XHJcblxyXG4gICAgJHJvb3RTY29wZS5uYXYucHJvZmlsZV9pbmRleD1pO1xyXG4gICAgXHJcbiAgICAkc2NvcGUuc2VhcmNoPWZ1bmN0aW9uKHF1ZXJ5KXtcclxuICAgICAgICAkc2NvcGUuJHBhcmVudC5hY3Rpb25zLnNlYXJjaF9xdWVyeT1xdWVyeTtcclxuICAgICAgICBjb25zb2xlLmxvZyhxdWVyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgJHNjb3BlLmV4cGFuZD1mdW5jdGlvbihpbmRleCxjb250ZW50LGRhdGEsZG91YmxlLGtleSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coa2V5KTtcclxuICAgICAgICBTaXRlRXNzZW50aWFscy5leHBhbmQoJHNjb3BlW2NvbnRlbnRdLGluZGV4LCdleHBhbmQnLGRvdWJsZSxrZXkpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCRzY29wZVtjb250ZW50XSk7XHJcbiAgICB9XHJcbiAgICAkc2NvcGUuZGVsZXRlPWZ1bmN0aW9uKGV2LGl0ZW1fbmFtZSx1cmwsaWQpe1xyXG4gICAgICAgIHN1cGVyU2VydmljZXMuZGVsZXRlQ29udGVudChldixpdGVtX25hbWUsdXJsLGlkKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgJHNjb3BlLnNob3dFZGl0PWZ1bmN0aW9uKGV2LG5hbWUsZGF0YSxkYXRhX2luZGV4LGtleSxjYXRlZ29yeV9wYXRoKXtcclxuXHJcbiAgICAgXHJcbiAgICAgICAgICAgIHN1cGVyU2VydmljZXMuc2hvd01vZGVsRWRpdChldiwkc2NvcGUsbmFtZSxkYXRhX2luZGV4KTtcclxuICAgICAgIFxyXG4gICAgfVxyXG4gICAgJHNjb3BlLmdldERhdGU9ZnVuY3Rpb24oZGF0ZSl7XHJcbiAgICAgICAgcmV0dXJuIFNpdGVFc3NlbnRpYWxzLmdldERhdGUoZGF0ZSk7XHJcbiAgICB9XHJcbiAgICAkc2NvcGUuc3VibWl0RWRpdEZvcm09ZnVuY3Rpb24oZm9ybSxkYXRhLGxpbmspe1xyXG4gICAgICAgIGlmKCFmb3JtLiRpbnZhbGlkKVxyXG4gICAgICAgIHN1cGVyU2VydmljZXMuc3VibWl0RWRpdEZvcm0oJHNjb3BlLGRhdGEsbGluayk7XHJcbiAgICB9XHJcblxyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ3JlcG9ydEN0cmwnLGZ1bmN0aW9uKCRzY29wZSwkcm9vdFNjb3BlLFJlcG9ydE1lbnUsc3VwZXJTZXJ2aWNlcywkc3RhdGUpe1xyXG4gICAgY29uc29sZS5sb2coUmVwb3J0TWVudSk7XHJcblxyXG4gICAgJHNjb3BlLnN0YXRlPSRzdGF0ZTtcclxuXHJcbiAgICAkc2NvcGUucmVwb3J0X21lbnU9UmVwb3J0TWVudTtcclxuICAgICRzY29wZS5vcGVuUmVwb3J0PWZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgIFxyXG4gICAgICAgICRzdGF0ZS5nbyhcInByb2ZpbGUucmVwb3J0cy5mb3JtXCIseyduYW1lJzppdGVtLnVybH0pO1xyXG5cclxuICAgIH1cclxufSlcclxuLmNvbnRyb2xsZXIoJ2Zvcm1DdHJsJyxmdW5jdGlvbigkc2NvcGUsJHJvb3RTY29wZSxRdWVzdGlvbnMsJHN0YXRlLCRzdGF0ZVBhcmFtcyxzdXBlclNlcnZpY2VzKXtcclxuICAgIFxyXG4gICAgJHNjb3BlLm5hbWU9JHN0YXRlUGFyYW1zLm5hbWU7XHJcbiAgICAkc2NvcGUudmlldz0nL2dldFZpZXcvcHJvZmlsZS5yZXBvcnRzLicrJHNjb3BlLm5hbWU7XHJcbiAgICAkc2NvcGUuZm9ybT1RdWVzdGlvbnMuZm9ybTtcclxuICAgICRyb290U2NvcGUubmF2LnRpdGxlPSRzY29wZS5mb3JtLnRpdGxlLnZhbHVlO1xyXG4gICAgJHNjb3BlLnN1Ym1pdEFuc3dlcj1mdW5jdGlvbihmb3JtLHJlcG9ydCx0eXBlKXtcclxuICAgICAgICBpZihmb3JtLiRpbnZhbGlkKXJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGFuc3dlcnM9c3VwZXJTZXJ2aWNlcy5nZXRBbnN3ZXJzKHJlcG9ydCx0eXBlKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhhbnN3ZXJzKTtcclxuICAgICAgICBzdXBlclNlcnZpY2VzLnN1Ym1pdEFuc3dlcigkc2NvcGUsYW5zd2Vycyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn0pXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJlc291cmNlcy9hc3NldHMvanMvc3VwZXJ2aXNpb24uY29udHJvbGxlcnMuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports) {

eval("angular.module('super-factory',['ngMaterial','ngAnimate'])\r\n\r\n.factory('ShowSimpleToast',function($mdToast,$mdDialog){\r\n    var toast=[];\r\n    toast.show=function(text){\r\n\r\n           $mdToast.show(\r\n                  $mdToast.simple()\r\n                    .textContent(text)             \r\n                    .action('Close')\r\n                    .highlightAction(true)\r\n                    .highlightClass('md-accent')\r\n                    .position(\"top right\")\r\n                    .hideDelay(5000)\r\n                ).then(function(response){\r\n                  $mdToast.hide();\r\n                });\r\n    }\r\n    \r\n    toast.showAlert = function(ev,title,description,arealabel) {\r\n    // Appending dialog to document.body to cover sidenav in docs app\r\n    // Modal dialogs should fully cover application\r\n    // to prevent interaction outside of dialog\r\n      title = typeof title !== 'undefined' ? title : 'Alert';\r\n      description = typeof description !== 'undefined' ? description : 'Some Error Occured';\r\n      arealabel = typeof arealabel !== 'undefined' ? arealabel : 'Error';\r\n      \r\n      $mdDialog.show(\r\n        $mdDialog.alert()\r\n          .parent(angular.element(document.querySelector('#popupContainer')))\r\n          .clickOutsideToClose(true)\r\n          .title(title)\r\n          .textContent(description)\r\n          .ariaLabel(arealabel)\r\n          .ok('Ok')\r\n          .targetEvent(ev)\r\n      );\r\n      \r\n\r\n  };\r\n  toast.showCustomPrerender=function($scope,ev,title,subtitle,template,content_id,template_id){\r\n        \r\n        var tmplate_id=(!template_id)?'display_content':template_id;\r\n        var content_id=(!content_id)?'#pre_dialog':content_id;\r\n        var templat_div=angular.element(document.getElementById(template_id));\r\n        \r\n        \r\n        templat_div.html(template);\r\n        $scope.dialog=[];\r\n        $scope.dialog.title=title;\r\n        $scope.dialog.sub_title=subtitle;\r\n        $scope.hide=function(){\r\n          $mdDialog.hide();\r\n        }\r\n        $mdDialog.show({\r\n            contentElement: content_id,\r\n            parent: angular.element(document.body),\r\n            targetEvent: ev,\r\n            clickOutsideToClose: true,\r\n          }).then(function(response){\r\n            \r\n          });\r\n      }\r\n    toast.showConfirm=function(ev,title,text_content,ok_text,cancel_text,success,failed){\r\n           title=typeof title !=undefined?title:'Are your confirm about this operation ??';\r\n           text_content=typeof text_content!=undefined?text_content:'';\r\n           var ariaLabel='Confirmation';\r\n           ok_text=typeof ok_text!=undefined?ok_text:'Ok';\r\n           cancel_text=typeof cancel_text!=undefined?cancel_text:'Cancel';\r\n\r\n       var confirm = $mdDialog.confirm()\r\n          .title(title)\r\n          .textContent(text_content)\r\n          .ariaLabel(ariaLabel)\r\n          .targetEvent(ev)\r\n          .ok(ok_text)\r\n          .cancel(cancel_text);\r\n        \r\n        $mdDialog.show(confirm).then(\r\n          success,failed)\r\n\r\n\r\n    }\r\n      \r\n    return toast;\r\n    \r\n})\r\n.service('superServices',  function($http,$rootScope,$q,SiteEssentials,\r\n  AuthenticationService,$location,$state,Upload,$mdDialog,ShowSimpleToast,$interval){\r\n  this.classes=null;\r\n  var methods=[];\r\n  \r\n  this.logout=function(){\r\n    $rootScope.logging_out=true;\r\n    $http.get('api/logout').then(function(response){\r\n      if(response.data.success){\r\n        AuthenticationService.ClearCredentials();\r\n        if($state.current.name!='home'){\r\n          $state.go('home');\r\n        }else{\r\n          $state.reload('home');\r\n        }\r\n        ShowSimpleToast.show(response.data.message);\r\n      }else{\r\n       \r\n        AuthenticationService.ClearCredentials();\r\n        if($state.current.name!='home'){\r\n          $state.go('home');\r\n        }else{\r\n          $state.reload('home');\r\n        }\r\n        ShowSimpleToast.show(response.data.message);\r\n      }\r\n    },function(response){\r\n      SiteEssentials.responsCheck(response);\r\n    })\r\n  }\r\nthis.getMenu=function(type){\r\n  var menu=[];\r\n  menu['profile']=[\r\n            {'name':'home','title':'Home','icon':'/img/accessories/home.svg','action_template':'',role:'all'},\r\n            {'name':'profile.reports','title':'Reports','icon':'/img/accessories/reports.svg',\r\n            'action_template':'getView/profile.reports.actions',role:'all'},\r\n            {'name':'profile.notice','title':'Notice','icon':'/img/accessories/notice.svg',\r\n            'action_template':'getView/profile.notice.action_template',role:'all'},\r\n            {'name':'profile.schools','title':'Schools','icon':'/img/accessories/schools.svg',\r\n            'action_template':'getView/template.actions.school',role:'admin'},\r\n            {'name':'profile.settings','title':'Settings','icon':'img/accessories/settings.svg','action_template':'',role:'all'},\r\n            {'name':'profile.home_contents','title':'Home Contents','icon':'/img/accessories/home_contents.svg',\r\n            'action_template':'getView/template.actions.home_contents',role:'admin'},\r\n            {name:'profile.class',title:'Class',icon:'img/accessories/class.svg',\r\n            action_template:'getView/profile.class.action_template',role:'general_user'}\r\n            ];\r\n  menu['home_contents']=[\r\n            {name:'profile.home_contents.posts',\r\n            'action_template':'getView/template.actions.home_contents',title:'Posts',icon:'/img/accessories/posts.svg'},\r\n            {name:'profile.home_contents.links',\r\n            'action_template':'getView/template.actions.home_contents',title:'Links',icon:'/img/accessories/links.svg'},\r\n            {name:'profile.home_contents.slider',\r\n            'action_template':'getView/template.actions.home_contents',title:'Slider',icon:'/img/accessories/slider.svg'},\r\n            {name:'profile.home_contents.gallery',\r\n            'action_template':'getView/template.actions.home_contents',title:'Gallery',icon:'/img/accessories/gallery.svg'},\r\n            {name:'profile.home_contents.employees',\r\n            'action_template':'getView/template.actions.home_contents',title:'Employees',\r\n            icon:'/img/accessories/employees.svg'}\r\n            ];\r\n    \r\n      return menu[type]\r\n    \r\n    \r\n}\r\nthis.loadHomepageContent=function($scope,content){\r\n\r\n  $rootScope.site[content+'Loading']=true;\r\n  $scope.sliders=[];\r\n  $http.get('api/homepage').then(function(response){\r\n    $rootScope.site[content+'Loading']=false;\r\n      if(response.data.success){\r\n        if(content!='all'){\r\n          \r\n          if(content=='menu'){\r\n            $scope.sliders['navigation']=SiteEssentials.generateMenu(response.data.menue);\r\n            $scope.sliders['sliders']=response.data.sliders;\r\n            \r\n          }else{\r\n            $scope[content]=response.data[content];\r\n          }\r\n        }else{\r\n          $scope.homepageContents=response.data;\r\n        }\r\n      }\r\n  },function(response){\r\n    $rootScope.site[content+'Loading']=false;\r\n    SiteEssentials.responsCheck(response);\r\n  })\r\n\r\n}\r\nthis.loadHomeMenu=function(scope,success,failed){\r\n    $http.get('api/menu').then(success,failed);\r\n}\r\nthis.loadSideBar=function(scope,success,failed){\r\n  $http.get('api/sidebar').then(success,failed);\r\n}\r\nthis.loadCategory=function($scope,link){\r\n\r\n    var differ=$q.defer();\r\n\r\n    if(!$scope.categories){\r\n      $scope.categoryLoading=true\r\n      $http.get('api/'+link).then(function(response){\r\n          console.log(response);\r\n          if(response.data.success){\r\n              $scope.categories=response.data.categories;\r\n              $scope.categoryLoading=false;\r\n              differ.resolve();\r\n\r\n          }else{\r\n              differ.reject();\r\n          }\r\n\r\n      },function(response){\r\n        differ.reject();\r\n        SiteEssentials.responsCheck(response);\r\n      });\r\n      return differ.promise;    \r\n    }else{\r\n      return false;\r\n    }\r\n  \r\n\r\n};\r\n\r\nthis.getSchools=function(){\r\n  \r\n  $rootScope.loadingData=true;\r\n  \r\n  return $http.get('api/school').then(function(response){\r\n          // console.log(response);\r\n          $rootScope.loadingData=false;\r\n            if(response.data.success){\r\n              return response.data.schools;\r\n            }else{\r\n              ShowSimpleToast.show(response.data.message);\r\n              return null;\r\n            }\r\n          },function(response){\r\n          \r\n          $rootScope.loadingData=false;\r\n          SiteEssentials.responsCheck(response);\r\n        });\r\n\r\n    };\r\n\r\nthis.getContent=function(link,title,id){\r\n  \r\n  $rootScope.loadingData=true;\r\n  var url='api/'+link;\r\n  if(typeof id!=undefined&&id!=null){\r\n    url+='/'+id;\r\n  }\r\n  // console.log(url);\r\n  return $http.get(url).then(function(response){\r\n          console.log(response);\r\n          $rootScope.loadingData=false;\r\n            if(response.data.success){\r\n              return response.data[title];\r\n            }else{\r\n              ShowSimpleToast.show(response.data.message);\r\n              return null;\r\n            }\r\n          },function(response){\r\n          \r\n          $rootScope.loadingData=false;\r\n          SiteEssentials.responsCheck(response);\r\n        });\r\n\r\n    };\r\n\r\nthis.addNewContent=function(data,url,name,key,$scope){\r\n    \r\n   var cancel=false;\r\n    $scope.form=[];\r\n    $scope.form.addingContent=true;\r\n  \r\n\r\n    var upload=Upload.upload({\r\n        url:'api/'+url,\r\n        method:'POST',\r\n        '_method':'PUT',\r\n        data:data\r\n      });\r\n    $scope.cancelsubmit=function(){\r\n      cancel=true;\r\n      upload.abort();\r\n    }\r\n    upload.then(function(response){\r\n\r\n      console.log(response);\r\n      \r\n      $scope.form.addingContent=false;\r\n      data.message=response.data.message;\r\n    \r\n        $state.reload($state.current.name);\r\n        $mdDialog.hide(data,name,key);\r\n      \r\n\r\n    },function(response){\r\n      $scope.form.addingContent=false;\r\n      if(!cancel)\r\n        { SiteEssentials.responsCheck(response); }\r\n      if (response.status > 0)\r\n                { $scope.form.error = response.status + ': ' + response.data; }\r\n    },function(evt){\r\n      $scope.form.progress = Math.min(100, parseInt(100.0 * evt.loaded / evt.total));\r\n    });\r\n   \r\n}\r\n\r\nthis.deleteContent=function(ev,item_name,url,id){\r\n\r\n  var message='Are you sure you want to delete '+item_name+' ?';\r\n  var text_content='';\r\n \r\n  \r\n   var success=function(){\r\n     $http.delete('api/'+url+'/'+id).then(function(response){\r\n          console.log(response);\r\n          ShowSimpleToast.show(response.data.message);\r\n          $state.reload($state.current.name);\r\n      },function(response){\r\n          SiteEssentials.responsCheck(response);\r\n      })\r\n  }\r\n   var failed=function(){\r\n    return false;\r\n   }\r\n   ShowSimpleToast.showConfirm(ev,message,'','Yes','No',success,failed);\r\n}\r\n\r\n  this.showLinkEdit=function($scope,name,$index,data_key){\r\n    $rootScope.data=[];\r\n\r\n    $rootScope.data.editContent=$scope[name][data_key][$index];\r\n\r\n    angular.forEach($scope[name], function(value, key){\r\n\r\n      angular.forEach(value,function(val,k){\r\n        if(key==data_key&&k==$index){\r\n          val.edit_expand=!val.edit_expand;\r\n          val.edit_template='/getView/'+$state.current.name+'.edit';\r\n        }else{\r\n          val.edit_expand=false;\r\n          val.edit_template='';\r\n        }\r\n      })\r\n\r\n      \r\n    });\r\n  }\r\n  this.showModelEdit=function(ev,$scope,name,index,key){\r\n    \r\n    $rootScope.data=[];\r\n\r\n    $rootScope.data.editContent=key!=null?$scope[name][key][index]:$scope[name][index];\r\n    \r\n    $mdDialog.show({\r\n          templateUrl: 'getView/'+$state.current.name+'.edit',\r\n          parent: angular.element(document.body),\r\n          targetEvent: ev,\r\n          controller:'editModelCtrl',\r\n          clickOutsideToClose: false,\r\n          fullscreen:true\r\n        }).then(function(data){\r\n            $rootScope.data=[];\r\n            if(data){\r\n                ShowSimpleToast.show(data.message);\r\n            }\r\n        });\r\n  }\r\n \r\n  this.submitEditForm=function($scope,data,link,dialog){\r\n    \r\n    $scope.form=[];\r\n    \r\n    $scope.form.updatingContent=true;\r\n    console.log(data);\r\n    var cancel=false;\r\n    var form_data=SiteEssentials.processFormInput(data);\r\n     console.log(form_data);\r\n    var upload=$http.put('api/'+link+'/'+data.id, form_data,{'_method':'PUT'})\r\n    \r\n    $scope.cancelsubmit=function(){\r\n      cancel=true;\r\n      upload.abort();\r\n    }\r\n\r\n\r\n      \r\n    var success=function(response){\r\n        console.log(response);\r\n        $scope.form.updatingContent=false;\r\n        if(response.data.success){\r\n            if(typeof dialog!=undefined||dialog!=null){\r\n              data.message=response.data.message;\r\n              $mdDialog.hide(data);\r\n            }else{\r\n              ShowSimpleToast.show(response.data.message);\r\n\r\n            }\r\n            $state.reload($state.current.name);\r\n        }\r\n      }\r\n   \r\n    var error =function(response){\r\n         $scope.form.updatingContent=false;\r\n         if(!cancel){ SiteEssentials.responsCheck(response); }\r\n    }\r\n    \r\n    var progress=function(evt){\r\n      $scope.form.progress = Math.min(100, parseInt(100.0 * evt.loaded / evt.total));\r\n    }\r\n    \r\n    upload.then(success,error,progress);\r\n    \r\n  }\r\n\r\n  this.getClasses=function(){\r\n    $rootScope.loadingData=true;\r\n    var role=$rootScope.globals.currentUser.role;\r\n    return $http.get('api/class').then(function(response){\r\n      $rootScope.loadingData=false;\r\n        if(response.data.success){\r\n          return response.data;\r\n        }else{\r\n          ShowSimpleToast.show(response.data.message);\r\n        }\r\n    },function(response){\r\n      SiteEssentials.responsCheck(response);\r\n    });\r\n  }\r\n  this.getAttendance=function(){\r\n    $rootScope.loadingData=true;\r\n    return $http.get('api/attendance').then(function(response){\r\n      $rootScope.loadingData=false;\r\n      if(response.data.success){\r\n        return response.data;\r\n      }else{\r\n        return ShowSimpleToast.show(response.data.message);\r\n      }\r\n    },function(response){\r\n      $rootScope.loadingData=false;\r\n      SiteEssentials.responsCheck(response);\r\n    })\r\n  }\r\n  this.checkNotice=function(response){\r\n    $http.get('api/notice/new').then(function(response){\r\n      // console.log(response);\r\n      if(response.data.success){\r\n        $rootScope.globals.new_notice=response.data;\r\n        if(!$rootScope.notice_found){\r\n          $rootScope.notice_found=true;\r\n          ShowSimpleToast.show(response.data.message);\r\n        }\r\n\r\n      }\r\n    },function(response){\r\n      ShowSimpleToast.show('Failed to connect !!');\r\n      $interval.cancel($rootScope.notification);\r\n      console.log($rootScope.notification);\r\n    })\r\n  }\r\n\r\n  this.getReportForm=function(param){\r\n    $rootScope.loadingData=true;\r\n    return $http.get('api/questions/'+param.name).then(function(response){\r\n      if(response.data.success){\r\n        console.log(response);\r\n        $rootScope.loadingData=false;\r\n        return response.data;\r\n      }else{\r\n        ShowSimpleToast.show(response.data.message);\r\n      }\r\n    },function(response){\r\n      $rootScope.loadingData=false;\r\n      SiteEssentials.responsCheck(response);\r\n    })\r\n  }\r\nthis.getAnswers=function(report,type){\r\n  answers=[];\r\n  if(type=='no_class'){\r\n    angular.forEach(report.questions, function(value, key){\r\n\r\n    if(value.type!='input'){ value.answer.answer_id=value.answer.id; }\r\n\r\n      value.answer.question_id=value.id;\r\n      answers.push(value.answer)\r\n    });\r\n  }\r\n  return answers;\r\n}\r\nthis.submitAnswer=function(scope,answer){\r\n  $rootScope.loadingData=true;\r\n  $http({url:'api/questions/'+scope.name,method:'POST',data:{answers:answer},dataType:'JSON'}).then(function(response){\r\n    $rootScope.loadingData=false;\r\n    if(response.data.success){\r\n      $state.reload($state.current.name);\r\n    }\r\n    console.log(response);\r\n    ShowSimpleToast.show(response.data.message);\r\n  },function(response){\r\n    $rootScope.loadingData=false;\r\n    SiteEssentials.responsCheck(response);\r\n  })\r\n}\r\n\r\n})\r\n\r\n\r\n.factory('SiteEssentials',function(ShowSimpleToast){\r\n\r\n  var methods={};\r\n\r\n  methods.responsCheck=function(response){\r\n    if(response.status==-1){\r\n        ShowSimpleToast.showAlert(this,'Timeout!!','Net Error Connection Timout');\r\n      }else if(response.status==500){\r\n        ShowSimpleToast.showAlert(this,response.statusText,'Sorry there might be an internal server problem please try again later');\r\n      }\r\n  }\r\n  methods.goTop=function(index){\r\n    if(index==undefined||index==null){\r\n      index=0\r\n    }\r\n    $('body,html').animate({scrollTop:index},\"slow\");\r\n  }\r\n  \r\n  methods.cloneJSON=function(old){\r\n    var newJSON={};\r\n    angular.forEach(old,function(value,key){\r\n     \r\n        newJSON[key]=value;\r\n      \r\n    });\r\n    return newJSON;\r\n  }\r\n  methods.getDateFormate=function(date){\r\n    var date=new Date(date);\r\n    var month=date.getMonth()+1;\r\n    var day=date.getDate();\r\n    var year=date.getFullYear();\r\n    if(month<=9){\r\n      month='0'+month;\r\n    }\r\n    return year+'-'+month+'-'+day;\r\n  }\r\n  methods.getDate=function(date){\r\n    if(date!=null){\r\n      return new Date(date);\r\n    }else{\r\n      return new Date\r\n    }\r\n  }\r\n \r\n methods.expand=function(data,index,name,double,keys){\r\n      \r\n      angular.forEach(data, function(value, key){\r\n\r\n        if(typeof double!=undefined &&double==1 && typeof keys != undefined){\r\n          angular.forEach(value, function(val, k){\r\n            if(k==index&&key==keys){\r\n              val[name]=!val[name];\r\n            }else{\r\n              value[name]=false;\r\n            }\r\n          });\r\n        }else{\r\n           if(key==index){\r\n                value[name]=!value[name];\r\n            }else{\r\n                value[name]=false;\r\n            }\r\n        }\r\n           \r\n        });\r\n }\r\n\r\n methods.generateMenu=function(menu_content){\r\n  var gallery={\"গ্যালারী\":[{\r\n    name:'ভিডিও গ্যালারী',\r\n    url:'#/gallery/video',\r\n    parent:'গ্যালারী'\r\n  },\r\n  {\r\n    name:'ফটো গ্যালারী',\r\n    url:'#/gallery/image'\r\n  }],'মাধ্যমিক প্রতিষ্ঠান সমূহের তালিকা':[\r\n  {name:'স্কুল',url:'#/institution/স্কুল',parent:'মাধ্যমিক প্রতিষ্ঠান সমূহের তালিকা'},\r\n  {name:'কলেজ',url:'#/institution/কলেজ',parent:'মাধ্যমিক প্রতিষ্ঠান সমূহের তালিকা'},\r\n  {name:'মাদ্রাসা',url:'#/institution/মাদ্রাসা',parent:'মাধ্যমিক প্রতিষ্ঠান সমূহের তালিকা'}\r\n  ]\r\n  }\r\n\r\n  var menu=[];\r\n  var tab=[]\r\n  tab[0]={name:'হোম',url:'#/',parent:'হোম',type:'home'}\r\n  var i=1;\r\n  var contact;\r\n    if(menu_content){\r\n      angular.forEach(menu_content, function(value, key){\r\n        \r\n        tab[i]=[];\r\n        if(!value.length){\r\n          tab[i]={parent:key}\r\n        }\r\n        if(key=='যোগাযোগ'&&!contact&&typeof value[0].title!=undefined&&typeof value[0].title!=null){\r\n          contact=contact={name:value[0].title,url:'#/posts/'+value[0].id,parent:key};\r\n            \r\n        }else{\r\n         angular.forEach(value,function(val,k){\r\n         \r\n            if(!val.is_employee){\r\n                tab[i][k]={name:val.title,url:'#/posts/'+val.id,parent:key};\r\n            }else{\r\n              tab[i][k]={name:val.designation,url:'#/employees/'+val.designation,parent:key};\r\n            }\r\n\r\n          })\r\n          \r\n          i++ \r\n        }\r\n        \r\n\r\n      });\r\n    }\r\n    angular.forEach(gallery, function(value, key){\r\n      tab[i]=value;\r\n     \r\n      i++;\r\n    });\r\n    tab[i]=contact;\r\n\r\n    return tab;\r\n }\r\n methods.processFormInput=function(data){\r\n  var form_data={};\r\n    angular.forEach(data, function(value, key){\r\n      \r\n      form_data[key]=value;\r\n      if(key=='mpo_date'){\r\n        form_data[key]=methods.getDateFormate(value);\r\n      }\r\n      \r\n    });\r\n    return form_data;\r\n }\r\n\r\n  return methods;\r\n\r\n})\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy9zdXBlcnZpc2lvbi5mYWN0b3J5LmpzP2E3ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiYW5ndWxhci5tb2R1bGUoJ3N1cGVyLWZhY3RvcnknLFsnbmdNYXRlcmlhbCcsJ25nQW5pbWF0ZSddKVxyXG5cclxuLmZhY3RvcnkoJ1Nob3dTaW1wbGVUb2FzdCcsZnVuY3Rpb24oJG1kVG9hc3QsJG1kRGlhbG9nKXtcclxuICAgIHZhciB0b2FzdD1bXTtcclxuICAgIHRvYXN0LnNob3c9ZnVuY3Rpb24odGV4dCl7XHJcblxyXG4gICAgICAgICAgICRtZFRvYXN0LnNob3coXHJcbiAgICAgICAgICAgICAgICAgICRtZFRvYXN0LnNpbXBsZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHRDb250ZW50KHRleHQpICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC5hY3Rpb24oJ0Nsb3NlJylcclxuICAgICAgICAgICAgICAgICAgICAuaGlnaGxpZ2h0QWN0aW9uKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmhpZ2hsaWdodENsYXNzKCdtZC1hY2NlbnQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5wb3NpdGlvbihcInRvcCByaWdodFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5oaWRlRGVsYXkoNTAwMClcclxuICAgICAgICAgICAgICAgICkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICAgICAgICAgICAgICRtZFRvYXN0LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0b2FzdC5zaG93QWxlcnQgPSBmdW5jdGlvbihldix0aXRsZSxkZXNjcmlwdGlvbixhcmVhbGFiZWwpIHtcclxuICAgIC8vIEFwcGVuZGluZyBkaWFsb2cgdG8gZG9jdW1lbnQuYm9keSB0byBjb3ZlciBzaWRlbmF2IGluIGRvY3MgYXBwXHJcbiAgICAvLyBNb2RhbCBkaWFsb2dzIHNob3VsZCBmdWxseSBjb3ZlciBhcHBsaWNhdGlvblxyXG4gICAgLy8gdG8gcHJldmVudCBpbnRlcmFjdGlvbiBvdXRzaWRlIG9mIGRpYWxvZ1xyXG4gICAgICB0aXRsZSA9IHR5cGVvZiB0aXRsZSAhPT0gJ3VuZGVmaW5lZCcgPyB0aXRsZSA6ICdBbGVydCc7XHJcbiAgICAgIGRlc2NyaXB0aW9uID0gdHlwZW9mIGRlc2NyaXB0aW9uICE9PSAndW5kZWZpbmVkJyA/IGRlc2NyaXB0aW9uIDogJ1NvbWUgRXJyb3IgT2NjdXJlZCc7XHJcbiAgICAgIGFyZWFsYWJlbCA9IHR5cGVvZiBhcmVhbGFiZWwgIT09ICd1bmRlZmluZWQnID8gYXJlYWxhYmVsIDogJ0Vycm9yJztcclxuICAgICAgXHJcbiAgICAgICRtZERpYWxvZy5zaG93KFxyXG4gICAgICAgICRtZERpYWxvZy5hbGVydCgpXHJcbiAgICAgICAgICAucGFyZW50KGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcG9wdXBDb250YWluZXInKSkpXHJcbiAgICAgICAgICAuY2xpY2tPdXRzaWRlVG9DbG9zZSh0cnVlKVxyXG4gICAgICAgICAgLnRpdGxlKHRpdGxlKVxyXG4gICAgICAgICAgLnRleHRDb250ZW50KGRlc2NyaXB0aW9uKVxyXG4gICAgICAgICAgLmFyaWFMYWJlbChhcmVhbGFiZWwpXHJcbiAgICAgICAgICAub2soJ09rJylcclxuICAgICAgICAgIC50YXJnZXRFdmVudChldilcclxuICAgICAgKTtcclxuICAgICAgXHJcblxyXG4gIH07XHJcbiAgdG9hc3Quc2hvd0N1c3RvbVByZXJlbmRlcj1mdW5jdGlvbigkc2NvcGUsZXYsdGl0bGUsc3VidGl0bGUsdGVtcGxhdGUsY29udGVudF9pZCx0ZW1wbGF0ZV9pZCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRtcGxhdGVfaWQ9KCF0ZW1wbGF0ZV9pZCk/J2Rpc3BsYXlfY29udGVudCc6dGVtcGxhdGVfaWQ7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRfaWQ9KCFjb250ZW50X2lkKT8nI3ByZV9kaWFsb2cnOmNvbnRlbnRfaWQ7XHJcbiAgICAgICAgdmFyIHRlbXBsYXRfZGl2PWFuZ3VsYXIuZWxlbWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZV9pZCkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIHRlbXBsYXRfZGl2Lmh0bWwodGVtcGxhdGUpO1xyXG4gICAgICAgICRzY29wZS5kaWFsb2c9W107XHJcbiAgICAgICAgJHNjb3BlLmRpYWxvZy50aXRsZT10aXRsZTtcclxuICAgICAgICAkc2NvcGUuZGlhbG9nLnN1Yl90aXRsZT1zdWJ0aXRsZTtcclxuICAgICAgICAkc2NvcGUuaGlkZT1mdW5jdGlvbigpe1xyXG4gICAgICAgICAgJG1kRGlhbG9nLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJG1kRGlhbG9nLnNob3coe1xyXG4gICAgICAgICAgICBjb250ZW50RWxlbWVudDogY29udGVudF9pZCxcclxuICAgICAgICAgICAgcGFyZW50OiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQuYm9keSksXHJcbiAgICAgICAgICAgIHRhcmdldEV2ZW50OiBldixcclxuICAgICAgICAgICAgY2xpY2tPdXRzaWRlVG9DbG9zZTogdHJ1ZSxcclxuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB0b2FzdC5zaG93Q29uZmlybT1mdW5jdGlvbihldix0aXRsZSx0ZXh0X2NvbnRlbnQsb2tfdGV4dCxjYW5jZWxfdGV4dCxzdWNjZXNzLGZhaWxlZCl7XHJcbiAgICAgICAgICAgdGl0bGU9dHlwZW9mIHRpdGxlICE9dW5kZWZpbmVkP3RpdGxlOidBcmUgeW91ciBjb25maXJtIGFib3V0IHRoaXMgb3BlcmF0aW9uID8/JztcclxuICAgICAgICAgICB0ZXh0X2NvbnRlbnQ9dHlwZW9mIHRleHRfY29udGVudCE9dW5kZWZpbmVkP3RleHRfY29udGVudDonJztcclxuICAgICAgICAgICB2YXIgYXJpYUxhYmVsPSdDb25maXJtYXRpb24nO1xyXG4gICAgICAgICAgIG9rX3RleHQ9dHlwZW9mIG9rX3RleHQhPXVuZGVmaW5lZD9va190ZXh0OidPayc7XHJcbiAgICAgICAgICAgY2FuY2VsX3RleHQ9dHlwZW9mIGNhbmNlbF90ZXh0IT11bmRlZmluZWQ/Y2FuY2VsX3RleHQ6J0NhbmNlbCc7XHJcblxyXG4gICAgICAgdmFyIGNvbmZpcm0gPSAkbWREaWFsb2cuY29uZmlybSgpXHJcbiAgICAgICAgICAudGl0bGUodGl0bGUpXHJcbiAgICAgICAgICAudGV4dENvbnRlbnQodGV4dF9jb250ZW50KVxyXG4gICAgICAgICAgLmFyaWFMYWJlbChhcmlhTGFiZWwpXHJcbiAgICAgICAgICAudGFyZ2V0RXZlbnQoZXYpXHJcbiAgICAgICAgICAub2sob2tfdGV4dClcclxuICAgICAgICAgIC5jYW5jZWwoY2FuY2VsX3RleHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICRtZERpYWxvZy5zaG93KGNvbmZpcm0pLnRoZW4oXHJcbiAgICAgICAgICBzdWNjZXNzLGZhaWxlZClcclxuXHJcblxyXG4gICAgfVxyXG4gICAgICBcclxuICAgIHJldHVybiB0b2FzdDtcclxuICAgIFxyXG59KVxyXG4uc2VydmljZSgnc3VwZXJTZXJ2aWNlcycsICBmdW5jdGlvbigkaHR0cCwkcm9vdFNjb3BlLCRxLFNpdGVFc3NlbnRpYWxzLFxyXG4gIEF1dGhlbnRpY2F0aW9uU2VydmljZSwkbG9jYXRpb24sJHN0YXRlLFVwbG9hZCwkbWREaWFsb2csU2hvd1NpbXBsZVRvYXN0LCRpbnRlcnZhbCl7XHJcbiAgdGhpcy5jbGFzc2VzPW51bGw7XHJcbiAgdmFyIG1ldGhvZHM9W107XHJcbiAgXHJcbiAgdGhpcy5sb2dvdXQ9ZnVuY3Rpb24oKXtcclxuICAgICRyb290U2NvcGUubG9nZ2luZ19vdXQ9dHJ1ZTtcclxuICAgICRodHRwLmdldCgnYXBpL2xvZ291dCcpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICBpZihyZXNwb25zZS5kYXRhLnN1Y2Nlc3Mpe1xyXG4gICAgICAgIEF1dGhlbnRpY2F0aW9uU2VydmljZS5DbGVhckNyZWRlbnRpYWxzKCk7XHJcbiAgICAgICAgaWYoJHN0YXRlLmN1cnJlbnQubmFtZSE9J2hvbWUnKXtcclxuICAgICAgICAgICRzdGF0ZS5nbygnaG9tZScpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgJHN0YXRlLnJlbG9hZCgnaG9tZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTaG93U2ltcGxlVG9hc3Quc2hvdyhyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICB9ZWxzZXtcclxuICAgICAgIFxyXG4gICAgICAgIEF1dGhlbnRpY2F0aW9uU2VydmljZS5DbGVhckNyZWRlbnRpYWxzKCk7XHJcbiAgICAgICAgaWYoJHN0YXRlLmN1cnJlbnQubmFtZSE9J2hvbWUnKXtcclxuICAgICAgICAgICRzdGF0ZS5nbygnaG9tZScpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgJHN0YXRlLnJlbG9hZCgnaG9tZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTaG93U2ltcGxlVG9hc3Quc2hvdyhyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9LGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgU2l0ZUVzc2VudGlhbHMucmVzcG9uc0NoZWNrKHJlc3BvbnNlKTtcclxuICAgIH0pXHJcbiAgfVxyXG50aGlzLmdldE1lbnU9ZnVuY3Rpb24odHlwZSl7XHJcbiAgdmFyIG1lbnU9W107XHJcbiAgbWVudVsncHJvZmlsZSddPVtcclxuICAgICAgICAgICAgeyduYW1lJzonaG9tZScsJ3RpdGxlJzonSG9tZScsJ2ljb24nOicvaW1nL2FjY2Vzc29yaWVzL2hvbWUuc3ZnJywnYWN0aW9uX3RlbXBsYXRlJzonJyxyb2xlOidhbGwnfSxcclxuICAgICAgICAgICAgeyduYW1lJzoncHJvZmlsZS5yZXBvcnRzJywndGl0bGUnOidSZXBvcnRzJywnaWNvbic6Jy9pbWcvYWNjZXNzb3JpZXMvcmVwb3J0cy5zdmcnLFxyXG4gICAgICAgICAgICAnYWN0aW9uX3RlbXBsYXRlJzonZ2V0Vmlldy9wcm9maWxlLnJlcG9ydHMuYWN0aW9ucycscm9sZTonYWxsJ30sXHJcbiAgICAgICAgICAgIHsnbmFtZSc6J3Byb2ZpbGUubm90aWNlJywndGl0bGUnOidOb3RpY2UnLCdpY29uJzonL2ltZy9hY2Nlc3Nvcmllcy9ub3RpY2Uuc3ZnJyxcclxuICAgICAgICAgICAgJ2FjdGlvbl90ZW1wbGF0ZSc6J2dldFZpZXcvcHJvZmlsZS5ub3RpY2UuYWN0aW9uX3RlbXBsYXRlJyxyb2xlOidhbGwnfSxcclxuICAgICAgICAgICAgeyduYW1lJzoncHJvZmlsZS5zY2hvb2xzJywndGl0bGUnOidTY2hvb2xzJywnaWNvbic6Jy9pbWcvYWNjZXNzb3JpZXMvc2Nob29scy5zdmcnLFxyXG4gICAgICAgICAgICAnYWN0aW9uX3RlbXBsYXRlJzonZ2V0Vmlldy90ZW1wbGF0ZS5hY3Rpb25zLnNjaG9vbCcscm9sZTonYWRtaW4nfSxcclxuICAgICAgICAgICAgeyduYW1lJzoncHJvZmlsZS5zZXR0aW5ncycsJ3RpdGxlJzonU2V0dGluZ3MnLCdpY29uJzonaW1nL2FjY2Vzc29yaWVzL3NldHRpbmdzLnN2ZycsJ2FjdGlvbl90ZW1wbGF0ZSc6Jycscm9sZTonYWxsJ30sXHJcbiAgICAgICAgICAgIHsnbmFtZSc6J3Byb2ZpbGUuaG9tZV9jb250ZW50cycsJ3RpdGxlJzonSG9tZSBDb250ZW50cycsJ2ljb24nOicvaW1nL2FjY2Vzc29yaWVzL2hvbWVfY29udGVudHMuc3ZnJyxcclxuICAgICAgICAgICAgJ2FjdGlvbl90ZW1wbGF0ZSc6J2dldFZpZXcvdGVtcGxhdGUuYWN0aW9ucy5ob21lX2NvbnRlbnRzJyxyb2xlOidhZG1pbid9LFxyXG4gICAgICAgICAgICB7bmFtZToncHJvZmlsZS5jbGFzcycsdGl0bGU6J0NsYXNzJyxpY29uOidpbWcvYWNjZXNzb3JpZXMvY2xhc3Muc3ZnJyxcclxuICAgICAgICAgICAgYWN0aW9uX3RlbXBsYXRlOidnZXRWaWV3L3Byb2ZpbGUuY2xhc3MuYWN0aW9uX3RlbXBsYXRlJyxyb2xlOidnZW5lcmFsX3VzZXInfVxyXG4gICAgICAgICAgICBdO1xyXG4gIG1lbnVbJ2hvbWVfY29udGVudHMnXT1bXHJcbiAgICAgICAgICAgIHtuYW1lOidwcm9maWxlLmhvbWVfY29udGVudHMucG9zdHMnLFxyXG4gICAgICAgICAgICAnYWN0aW9uX3RlbXBsYXRlJzonZ2V0Vmlldy90ZW1wbGF0ZS5hY3Rpb25zLmhvbWVfY29udGVudHMnLHRpdGxlOidQb3N0cycsaWNvbjonL2ltZy9hY2Nlc3Nvcmllcy9wb3N0cy5zdmcnfSxcclxuICAgICAgICAgICAge25hbWU6J3Byb2ZpbGUuaG9tZV9jb250ZW50cy5saW5rcycsXHJcbiAgICAgICAgICAgICdhY3Rpb25fdGVtcGxhdGUnOidnZXRWaWV3L3RlbXBsYXRlLmFjdGlvbnMuaG9tZV9jb250ZW50cycsdGl0bGU6J0xpbmtzJyxpY29uOicvaW1nL2FjY2Vzc29yaWVzL2xpbmtzLnN2Zyd9LFxyXG4gICAgICAgICAgICB7bmFtZToncHJvZmlsZS5ob21lX2NvbnRlbnRzLnNsaWRlcicsXHJcbiAgICAgICAgICAgICdhY3Rpb25fdGVtcGxhdGUnOidnZXRWaWV3L3RlbXBsYXRlLmFjdGlvbnMuaG9tZV9jb250ZW50cycsdGl0bGU6J1NsaWRlcicsaWNvbjonL2ltZy9hY2Nlc3Nvcmllcy9zbGlkZXIuc3ZnJ30sXHJcbiAgICAgICAgICAgIHtuYW1lOidwcm9maWxlLmhvbWVfY29udGVudHMuZ2FsbGVyeScsXHJcbiAgICAgICAgICAgICdhY3Rpb25fdGVtcGxhdGUnOidnZXRWaWV3L3RlbXBsYXRlLmFjdGlvbnMuaG9tZV9jb250ZW50cycsdGl0bGU6J0dhbGxlcnknLGljb246Jy9pbWcvYWNjZXNzb3JpZXMvZ2FsbGVyeS5zdmcnfSxcclxuICAgICAgICAgICAge25hbWU6J3Byb2ZpbGUuaG9tZV9jb250ZW50cy5lbXBsb3llZXMnLFxyXG4gICAgICAgICAgICAnYWN0aW9uX3RlbXBsYXRlJzonZ2V0Vmlldy90ZW1wbGF0ZS5hY3Rpb25zLmhvbWVfY29udGVudHMnLHRpdGxlOidFbXBsb3llZXMnLFxyXG4gICAgICAgICAgICBpY29uOicvaW1nL2FjY2Vzc29yaWVzL2VtcGxveWVlcy5zdmcnfVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgXHJcbiAgICAgIHJldHVybiBtZW51W3R5cGVdXHJcbiAgICBcclxuICAgIFxyXG59XHJcbnRoaXMubG9hZEhvbWVwYWdlQ29udGVudD1mdW5jdGlvbigkc2NvcGUsY29udGVudCl7XHJcblxyXG4gICRyb290U2NvcGUuc2l0ZVtjb250ZW50KydMb2FkaW5nJ109dHJ1ZTtcclxuICAkc2NvcGUuc2xpZGVycz1bXTtcclxuICAkaHR0cC5nZXQoJ2FwaS9ob21lcGFnZScpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgJHJvb3RTY29wZS5zaXRlW2NvbnRlbnQrJ0xvYWRpbmcnXT1mYWxzZTtcclxuICAgICAgaWYocmVzcG9uc2UuZGF0YS5zdWNjZXNzKXtcclxuICAgICAgICBpZihjb250ZW50IT0nYWxsJyl7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmKGNvbnRlbnQ9PSdtZW51Jyl7XHJcbiAgICAgICAgICAgICRzY29wZS5zbGlkZXJzWyduYXZpZ2F0aW9uJ109U2l0ZUVzc2VudGlhbHMuZ2VuZXJhdGVNZW51KHJlc3BvbnNlLmRhdGEubWVudWUpO1xyXG4gICAgICAgICAgICAkc2NvcGUuc2xpZGVyc1snc2xpZGVycyddPXJlc3BvbnNlLmRhdGEuc2xpZGVycztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgJHNjb3BlW2NvbnRlbnRdPXJlc3BvbnNlLmRhdGFbY29udGVudF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAkc2NvcGUuaG9tZXBhZ2VDb250ZW50cz1yZXNwb25zZS5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIH0sZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgJHJvb3RTY29wZS5zaXRlW2NvbnRlbnQrJ0xvYWRpbmcnXT1mYWxzZTtcclxuICAgIFNpdGVFc3NlbnRpYWxzLnJlc3BvbnNDaGVjayhyZXNwb25zZSk7XHJcbiAgfSlcclxuXHJcbn1cclxudGhpcy5sb2FkSG9tZU1lbnU9ZnVuY3Rpb24oc2NvcGUsc3VjY2VzcyxmYWlsZWQpe1xyXG4gICAgJGh0dHAuZ2V0KCdhcGkvbWVudScpLnRoZW4oc3VjY2VzcyxmYWlsZWQpO1xyXG59XHJcbnRoaXMubG9hZFNpZGVCYXI9ZnVuY3Rpb24oc2NvcGUsc3VjY2VzcyxmYWlsZWQpe1xyXG4gICRodHRwLmdldCgnYXBpL3NpZGViYXInKS50aGVuKHN1Y2Nlc3MsZmFpbGVkKTtcclxufVxyXG50aGlzLmxvYWRDYXRlZ29yeT1mdW5jdGlvbigkc2NvcGUsbGluayl7XHJcblxyXG4gICAgdmFyIGRpZmZlcj0kcS5kZWZlcigpO1xyXG5cclxuICAgIGlmKCEkc2NvcGUuY2F0ZWdvcmllcyl7XHJcbiAgICAgICRzY29wZS5jYXRlZ29yeUxvYWRpbmc9dHJ1ZVxyXG4gICAgICAkaHR0cC5nZXQoJ2FwaS8nK2xpbmspLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG4gICAgICAgICAgaWYocmVzcG9uc2UuZGF0YS5zdWNjZXNzKXtcclxuICAgICAgICAgICAgICAkc2NvcGUuY2F0ZWdvcmllcz1yZXNwb25zZS5kYXRhLmNhdGVnb3JpZXM7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmNhdGVnb3J5TG9hZGluZz1mYWxzZTtcclxuICAgICAgICAgICAgICBkaWZmZXIucmVzb2x2ZSgpO1xyXG5cclxuICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgIGRpZmZlci5yZWplY3QoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgIH0sZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAgIGRpZmZlci5yZWplY3QoKTtcclxuICAgICAgICBTaXRlRXNzZW50aWFscy5yZXNwb25zQ2hlY2socmVzcG9uc2UpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGRpZmZlci5wcm9taXNlOyAgICBcclxuICAgIH1lbHNle1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgXHJcblxyXG59O1xyXG5cclxudGhpcy5nZXRTY2hvb2xzPWZ1bmN0aW9uKCl7XHJcbiAgXHJcbiAgJHJvb3RTY29wZS5sb2FkaW5nRGF0YT10cnVlO1xyXG4gIFxyXG4gIHJldHVybiAkaHR0cC5nZXQoJ2FwaS9zY2hvb2wnKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcclxuICAgICAgICAgICRyb290U2NvcGUubG9hZGluZ0RhdGE9ZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKHJlc3BvbnNlLmRhdGEuc3VjY2Vzcyl7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuc2Nob29scztcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgU2hvd1NpbXBsZVRvYXN0LnNob3cocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxmdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICRyb290U2NvcGUubG9hZGluZ0RhdGE9ZmFsc2U7XHJcbiAgICAgICAgICBTaXRlRXNzZW50aWFscy5yZXNwb25zQ2hlY2socmVzcG9uc2UpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH07XHJcblxyXG50aGlzLmdldENvbnRlbnQ9ZnVuY3Rpb24obGluayx0aXRsZSxpZCl7XHJcbiAgXHJcbiAgJHJvb3RTY29wZS5sb2FkaW5nRGF0YT10cnVlO1xyXG4gIHZhciB1cmw9J2FwaS8nK2xpbms7XHJcbiAgaWYodHlwZW9mIGlkIT11bmRlZmluZWQmJmlkIT1udWxsKXtcclxuICAgIHVybCs9Jy8nK2lkO1xyXG4gIH1cclxuICAvLyBjb25zb2xlLmxvZyh1cmwpO1xyXG4gIHJldHVybiAkaHR0cC5nZXQodXJsKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcclxuICAgICAgICAgICRyb290U2NvcGUubG9hZGluZ0RhdGE9ZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKHJlc3BvbnNlLmRhdGEuc3VjY2Vzcyl7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFbdGl0bGVdO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICBTaG93U2ltcGxlVG9hc3Quc2hvdyhyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgJHJvb3RTY29wZS5sb2FkaW5nRGF0YT1mYWxzZTtcclxuICAgICAgICAgIFNpdGVFc3NlbnRpYWxzLnJlc3BvbnNDaGVjayhyZXNwb25zZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfTtcclxuXHJcbnRoaXMuYWRkTmV3Q29udGVudD1mdW5jdGlvbihkYXRhLHVybCxuYW1lLGtleSwkc2NvcGUpe1xyXG4gICAgXHJcbiAgIHZhciBjYW5jZWw9ZmFsc2U7XHJcbiAgICAkc2NvcGUuZm9ybT1bXTtcclxuICAgICRzY29wZS5mb3JtLmFkZGluZ0NvbnRlbnQ9dHJ1ZTtcclxuICBcclxuXHJcbiAgICB2YXIgdXBsb2FkPVVwbG9hZC51cGxvYWQoe1xyXG4gICAgICAgIHVybDonYXBpLycrdXJsLFxyXG4gICAgICAgIG1ldGhvZDonUE9TVCcsXHJcbiAgICAgICAgJ19tZXRob2QnOidQVVQnLFxyXG4gICAgICAgIGRhdGE6ZGF0YVxyXG4gICAgICB9KTtcclxuICAgICRzY29wZS5jYW5jZWxzdWJtaXQ9ZnVuY3Rpb24oKXtcclxuICAgICAgY2FuY2VsPXRydWU7XHJcbiAgICAgIHVwbG9hZC5hYm9ydCgpO1xyXG4gICAgfVxyXG4gICAgdXBsb2FkLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG5cclxuICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG4gICAgICBcclxuICAgICAgJHNjb3BlLmZvcm0uYWRkaW5nQ29udGVudD1mYWxzZTtcclxuICAgICAgZGF0YS5tZXNzYWdlPXJlc3BvbnNlLmRhdGEubWVzc2FnZTtcclxuICAgIFxyXG4gICAgICAgICRzdGF0ZS5yZWxvYWQoJHN0YXRlLmN1cnJlbnQubmFtZSk7XHJcbiAgICAgICAgJG1kRGlhbG9nLmhpZGUoZGF0YSxuYW1lLGtleSk7XHJcbiAgICAgIFxyXG5cclxuICAgIH0sZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAkc2NvcGUuZm9ybS5hZGRpbmdDb250ZW50PWZhbHNlO1xyXG4gICAgICBpZighY2FuY2VsKVxyXG4gICAgICAgIFNpdGVFc3NlbnRpYWxzLnJlc3BvbnNDaGVjayhyZXNwb25zZSk7XHJcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPiAwKVxyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmZvcm0uZXJyb3IgPSByZXNwb25zZS5zdGF0dXMgKyAnOiAnICsgcmVzcG9uc2UuZGF0YTtcclxuICAgIH0sZnVuY3Rpb24oZXZ0KXtcclxuICAgICAgJHNjb3BlLmZvcm0ucHJvZ3Jlc3MgPSBNYXRoLm1pbigxMDAsIHBhcnNlSW50KDEwMC4wICogZXZ0LmxvYWRlZCAvIGV2dC50b3RhbCkpO1xyXG4gICAgfSk7XHJcbiAgIFxyXG59XHJcblxyXG50aGlzLmRlbGV0ZUNvbnRlbnQ9ZnVuY3Rpb24oZXYsaXRlbV9uYW1lLHVybCxpZCl7XHJcblxyXG4gIHZhciBtZXNzYWdlPSdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlICcraXRlbV9uYW1lKycgPyc7XHJcbiAgdmFyIHRleHRfY29udGVudD0nJztcclxuIFxyXG4gIFxyXG4gICB2YXIgc3VjY2Vzcz1mdW5jdGlvbigpe1xyXG4gICAgICRodHRwLmRlbGV0ZSgnYXBpLycrdXJsKycvJytpZCkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICBTaG93U2ltcGxlVG9hc3Quc2hvdyhyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgJHN0YXRlLnJlbG9hZCgkc3RhdGUuY3VycmVudC5uYW1lKTtcclxuICAgICAgfSxmdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICAgICBTaXRlRXNzZW50aWFscy5yZXNwb25zQ2hlY2socmVzcG9uc2UpO1xyXG4gICAgICB9KVxyXG4gIH1cclxuICAgdmFyIGZhaWxlZD1mdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gICB9XHJcbiAgIFNob3dTaW1wbGVUb2FzdC5zaG93Q29uZmlybShldixtZXNzYWdlLCcnLCdZZXMnLCdObycsc3VjY2VzcyxmYWlsZWQpO1xyXG59XHJcblxyXG4gIHRoaXMuc2hvd0xpbmtFZGl0PWZ1bmN0aW9uKCRzY29wZSxuYW1lLCRpbmRleCxkYXRhX2tleSl7XHJcbiAgICAkcm9vdFNjb3BlLmRhdGE9W107XHJcblxyXG4gICAgJHJvb3RTY29wZS5kYXRhLmVkaXRDb250ZW50PSRzY29wZVtuYW1lXVtkYXRhX2tleV1bJGluZGV4XTtcclxuXHJcbiAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlW25hbWVdLCBmdW5jdGlvbih2YWx1ZSwga2V5KXtcclxuXHJcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaCh2YWx1ZSxmdW5jdGlvbih2YWwsayl7XHJcbiAgICAgICAgaWYoa2V5PT1kYXRhX2tleSYmaz09JGluZGV4KXtcclxuICAgICAgICAgIHZhbC5lZGl0X2V4cGFuZD0hdmFsLmVkaXRfZXhwYW5kO1xyXG4gICAgICAgICAgdmFsLmVkaXRfdGVtcGxhdGU9Jy9nZXRWaWV3LycrJHN0YXRlLmN1cnJlbnQubmFtZSsnLmVkaXQnO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgdmFsLmVkaXRfZXhwYW5kPWZhbHNlO1xyXG4gICAgICAgICAgdmFsLmVkaXRfdGVtcGxhdGU9Jyc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgXHJcbiAgICB9KTtcclxuICB9XHJcbiAgdGhpcy5zaG93TW9kZWxFZGl0PWZ1bmN0aW9uKGV2LCRzY29wZSxuYW1lLGluZGV4LGtleSl7XHJcbiAgICBcclxuICAgICRyb290U2NvcGUuZGF0YT1bXTtcclxuXHJcbiAgICAkcm9vdFNjb3BlLmRhdGEuZWRpdENvbnRlbnQ9a2V5IT1udWxsPyRzY29wZVtuYW1lXVtrZXldW2luZGV4XTokc2NvcGVbbmFtZV1baW5kZXhdO1xyXG4gICAgXHJcbiAgICAkbWREaWFsb2cuc2hvdyh7XHJcbiAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2dldFZpZXcvJyskc3RhdGUuY3VycmVudC5uYW1lKycuZWRpdCcsXHJcbiAgICAgICAgICBwYXJlbnQ6IGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudC5ib2R5KSxcclxuICAgICAgICAgIHRhcmdldEV2ZW50OiBldixcclxuICAgICAgICAgIGNvbnRyb2xsZXI6J2VkaXRNb2RlbEN0cmwnLFxyXG4gICAgICAgICAgY2xpY2tPdXRzaWRlVG9DbG9zZTogZmFsc2UsXHJcbiAgICAgICAgICBmdWxsc2NyZWVuOnRydWVcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmRhdGE9W107XHJcbiAgICAgICAgICAgIGlmKGRhdGEpe1xyXG4gICAgICAgICAgICAgICAgU2hvd1NpbXBsZVRvYXN0LnNob3coZGF0YS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gIH1cclxuIFxyXG4gIHRoaXMuc3VibWl0RWRpdEZvcm09ZnVuY3Rpb24oJHNjb3BlLGRhdGEsbGluayxkaWFsb2cpe1xyXG4gICAgXHJcbiAgICAkc2NvcGUuZm9ybT1bXTtcclxuICAgIFxyXG4gICAgJHNjb3BlLmZvcm0udXBkYXRpbmdDb250ZW50PXRydWU7XHJcbiAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuICAgIHZhciBjYW5jZWw9ZmFsc2U7XHJcbiAgICB2YXIgZm9ybV9kYXRhPVNpdGVFc3NlbnRpYWxzLnByb2Nlc3NGb3JtSW5wdXQoZGF0YSk7XHJcbiAgICAgY29uc29sZS5sb2coZm9ybV9kYXRhKTtcclxuICAgIHZhciB1cGxvYWQ9JGh0dHAucHV0KCdhcGkvJytsaW5rKycvJytkYXRhLmlkLCBmb3JtX2RhdGEseydfbWV0aG9kJzonUFVUJ30pXHJcbiAgICBcclxuICAgICRzY29wZS5jYW5jZWxzdWJtaXQ9ZnVuY3Rpb24oKXtcclxuICAgICAgY2FuY2VsPXRydWU7XHJcbiAgICAgIHVwbG9hZC5hYm9ydCgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAgIFxyXG4gICAgdmFyIHN1Y2Nlc3M9ZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcclxuICAgICAgICAkc2NvcGUuZm9ybS51cGRhdGluZ0NvbnRlbnQ9ZmFsc2U7XHJcbiAgICAgICAgaWYocmVzcG9uc2UuZGF0YS5zdWNjZXNzKXtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGRpYWxvZyE9dW5kZWZpbmVkfHxkaWFsb2chPW51bGwpe1xyXG4gICAgICAgICAgICAgIGRhdGEubWVzc2FnZT1yZXNwb25zZS5kYXRhLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgJG1kRGlhbG9nLmhpZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgIFNob3dTaW1wbGVUb2FzdC5zaG93KHJlc3BvbnNlLmRhdGEubWVzc2FnZSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRzdGF0ZS5yZWxvYWQoJHN0YXRlLmN1cnJlbnQubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIFxyXG4gICAgdmFyIGVycm9yID1mdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICAgICRzY29wZS5mb3JtLnVwZGF0aW5nQ29udGVudD1mYWxzZTtcclxuICAgICAgICAgaWYoIWNhbmNlbClTaXRlRXNzZW50aWFscy5yZXNwb25zQ2hlY2socmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgcHJvZ3Jlc3M9ZnVuY3Rpb24oZXZ0KXtcclxuICAgICAgJHNjb3BlLmZvcm0ucHJvZ3Jlc3MgPSBNYXRoLm1pbigxMDAsIHBhcnNlSW50KDEwMC4wICogZXZ0LmxvYWRlZCAvIGV2dC50b3RhbCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB1cGxvYWQudGhlbihzdWNjZXNzLGVycm9yLHByb2dyZXNzKTtcclxuICAgIFxyXG4gIH1cclxuXHJcbiAgdGhpcy5nZXRDbGFzc2VzPWZ1bmN0aW9uKCl7XHJcbiAgICAkcm9vdFNjb3BlLmxvYWRpbmdEYXRhPXRydWU7XHJcbiAgICB2YXIgcm9sZT0kcm9vdFNjb3BlLmdsb2JhbHMuY3VycmVudFVzZXIucm9sZTtcclxuICAgIHJldHVybiAkaHR0cC5nZXQoJ2FwaS9jbGFzcycpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAkcm9vdFNjb3BlLmxvYWRpbmdEYXRhPWZhbHNlO1xyXG4gICAgICAgIGlmKHJlc3BvbnNlLmRhdGEuc3VjY2Vzcyl7XHJcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIFNob3dTaW1wbGVUb2FzdC5zaG93KHJlc3BvbnNlLmRhdGEubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxmdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgIFNpdGVFc3NlbnRpYWxzLnJlc3BvbnNDaGVjayhyZXNwb25zZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgdGhpcy5nZXRBdHRlbmRhbmNlPWZ1bmN0aW9uKCl7XHJcbiAgICAkcm9vdFNjb3BlLmxvYWRpbmdEYXRhPXRydWU7XHJcbiAgICByZXR1cm4gJGh0dHAuZ2V0KCdhcGkvYXR0ZW5kYW5jZScpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAkcm9vdFNjb3BlLmxvYWRpbmdEYXRhPWZhbHNlO1xyXG4gICAgICBpZihyZXNwb25zZS5kYXRhLnN1Y2Nlc3Mpe1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICByZXR1cm4gU2hvd1NpbXBsZVRvYXN0LnNob3cocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgfSxmdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICRyb290U2NvcGUubG9hZGluZ0RhdGE9ZmFsc2U7XHJcbiAgICAgIFNpdGVFc3NlbnRpYWxzLnJlc3BvbnNDaGVjayhyZXNwb25zZSk7XHJcbiAgICB9KVxyXG4gIH1cclxuICB0aGlzLmNoZWNrTm90aWNlPWZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICRodHRwLmdldCgnYXBpL25vdGljZS9uZXcnKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgLy8gY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG4gICAgICBpZihyZXNwb25zZS5kYXRhLnN1Y2Nlc3Mpe1xyXG4gICAgICAgICRyb290U2NvcGUuZ2xvYmFscy5uZXdfbm90aWNlPXJlc3BvbnNlLmRhdGE7XHJcbiAgICAgICAgaWYoISRyb290U2NvcGUubm90aWNlX2ZvdW5kKXtcclxuICAgICAgICAgICRyb290U2NvcGUubm90aWNlX2ZvdW5kPXRydWU7XHJcbiAgICAgICAgICBTaG93U2ltcGxlVG9hc3Quc2hvdyhyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuICAgIH0sZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICBTaG93U2ltcGxlVG9hc3Quc2hvdygnRmFpbGVkIHRvIGNvbm5lY3QgISEnKTtcclxuICAgICAgJGludGVydmFsLmNhbmNlbCgkcm9vdFNjb3BlLm5vdGlmaWNhdGlvbik7XHJcbiAgICAgIGNvbnNvbGUubG9nKCRyb290U2NvcGUubm90aWZpY2F0aW9uKTtcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICB0aGlzLmdldFJlcG9ydEZvcm09ZnVuY3Rpb24ocGFyYW0pe1xyXG4gICAgJHJvb3RTY29wZS5sb2FkaW5nRGF0YT10cnVlO1xyXG4gICAgcmV0dXJuICRodHRwLmdldCgnYXBpL3F1ZXN0aW9ucy8nK3BhcmFtLm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICBpZihyZXNwb25zZS5kYXRhLnN1Y2Nlc3Mpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcclxuICAgICAgICAkcm9vdFNjb3BlLmxvYWRpbmdEYXRhPWZhbHNlO1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICBTaG93U2ltcGxlVG9hc3Quc2hvdyhyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9LGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgJHJvb3RTY29wZS5sb2FkaW5nRGF0YT1mYWxzZTtcclxuICAgICAgU2l0ZUVzc2VudGlhbHMucmVzcG9uc0NoZWNrKHJlc3BvbnNlKTtcclxuICAgIH0pXHJcbiAgfVxyXG50aGlzLmdldEFuc3dlcnM9ZnVuY3Rpb24ocmVwb3J0LHR5cGUpe1xyXG4gIGFuc3dlcnM9W107XHJcbiAgaWYodHlwZT09J25vX2NsYXNzJyl7XHJcbiAgICBhbmd1bGFyLmZvckVhY2gocmVwb3J0LnF1ZXN0aW9ucywgZnVuY3Rpb24odmFsdWUsIGtleSl7XHJcblxyXG4gICAgaWYodmFsdWUudHlwZSE9J2lucHV0Jyl2YWx1ZS5hbnN3ZXIuYW5zd2VyX2lkPXZhbHVlLmFuc3dlci5pZDtcclxuXHJcbiAgICAgIHZhbHVlLmFuc3dlci5xdWVzdGlvbl9pZD12YWx1ZS5pZDtcclxuICAgICAgYW5zd2Vycy5wdXNoKHZhbHVlLmFuc3dlcilcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gYW5zd2VycztcclxufVxyXG50aGlzLnN1Ym1pdEFuc3dlcj1mdW5jdGlvbihzY29wZSxhbnN3ZXIpe1xyXG4gICRyb290U2NvcGUubG9hZGluZ0RhdGE9dHJ1ZTtcclxuICAkaHR0cCh7dXJsOidhcGkvcXVlc3Rpb25zLycrc2NvcGUubmFtZSxtZXRob2Q6J1BPU1QnLGRhdGE6e2Fuc3dlcnM6YW5zd2VyfSxkYXRhVHlwZTonSlNPTid9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICRyb290U2NvcGUubG9hZGluZ0RhdGE9ZmFsc2U7XHJcbiAgICBpZihyZXNwb25zZS5kYXRhLnN1Y2Nlc3Mpe1xyXG4gICAgICAkc3RhdGUucmVsb2FkKCRzdGF0ZS5jdXJyZW50Lm5hbWUpO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG4gICAgU2hvd1NpbXBsZVRvYXN0LnNob3cocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcclxuICB9LGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICRyb290U2NvcGUubG9hZGluZ0RhdGE9ZmFsc2U7XHJcbiAgICBTaXRlRXNzZW50aWFscy5yZXNwb25zQ2hlY2socmVzcG9uc2UpO1xyXG4gIH0pXHJcbn1cclxuXHJcbn0pXHJcblxyXG5cclxuLmZhY3RvcnkoJ1NpdGVFc3NlbnRpYWxzJyxmdW5jdGlvbihTaG93U2ltcGxlVG9hc3Qpe1xyXG5cclxuICB2YXIgbWV0aG9kcz17fTtcclxuXHJcbiAgbWV0aG9kcy5yZXNwb25zQ2hlY2s9ZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgaWYocmVzcG9uc2Uuc3RhdHVzPT0tMSl7XHJcbiAgICAgICAgU2hvd1NpbXBsZVRvYXN0LnNob3dBbGVydCh0aGlzLCdUaW1lb3V0ISEnLCdOZXQgRXJyb3IgQ29ubmVjdGlvbiBUaW1vdXQnKTtcclxuICAgICAgfWVsc2UgaWYocmVzcG9uc2Uuc3RhdHVzPT01MDApe1xyXG4gICAgICAgIFNob3dTaW1wbGVUb2FzdC5zaG93QWxlcnQodGhpcyxyZXNwb25zZS5zdGF0dXNUZXh0LCdTb3JyeSB0aGVyZSBtaWdodCBiZSBhbiBpbnRlcm5hbCBzZXJ2ZXIgcHJvYmxlbSBwbGVhc2UgdHJ5IGFnYWluIGxhdGVyJyk7XHJcbiAgICAgIH1cclxuICB9XHJcbiAgbWV0aG9kcy5nb1RvcD1mdW5jdGlvbihpbmRleCl7XHJcbiAgICBpZihpbmRleD09dW5kZWZpbmVkfHxpbmRleD09bnVsbCl7XHJcbiAgICAgIGluZGV4PTBcclxuICAgIH1cclxuICAgICQoJ2JvZHksaHRtbCcpLmFuaW1hdGUoe3Njcm9sbFRvcDppbmRleH0sXCJzbG93XCIpO1xyXG4gIH1cclxuICBcclxuICBtZXRob2RzLmNsb25lSlNPTj1mdW5jdGlvbihvbGQpe1xyXG4gICAgdmFyIG5ld0pTT049e307XHJcbiAgICBhbmd1bGFyLmZvckVhY2gob2xkLGZ1bmN0aW9uKHZhbHVlLGtleSl7XHJcbiAgICAgXHJcbiAgICAgICAgbmV3SlNPTltrZXldPXZhbHVlO1xyXG4gICAgICBcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ld0pTT047XHJcbiAgfVxyXG4gIG1ldGhvZHMuZ2V0RGF0ZUZvcm1hdGU9ZnVuY3Rpb24oZGF0ZSl7XHJcbiAgICB2YXIgZGF0ZT1uZXcgRGF0ZShkYXRlKTtcclxuICAgIHZhciBtb250aD1kYXRlLmdldE1vbnRoKCkrMTtcclxuICAgIHZhciBkYXk9ZGF0ZS5nZXREYXRlKCk7XHJcbiAgICB2YXIgeWVhcj1kYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICBpZihtb250aDw9OSl7XHJcbiAgICAgIG1vbnRoPScwJyttb250aDtcclxuICAgIH1cclxuICAgIHJldHVybiB5ZWFyKyctJyttb250aCsnLScrZGF5O1xyXG4gIH1cclxuICBtZXRob2RzLmdldERhdGU9ZnVuY3Rpb24oZGF0ZSl7XHJcbiAgICBpZihkYXRlIT1udWxsKXtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgIHJldHVybiBuZXcgRGF0ZVxyXG4gICAgfVxyXG4gIH1cclxuIFxyXG4gbWV0aG9kcy5leHBhbmQ9ZnVuY3Rpb24oZGF0YSxpbmRleCxuYW1lLGRvdWJsZSxrZXlzKXtcclxuICAgICAgXHJcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLCBmdW5jdGlvbih2YWx1ZSwga2V5KXtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIGRvdWJsZSE9dW5kZWZpbmVkICYmZG91YmxlPT0xICYmIHR5cGVvZiBrZXlzICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHZhbCwgayl7XHJcbiAgICAgICAgICAgIGlmKGs9PWluZGV4JiZrZXk9PWtleXMpe1xyXG4gICAgICAgICAgICAgIHZhbFtuYW1lXT0hdmFsW25hbWVdO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICB2YWx1ZVtuYW1lXT1mYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgaWYoa2V5PT1pbmRleCl7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZVtuYW1lXT0hdmFsdWVbbmFtZV07XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdmFsdWVbbmFtZV09ZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgfSk7XHJcbiB9XHJcblxyXG4gbWV0aG9kcy5nZW5lcmF0ZU1lbnU9ZnVuY3Rpb24obWVudV9jb250ZW50KXtcclxuICB2YXIgZ2FsbGVyeT17XCLgppfgp43gpq/gpr7gprLgpr7gprDgp4BcIjpbe1xyXG4gICAgbmFtZTon4Kat4Ka/4Kah4Ka/4KaTIOCml+CnjeCmr+CmvuCmsuCmvuCmsOCngCcsXHJcbiAgICB1cmw6JyMvZ2FsbGVyeS92aWRlbycsXHJcbiAgICBwYXJlbnQ6J+Cml+CnjeCmr+CmvuCmsuCmvuCmsOCngCdcclxuICB9LFxyXG4gIHtcclxuICAgIG5hbWU6J+Cmq+Cmn+CniyDgppfgp43gpq/gpr7gprLgpr7gprDgp4AnLFxyXG4gICAgdXJsOicjL2dhbGxlcnkvaW1hZ2UnXHJcbiAgfV0sJ+CmruCmvuCmp+CnjeCmr+CmruCmv+CmlSDgpqrgp43gprDgpqTgpr/gprfgp43gpqDgpr7gpqgg4Ka44Kau4KeC4Ka54KeH4KawIOCmpOCmvuCmsuCmv+CmleCmvic6W1xyXG4gIHtuYW1lOifgprjgp43gppXgp4HgprInLHVybDonIy9pbnN0aXR1dGlvbi/gprjgp43gppXgp4HgprInLHBhcmVudDon4Kau4Ka+4Kan4KeN4Kav4Kau4Ka/4KaVIOCmquCnjeCmsOCmpOCmv+Cmt+CnjeCmoOCmvuCmqCDgprjgpq7gp4Lgprngp4fgprAg4Kak4Ka+4Kay4Ka/4KaV4Ka+J30sXHJcbiAge25hbWU6J+CmleCmsuCnh+CmnCcsdXJsOicjL2luc3RpdHV0aW9uL+CmleCmsuCnh+CmnCcscGFyZW50Oifgpq7gpr7gpqfgp43gpq/gpq7gpr/gppUg4Kaq4KeN4Kaw4Kak4Ka/4Ka34KeN4Kag4Ka+4KaoIOCmuOCmruCnguCmueCnh+CmsCDgpqTgpr7gprLgpr/gppXgpr4nfSxcclxuICB7bmFtZTon4Kau4Ka+4Kam4KeN4Kaw4Ka+4Ka44Ka+Jyx1cmw6JyMvaW5zdGl0dXRpb24v4Kau4Ka+4Kam4KeN4Kaw4Ka+4Ka44Ka+JyxwYXJlbnQ6J+CmruCmvuCmp+CnjeCmr+CmruCmv+CmlSDgpqrgp43gprDgpqTgpr/gprfgp43gpqDgpr7gpqgg4Ka44Kau4KeC4Ka54KeH4KawIOCmpOCmvuCmsuCmv+CmleCmvid9XHJcbiAgXVxyXG4gIH1cclxuXHJcbiAgdmFyIG1lbnU9W107XHJcbiAgdmFyIHRhYj1bXVxyXG4gIHRhYlswXT17bmFtZTon4Ka54KeL4KauJyx1cmw6JyMvJyxwYXJlbnQ6J+CmueCni+CmricsdHlwZTonaG9tZSd9XHJcbiAgdmFyIGk9MTtcclxuICB2YXIgY29udGFjdDtcclxuICAgIGlmKG1lbnVfY29udGVudCl7XHJcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaChtZW51X2NvbnRlbnQsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRhYltpXT1bXTtcclxuICAgICAgICBpZighdmFsdWUubGVuZ3RoKXtcclxuICAgICAgICAgIHRhYltpXT17cGFyZW50OmtleX1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoa2V5PT0n4Kav4KeL4KaX4Ka+4Kav4KeL4KaXJyYmIWNvbnRhY3QmJnR5cGVvZiB2YWx1ZVswXS50aXRsZSE9dW5kZWZpbmVkJiZ0eXBlb2YgdmFsdWVbMF0udGl0bGUhPW51bGwpe1xyXG4gICAgICAgICAgY29udGFjdD1jb250YWN0PXtuYW1lOnZhbHVlWzBdLnRpdGxlLHVybDonIy9wb3N0cy8nK3ZhbHVlWzBdLmlkLHBhcmVudDprZXl9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHZhbHVlLGZ1bmN0aW9uKHZhbCxrKXtcclxuICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKCF2YWwuaXNfZW1wbG95ZWUpe1xyXG4gICAgICAgICAgICAgICAgdGFiW2ldW2tdPXtuYW1lOnZhbC50aXRsZSx1cmw6JyMvcG9zdHMvJyt2YWwuaWQscGFyZW50OmtleX07XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgIHRhYltpXVtrXT17bmFtZTp2YWwuZGVzaWduYXRpb24sdXJsOicjL2VtcGxveWVlcy8nK3ZhbC5kZXNpZ25hdGlvbixwYXJlbnQ6a2V5fTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGkrKyBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcblxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGFuZ3VsYXIuZm9yRWFjaChnYWxsZXJ5LCBmdW5jdGlvbih2YWx1ZSwga2V5KXtcclxuICAgICAgdGFiW2ldPXZhbHVlO1xyXG4gICAgIFxyXG4gICAgICBpKys7XHJcbiAgICB9KTtcclxuICAgIHRhYltpXT1jb250YWN0O1xyXG5cclxuICAgIHJldHVybiB0YWI7XHJcbiB9XHJcbiBtZXRob2RzLnByb2Nlc3NGb3JtSW5wdXQ9ZnVuY3Rpb24oZGF0YSl7XHJcbiAgdmFyIGZvcm1fZGF0YT17fTtcclxuICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLCBmdW5jdGlvbih2YWx1ZSwga2V5KXtcclxuICAgICAgXHJcbiAgICAgIGZvcm1fZGF0YVtrZXldPXZhbHVlO1xyXG4gICAgICBpZihrZXk9PSdtcG9fZGF0ZScpe1xyXG4gICAgICAgIGZvcm1fZGF0YVtrZXldPW1ldGhvZHMuZ2V0RGF0ZUZvcm1hdGUodmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZm9ybV9kYXRhO1xyXG4gfVxyXG5cclxuICByZXR1cm4gbWV0aG9kcztcclxuXHJcbn0pXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL3N1cGVydmlzaW9uLmZhY3RvcnkuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\r\n\r\nangular.module('simpleAngularTicker', []).\r\ndirective('verticalTicker', function ($interval, $timeout) {\r\n    return {\r\n\r\n        restrict: 'A',\r\n        scope: true,\r\n        compile: function () {\r\n\r\n            return function (scope, element, attributes) {\r\n\r\n                var timing,\r\n                    timingEffect,\r\n                    timingEffectDivideBy = 4,\r\n                    isHovered = false,\r\n                    innerTime,\r\n                    start;\r\n\r\n                if (attributes.timing) {\r\n                    timing = attributes.timing;\r\n                    timingEffect = timing / timingEffectDivideBy;\r\n                } else {\r\n                    timing = 5000;\r\n                    timingEffect = timing / timingEffectDivideBy / timingEffectDivideBy * 2;\r\n                }\r\n\r\n                scope.$watch(element, function () {\r\n\r\n                    var list = element,\r\n                        items = element.find('li'),\r\n                        itemFirst;\r\n\r\n\r\n                    if (items.length) {\r\n                        list.addClass('active');\r\n\r\n                        start = $interval(function () {\r\n\r\n                            /*cancel the callback function for fade-out and makes the ticker steady.*/\r\n                            if (isHovered) {\r\n                                $timeout.cancel(innerTime);\r\n                                return;\r\n                            }\r\n\r\n                            items = list.children('li');\r\n                            itemFirst = angular.element(items[0]);\r\n\r\n                            itemFirst.addClass('fade-out minus-margin-top');\r\n\r\n                            $timeout(function () {\r\n                                itemFirst.removeClass('minus-margin-top');\r\n                                list.append(itemFirst);\r\n\r\n                                innerTime = $timeout(function () {\r\n                                    items.removeClass('fade-out');\r\n                                }, timingEffect);\r\n\r\n                            }, timingEffect);\r\n\r\n                        }, timing);\r\n\r\n                    } else {\r\n                        console.warn('no items assigned to ticker! Ensure you have correctly assigned items to your ng-repeat.');\r\n                    }\r\n\r\n                });\r\n\r\n                element.on('$destroy', function () {\r\n                    $interval.cancel(start, 0);\r\n                });\r\n\r\n                /* \r\n                 *author - mayo\r\n                 *checking for mouse enter the ticker region\r\n                 */\r\n                element.on('mouseenter', function () {\r\n                    isHovered = true;\r\n                });\r\n\r\n                /* \r\n                 *author - mayo\r\n                 *checking for mouse exit the ticker region\r\n                 */\r\n                element.on('mouseleave', function () {\r\n                    isHovered = false;\r\n                });\r\n\r\n            };\r\n        }\r\n\r\n    };\r\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy90aWNrZXIubWluLmpzP2QzMTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3NpbXBsZUFuZ3VsYXJUaWNrZXInLCBbXSkuXHJcbmRpcmVjdGl2ZSgndmVydGljYWxUaWNrZXInLCBmdW5jdGlvbiAoJGludGVydmFsLCAkdGltZW91dCkge1xyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgICAgICBzY29wZTogdHJ1ZSxcclxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWluZyxcclxuICAgICAgICAgICAgICAgICAgICB0aW1pbmdFZmZlY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgdGltaW5nRWZmZWN0RGl2aWRlQnkgPSA0LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzSG92ZXJlZCA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyVGltZSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy50aW1pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1pbmcgPSBhdHRyaWJ1dGVzLnRpbWluZztcclxuICAgICAgICAgICAgICAgICAgICB0aW1pbmdFZmZlY3QgPSB0aW1pbmcgLyB0aW1pbmdFZmZlY3REaXZpZGVCeTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltaW5nID0gNTAwMDtcclxuICAgICAgICAgICAgICAgICAgICB0aW1pbmdFZmZlY3QgPSB0aW1pbmcgLyB0aW1pbmdFZmZlY3REaXZpZGVCeSAvIHRpbWluZ0VmZmVjdERpdmlkZUJ5ICogMjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goZWxlbWVudCwgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IGVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gZWxlbWVudC5maW5kKCdsaScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtRmlyc3Q7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAkaW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qY2FuY2VsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZmFkZS1vdXQgYW5kIG1ha2VzIHRoZSB0aWNrZXIgc3RlYWR5LiovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNIb3ZlcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKGlubmVyVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gbGlzdC5jaGlsZHJlbignbGknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1GaXJzdCA9IGFuZ3VsYXIuZWxlbWVudChpdGVtc1swXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUZpcnN0LmFkZENsYXNzKCdmYWRlLW91dCBtaW51cy1tYXJnaW4tdG9wJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1GaXJzdC5yZW1vdmVDbGFzcygnbWludXMtbWFyZ2luLXRvcCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QuYXBwZW5kKGl0ZW1GaXJzdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVGltZSA9ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucmVtb3ZlQ2xhc3MoJ2ZhZGUtb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltaW5nRWZmZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aW1pbmdFZmZlY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltaW5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdubyBpdGVtcyBhc3NpZ25lZCB0byB0aWNrZXIhIEVuc3VyZSB5b3UgaGF2ZSBjb3JyZWN0bHkgYXNzaWduZWQgaXRlbXMgdG8geW91ciBuZy1yZXBlYXQuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQub24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICRpbnRlcnZhbC5jYW5jZWwoc3RhcnQsIDApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyogXHJcbiAgICAgICAgICAgICAgICAgKmF1dGhvciAtIG1heW9cclxuICAgICAgICAgICAgICAgICAqY2hlY2tpbmcgZm9yIG1vdXNlIGVudGVyIHRoZSB0aWNrZXIgcmVnaW9uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNIb3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIFxyXG4gICAgICAgICAgICAgICAgICphdXRob3IgLSBtYXlvXHJcbiAgICAgICAgICAgICAgICAgKmNoZWNraW5nIGZvciBtb3VzZSBleGl0IHRoZSB0aWNrZXIgcmVnaW9uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNIb3ZlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL3RpY2tlci5taW4uanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports) {

eval("/**!\n * AngularJS file upload directives and services. Supports: file upload/drop/paste, resume, cancel/abort,\n * progress, resize, thumbnail, preview, validation and CORS\n * FileAPI Flash shim for old browsers not supporting FormData\n * @author  Danial  <danial.farid@gmail.com>\n * @version 12.2.13\n */\n\n(function () {\n  /** @namespace FileAPI.noContentTimeout */\n\n  function patchXHR(fnName, newFn) {\n    window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]);\n  }\n\n  function redefineProp(xhr, prop, fn) {\n    try {\n      Object.defineProperty(xhr, prop, {get: fn});\n    } catch (e) {/*ignore*/\n    }\n  }\n\n  if (!window.FileAPI) {\n    window.FileAPI = {};\n  }\n\n  if (!window.XMLHttpRequest) {\n    throw 'AJAX is not supported. XMLHttpRequest is not defined.';\n  }\n\n  FileAPI.shouldLoad = !window.FormData || FileAPI.forceLoad;\n  if (FileAPI.shouldLoad) {\n    var initializeUploadListener = function (xhr) {\n      if (!xhr.__listeners) {\n        if (!xhr.upload) xhr.upload = {};\n        xhr.__listeners = [];\n        var origAddEventListener = xhr.upload.addEventListener;\n        xhr.upload.addEventListener = function (t, fn) {\n          xhr.__listeners[t] = fn;\n          if (origAddEventListener) origAddEventListener.apply(this, arguments);\n        };\n      }\n    };\n\n    patchXHR('open', function (orig) {\n      return function (m, url, b) {\n        initializeUploadListener(this);\n        this.__url = url;\n        try {\n          orig.apply(this, [m, url, b]);\n        } catch (e) {\n          if (e.message.indexOf('Access is denied') > -1) {\n            this.__origError = e;\n            orig.apply(this, [m, '_fix_for_ie_crossdomain__', b]);\n          }\n        }\n      };\n    });\n\n    patchXHR('getResponseHeader', function (orig) {\n      return function (h) {\n        return this.__fileApiXHR && this.__fileApiXHR.getResponseHeader ? this.__fileApiXHR.getResponseHeader(h) : (orig == null ? null : orig.apply(this, [h]));\n      };\n    });\n\n    patchXHR('getAllResponseHeaders', function (orig) {\n      return function () {\n        return this.__fileApiXHR && this.__fileApiXHR.getAllResponseHeaders ? this.__fileApiXHR.getAllResponseHeaders() : (orig == null ? null : orig.apply(this));\n      };\n    });\n\n    patchXHR('abort', function (orig) {\n      return function () {\n        return this.__fileApiXHR && this.__fileApiXHR.abort ? this.__fileApiXHR.abort() : (orig == null ? null : orig.apply(this));\n      };\n    });\n\n    patchXHR('setRequestHeader', function (orig) {\n      return function (header, value) {\n        if (header === '__setXHR_') {\n          initializeUploadListener(this);\n          var val = value(this);\n          // fix for angular < 1.2.0\n          if (val instanceof Function) {\n            val(this);\n          }\n        } else {\n          this.__requestHeaders = this.__requestHeaders || {};\n          this.__requestHeaders[header] = value;\n          orig.apply(this, arguments);\n        }\n      };\n    });\n\n    patchXHR('send', function (orig) {\n      return function () {\n        var xhr = this;\n        if (arguments[0] && arguments[0].__isFileAPIShim) {\n          var formData = arguments[0];\n          var config = {\n            url: xhr.__url,\n            jsonp: false, //removes the callback form param\n            cache: true, //removes the ?fileapiXXX in the url\n            complete: function (err, fileApiXHR) {\n              if (err && angular.isString(err) && err.indexOf('#2174') !== -1) {\n                // this error seems to be fine the file is being uploaded properly.\n                err = null;\n              }\n              xhr.__completed = true;\n              if (!err && xhr.__listeners.load)\n                xhr.__listeners.load({\n                  type: 'load',\n                  loaded: xhr.__loaded,\n                  total: xhr.__total,\n                  target: xhr,\n                  lengthComputable: true\n                });\n              if (!err && xhr.__listeners.loadend)\n                xhr.__listeners.loadend({\n                  type: 'loadend',\n                  loaded: xhr.__loaded,\n                  total: xhr.__total,\n                  target: xhr,\n                  lengthComputable: true\n                });\n              if (err === 'abort' && xhr.__listeners.abort)\n                xhr.__listeners.abort({\n                  type: 'abort',\n                  loaded: xhr.__loaded,\n                  total: xhr.__total,\n                  target: xhr,\n                  lengthComputable: true\n                });\n              if (fileApiXHR.status !== undefined) redefineProp(xhr, 'status', function () {\n                return (fileApiXHR.status === 0 && err && err !== 'abort') ? 500 : fileApiXHR.status;\n              });\n              if (fileApiXHR.statusText !== undefined) redefineProp(xhr, 'statusText', function () {\n                return fileApiXHR.statusText;\n              });\n              redefineProp(xhr, 'readyState', function () {\n                return 4;\n              });\n              if (fileApiXHR.response !== undefined) redefineProp(xhr, 'response', function () {\n                return fileApiXHR.response;\n              });\n              var resp = fileApiXHR.responseText || (err && fileApiXHR.status === 0 && err !== 'abort' ? err : undefined);\n              redefineProp(xhr, 'responseText', function () {\n                return resp;\n              });\n              redefineProp(xhr, 'response', function () {\n                return resp;\n              });\n              if (err) redefineProp(xhr, 'err', function () {\n                return err;\n              });\n              xhr.__fileApiXHR = fileApiXHR;\n              if (xhr.onreadystatechange) xhr.onreadystatechange();\n              if (xhr.onload) xhr.onload();\n            },\n            progress: function (e) {\n              e.target = xhr;\n              if (xhr.__listeners.progress) xhr.__listeners.progress(e);\n              xhr.__total = e.total;\n              xhr.__loaded = e.loaded;\n              if (e.total === e.loaded) {\n                // fix flash issue that doesn't call complete if there is no response text from the server\n                var _this = this;\n                setTimeout(function () {\n                  if (!xhr.__completed) {\n                    xhr.getAllResponseHeaders = function () {\n                    };\n                    _this.complete(null, {status: 204, statusText: 'No Content'});\n                  }\n                }, FileAPI.noContentTimeout || 10000);\n              }\n            },\n            headers: xhr.__requestHeaders\n          };\n          config.data = {};\n          config.files = {};\n          for (var i = 0; i < formData.data.length; i++) {\n            var item = formData.data[i];\n            if (item.val != null && item.val.name != null && item.val.size != null && item.val.type != null) {\n              config.files[item.key] = item.val;\n            } else {\n              config.data[item.key] = item.val;\n            }\n          }\n\n          setTimeout(function () {\n            if (!FileAPI.hasFlash) {\n              throw 'Adode Flash Player need to be installed. To check ahead use \"FileAPI.hasFlash\"';\n            }\n            xhr.__fileApiXHR = FileAPI.upload(config);\n          }, 1);\n        } else {\n          if (this.__origError) {\n            throw this.__origError;\n          }\n          orig.apply(xhr, arguments);\n        }\n      };\n    });\n    window.XMLHttpRequest.__isFileAPIShim = true;\n    window.FormData = FormData = function () {\n      return {\n        append: function (key, val, name) {\n          if (val.__isFileAPIBlobShim) {\n            val = val.data[0];\n          }\n          this.data.push({\n            key: key,\n            val: val,\n            name: name\n          });\n        },\n        data: [],\n        __isFileAPIShim: true\n      };\n    };\n\n    window.Blob = Blob = function (b) {\n      return {\n        data: b,\n        __isFileAPIBlobShim: true\n      };\n    };\n  }\n\n})();\n\n(function () {\n  /** @namespace FileAPI.forceLoad */\n  /** @namespace window.FileAPI.jsUrl */\n  /** @namespace window.FileAPI.jsPath */\n\n  function isInputTypeFile(elem) {\n    return elem[0].tagName.toLowerCase() === 'input' && elem.attr('type') && elem.attr('type').toLowerCase() === 'file';\n  }\n\n  function hasFlash() {\n    try {\n      var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');\n      if (fo) return true;\n    } catch (e) {\n      if (navigator.mimeTypes['application/x-shockwave-flash'] !== undefined) return true;\n    }\n    return false;\n  }\n\n  function getOffset(obj) {\n    var left = 0, top = 0;\n\n    if (window.jQuery) {\n      return jQuery(obj).offset();\n    }\n\n    if (obj.offsetParent) {\n      do {\n        left += (obj.offsetLeft - obj.scrollLeft);\n        top += (obj.offsetTop - obj.scrollTop);\n        obj = obj.offsetParent;\n      } while (obj);\n    }\n    return {\n      left: left,\n      top: top\n    };\n  }\n\n  if (FileAPI.shouldLoad) {\n    FileAPI.hasFlash = hasFlash();\n\n    //load FileAPI\n    if (FileAPI.forceLoad) {\n      FileAPI.html5 = false;\n    }\n\n    if (!FileAPI.upload) {\n      var jsUrl, basePath, script = document.createElement('script'), allScripts = document.getElementsByTagName('script'), i, index, src;\n      if (window.FileAPI.jsUrl) {\n        jsUrl = window.FileAPI.jsUrl;\n      } else if (window.FileAPI.jsPath) {\n        basePath = window.FileAPI.jsPath;\n      } else {\n        for (i = 0; i < allScripts.length; i++) {\n          src = allScripts[i].src;\n          index = src.search(/\\/ng\\-file\\-upload[\\-a-zA-z0-9\\.]*\\.js/);\n          if (index > -1) {\n            basePath = src.substring(0, index + 1);\n            break;\n          }\n        }\n      }\n\n      if (FileAPI.staticPath == null) FileAPI.staticPath = basePath;\n      script.setAttribute('src', jsUrl || basePath + 'FileAPI.min.js');\n      document.getElementsByTagName('head')[0].appendChild(script);\n    }\n\n    FileAPI.ngfFixIE = function (elem, fileElem, changeFn) {\n      if (!hasFlash()) {\n        throw 'Adode Flash Player need to be installed. To check ahead use \"FileAPI.hasFlash\"';\n      }\n      var fixInputStyle = function () {\n        var label = fileElem.parent();\n        if (elem.attr('disabled')) {\n          if (label) label.removeClass('js-fileapi-wrapper');\n        } else {\n          if (!fileElem.attr('__ngf_flash_')) {\n            fileElem.unbind('change');\n            fileElem.unbind('click');\n            fileElem.bind('change', function (evt) {\n              fileApiChangeFn.apply(this, [evt]);\n              changeFn.apply(this, [evt]);\n            });\n            fileElem.attr('__ngf_flash_', 'true');\n          }\n          label.addClass('js-fileapi-wrapper');\n          if (!isInputTypeFile(elem)) {\n            label.css('position', 'absolute')\n              .css('top', getOffset(elem[0]).top + 'px').css('left', getOffset(elem[0]).left + 'px')\n              .css('width', elem[0].offsetWidth + 'px').css('height', elem[0].offsetHeight + 'px')\n              .css('filter', 'alpha(opacity=0)').css('display', elem.css('display'))\n              .css('overflow', 'hidden').css('z-index', '900000')\n              .css('visibility', 'visible');\n            fileElem.css('width', elem[0].offsetWidth + 'px').css('height', elem[0].offsetHeight + 'px')\n              .css('position', 'absolute').css('top', '0px').css('left', '0px');\n          }\n        }\n      };\n\n      elem.bind('mouseenter', fixInputStyle);\n\n      var fileApiChangeFn = function (evt) {\n        var files = FileAPI.getFiles(evt);\n        //just a double check for #233\n        for (var i = 0; i < files.length; i++) {\n          if (files[i].size === undefined) files[i].size = 0;\n          if (files[i].name === undefined) files[i].name = 'file';\n          if (files[i].type === undefined) files[i].type = 'undefined';\n        }\n        if (!evt.target) {\n          evt.target = {};\n        }\n        evt.target.files = files;\n        // if evt.target.files is not writable use helper field\n        if (evt.target.files !== files) {\n          evt.__files_ = files;\n        }\n        (evt.__files_ || evt.target.files).item = function (i) {\n          return (evt.__files_ || evt.target.files)[i] || null;\n        };\n      };\n    };\n\n    FileAPI.disableFileInput = function (elem, disable) {\n      if (disable) {\n        elem.removeClass('js-fileapi-wrapper');\n      } else {\n        elem.addClass('js-fileapi-wrapper');\n      }\n    };\n  }\n})();\n\nif (!window.FileReader) {\n  window.FileReader = function () {\n    var _this = this, loadStarted = false;\n    this.listeners = {};\n    this.addEventListener = function (type, fn) {\n      _this.listeners[type] = _this.listeners[type] || [];\n      _this.listeners[type].push(fn);\n    };\n    this.removeEventListener = function (type, fn) {\n      if (_this.listeners[type]) _this.listeners[type].splice(_this.listeners[type].indexOf(fn), 1);\n    };\n    this.dispatchEvent = function (evt) {\n      var list = _this.listeners[evt.type];\n      if (list) {\n        for (var i = 0; i < list.length; i++) {\n          list[i].call(_this, evt);\n        }\n      }\n    };\n    this.onabort = this.onerror = this.onload = this.onloadstart = this.onloadend = this.onprogress = null;\n\n    var constructEvent = function (type, evt) {\n      var e = {type: type, target: _this, loaded: evt.loaded, total: evt.total, error: evt.error};\n      if (evt.result != null) e.target.result = evt.result;\n      return e;\n    };\n    var listener = function (evt) {\n      if (!loadStarted) {\n        loadStarted = true;\n        if (_this.onloadstart) _this.onloadstart(constructEvent('loadstart', evt));\n      }\n      var e;\n      if (evt.type === 'load') {\n        if (_this.onloadend) _this.onloadend(constructEvent('loadend', evt));\n        e = constructEvent('load', evt);\n        if (_this.onload) _this.onload(e);\n        _this.dispatchEvent(e);\n      } else if (evt.type === 'progress') {\n        e = constructEvent('progress', evt);\n        if (_this.onprogress) _this.onprogress(e);\n        _this.dispatchEvent(e);\n      } else {\n        e = constructEvent('error', evt);\n        if (_this.onerror) _this.onerror(e);\n        _this.dispatchEvent(e);\n      }\n    };\n    this.readAsDataURL = function (file) {\n      FileAPI.readAsDataURL(file, listener);\n    };\n    this.readAsText = function (file) {\n      FileAPI.readAsText(file, listener);\n    };\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L25nLWZpbGUtdXBsb2FkL2Rpc3QvbmctZmlsZS11cGxvYWQtc2hpbS5qcz9jMjNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiAqIEFuZ3VsYXJKUyBmaWxlIHVwbG9hZCBkaXJlY3RpdmVzIGFuZCBzZXJ2aWNlcy4gU3VwcG9ydHM6IGZpbGUgdXBsb2FkL2Ryb3AvcGFzdGUsIHJlc3VtZSwgY2FuY2VsL2Fib3J0LFxuICogcHJvZ3Jlc3MsIHJlc2l6ZSwgdGh1bWJuYWlsLCBwcmV2aWV3LCB2YWxpZGF0aW9uIGFuZCBDT1JTXG4gKiBGaWxlQVBJIEZsYXNoIHNoaW0gZm9yIG9sZCBicm93c2VycyBub3Qgc3VwcG9ydGluZyBGb3JtRGF0YVxuICogQGF1dGhvciAgRGFuaWFsICA8ZGFuaWFsLmZhcmlkQGdtYWlsLmNvbT5cbiAqIEB2ZXJzaW9uIDEyLjIuMTNcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICAvKiogQG5hbWVzcGFjZSBGaWxlQVBJLm5vQ29udGVudFRpbWVvdXQgKi9cblxuICBmdW5jdGlvbiBwYXRjaFhIUihmbk5hbWUsIG5ld0ZuKSB7XG4gICAgd2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZVtmbk5hbWVdID0gbmV3Rm4od2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZVtmbk5hbWVdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZGVmaW5lUHJvcCh4aHIsIHByb3AsIGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4aHIsIHByb3AsIHtnZXQ6IGZufSk7XG4gICAgfSBjYXRjaCAoZSkgey8qaWdub3JlKi9cbiAgICB9XG4gIH1cblxuICBpZiAoIXdpbmRvdy5GaWxlQVBJKSB7XG4gICAgd2luZG93LkZpbGVBUEkgPSB7fTtcbiAgfVxuXG4gIGlmICghd2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgdGhyb3cgJ0FKQVggaXMgbm90IHN1cHBvcnRlZC4gWE1MSHR0cFJlcXVlc3QgaXMgbm90IGRlZmluZWQuJztcbiAgfVxuXG4gIEZpbGVBUEkuc2hvdWxkTG9hZCA9ICF3aW5kb3cuRm9ybURhdGEgfHwgRmlsZUFQSS5mb3JjZUxvYWQ7XG4gIGlmIChGaWxlQVBJLnNob3VsZExvYWQpIHtcbiAgICB2YXIgaW5pdGlhbGl6ZVVwbG9hZExpc3RlbmVyID0gZnVuY3Rpb24gKHhocikge1xuICAgICAgaWYgKCF4aHIuX19saXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKCF4aHIudXBsb2FkKSB4aHIudXBsb2FkID0ge307XG4gICAgICAgIHhoci5fX2xpc3RlbmVycyA9IFtdO1xuICAgICAgICB2YXIgb3JpZ0FkZEV2ZW50TGlzdGVuZXIgPSB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0LCBmbikge1xuICAgICAgICAgIHhoci5fX2xpc3RlbmVyc1t0XSA9IGZuO1xuICAgICAgICAgIGlmIChvcmlnQWRkRXZlbnRMaXN0ZW5lcikgb3JpZ0FkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcGF0Y2hYSFIoJ29wZW4nLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtLCB1cmwsIGIpIHtcbiAgICAgICAgaW5pdGlhbGl6ZVVwbG9hZExpc3RlbmVyKHRoaXMpO1xuICAgICAgICB0aGlzLl9fdXJsID0gdXJsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9yaWcuYXBwbHkodGhpcywgW20sIHVybCwgYl0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUubWVzc2FnZS5pbmRleE9mKCdBY2Nlc3MgaXMgZGVuaWVkJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdFcnJvciA9IGU7XG4gICAgICAgICAgICBvcmlnLmFwcGx5KHRoaXMsIFttLCAnX2ZpeF9mb3JfaWVfY3Jvc3Nkb21haW5fXycsIGJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBwYXRjaFhIUignZ2V0UmVzcG9uc2VIZWFkZXInLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsZUFwaVhIUiAmJiB0aGlzLl9fZmlsZUFwaVhIUi5nZXRSZXNwb25zZUhlYWRlciA/IHRoaXMuX19maWxlQXBpWEhSLmdldFJlc3BvbnNlSGVhZGVyKGgpIDogKG9yaWcgPT0gbnVsbCA/IG51bGwgOiBvcmlnLmFwcGx5KHRoaXMsIFtoXSkpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHBhdGNoWEhSKCdnZXRBbGxSZXNwb25zZUhlYWRlcnMnLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWxlQXBpWEhSICYmIHRoaXMuX19maWxlQXBpWEhSLmdldEFsbFJlc3BvbnNlSGVhZGVycyA/IHRoaXMuX19maWxlQXBpWEhSLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIDogKG9yaWcgPT0gbnVsbCA/IG51bGwgOiBvcmlnLmFwcGx5KHRoaXMpKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBwYXRjaFhIUignYWJvcnQnLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWxlQXBpWEhSICYmIHRoaXMuX19maWxlQXBpWEhSLmFib3J0ID8gdGhpcy5fX2ZpbGVBcGlYSFIuYWJvcnQoKSA6IChvcmlnID09IG51bGwgPyBudWxsIDogb3JpZy5hcHBseSh0aGlzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcGF0Y2hYSFIoJ3NldFJlcXVlc3RIZWFkZXInLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChoZWFkZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmIChoZWFkZXIgPT09ICdfX3NldFhIUl8nKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZVVwbG9hZExpc3RlbmVyKHRoaXMpO1xuICAgICAgICAgIHZhciB2YWwgPSB2YWx1ZSh0aGlzKTtcbiAgICAgICAgICAvLyBmaXggZm9yIGFuZ3VsYXIgPCAxLjIuMFxuICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fcmVxdWVzdEhlYWRlcnMgPSB0aGlzLl9fcmVxdWVzdEhlYWRlcnMgfHwge307XG4gICAgICAgICAgdGhpcy5fX3JlcXVlc3RIZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICAgICAgICBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBwYXRjaFhIUignc2VuZCcsIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeGhyID0gdGhpcztcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0uX19pc0ZpbGVBUElTaGltKSB7XG4gICAgICAgICAgdmFyIGZvcm1EYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICB1cmw6IHhoci5fX3VybCxcbiAgICAgICAgICAgIGpzb25wOiBmYWxzZSwgLy9yZW1vdmVzIHRoZSBjYWxsYmFjayBmb3JtIHBhcmFtXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSwgLy9yZW1vdmVzIHRoZSA/ZmlsZWFwaVhYWCBpbiB0aGUgdXJsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKGVyciwgZmlsZUFwaVhIUikge1xuICAgICAgICAgICAgICBpZiAoZXJyICYmIGFuZ3VsYXIuaXNTdHJpbmcoZXJyKSAmJiBlcnIuaW5kZXhPZignIzIxNzQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGVycm9yIHNlZW1zIHRvIGJlIGZpbmUgdGhlIGZpbGUgaXMgYmVpbmcgdXBsb2FkZWQgcHJvcGVybHkuXG4gICAgICAgICAgICAgICAgZXJyID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB4aHIuX19jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoIWVyciAmJiB4aHIuX19saXN0ZW5lcnMubG9hZClcbiAgICAgICAgICAgICAgICB4aHIuX19saXN0ZW5lcnMubG9hZCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnbG9hZCcsXG4gICAgICAgICAgICAgICAgICBsb2FkZWQ6IHhoci5fX2xvYWRlZCxcbiAgICAgICAgICAgICAgICAgIHRvdGFsOiB4aHIuX190b3RhbCxcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogeGhyLFxuICAgICAgICAgICAgICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIWVyciAmJiB4aHIuX19saXN0ZW5lcnMubG9hZGVuZClcbiAgICAgICAgICAgICAgICB4aHIuX19saXN0ZW5lcnMubG9hZGVuZCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnbG9hZGVuZCcsXG4gICAgICAgICAgICAgICAgICBsb2FkZWQ6IHhoci5fX2xvYWRlZCxcbiAgICAgICAgICAgICAgICAgIHRvdGFsOiB4aHIuX190b3RhbCxcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogeGhyLFxuICAgICAgICAgICAgICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoZXJyID09PSAnYWJvcnQnICYmIHhoci5fX2xpc3RlbmVycy5hYm9ydClcbiAgICAgICAgICAgICAgICB4aHIuX19saXN0ZW5lcnMuYWJvcnQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2Fib3J0JyxcbiAgICAgICAgICAgICAgICAgIGxvYWRlZDogeGhyLl9fbG9hZGVkLFxuICAgICAgICAgICAgICAgICAgdG90YWw6IHhoci5fX3RvdGFsLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB4aHIsXG4gICAgICAgICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChmaWxlQXBpWEhSLnN0YXR1cyAhPT0gdW5kZWZpbmVkKSByZWRlZmluZVByb3AoeGhyLCAnc3RhdHVzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZmlsZUFwaVhIUi5zdGF0dXMgPT09IDAgJiYgZXJyICYmIGVyciAhPT0gJ2Fib3J0JykgPyA1MDAgOiBmaWxlQXBpWEhSLnN0YXR1cztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChmaWxlQXBpWEhSLnN0YXR1c1RleHQgIT09IHVuZGVmaW5lZCkgcmVkZWZpbmVQcm9wKHhociwgJ3N0YXR1c1RleHQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVBcGlYSFIuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlZGVmaW5lUHJvcCh4aHIsICdyZWFkeVN0YXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGZpbGVBcGlYSFIucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkgcmVkZWZpbmVQcm9wKHhociwgJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlQXBpWEhSLnJlc3BvbnNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIHJlc3AgPSBmaWxlQXBpWEhSLnJlc3BvbnNlVGV4dCB8fCAoZXJyICYmIGZpbGVBcGlYSFIuc3RhdHVzID09PSAwICYmIGVyciAhPT0gJ2Fib3J0JyA/IGVyciA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIHJlZGVmaW5lUHJvcCh4aHIsICdyZXNwb25zZVRleHQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZWRlZmluZVByb3AoeGhyLCAncmVzcG9uc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoZXJyKSByZWRlZmluZVByb3AoeGhyLCAnZXJyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB4aHIuX19maWxlQXBpWEhSID0gZmlsZUFwaVhIUjtcbiAgICAgICAgICAgICAgaWYgKHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UpIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcbiAgICAgICAgICAgICAgaWYgKHhoci5vbmxvYWQpIHhoci5vbmxvYWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9ncmVzczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZS50YXJnZXQgPSB4aHI7XG4gICAgICAgICAgICAgIGlmICh4aHIuX19saXN0ZW5lcnMucHJvZ3Jlc3MpIHhoci5fX2xpc3RlbmVycy5wcm9ncmVzcyhlKTtcbiAgICAgICAgICAgICAgeGhyLl9fdG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgICB4aHIuX19sb2FkZWQgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgICAgaWYgKGUudG90YWwgPT09IGUubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZml4IGZsYXNoIGlzc3VlIHRoYXQgZG9lc24ndCBjYWxsIGNvbXBsZXRlIGlmIHRoZXJlIGlzIG5vIHJlc3BvbnNlIHRleHQgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgheGhyLl9fY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG51bGwsIHtzdGF0dXM6IDIwNCwgc3RhdHVzVGV4dDogJ05vIENvbnRlbnQnfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgRmlsZUFQSS5ub0NvbnRlbnRUaW1lb3V0IHx8IDEwMDAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHhoci5fX3JlcXVlc3RIZWFkZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25maWcuZGF0YSA9IHt9O1xuICAgICAgICAgIGNvbmZpZy5maWxlcyA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybURhdGEuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBmb3JtRGF0YS5kYXRhW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0udmFsICE9IG51bGwgJiYgaXRlbS52YWwubmFtZSAhPSBudWxsICYmIGl0ZW0udmFsLnNpemUgIT0gbnVsbCAmJiBpdGVtLnZhbC50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uZmlnLmZpbGVzW2l0ZW0ua2V5XSA9IGl0ZW0udmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uZmlnLmRhdGFbaXRlbS5rZXldID0gaXRlbS52YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIUZpbGVBUEkuaGFzRmxhc2gpIHtcbiAgICAgICAgICAgICAgdGhyb3cgJ0Fkb2RlIEZsYXNoIFBsYXllciBuZWVkIHRvIGJlIGluc3RhbGxlZC4gVG8gY2hlY2sgYWhlYWQgdXNlIFwiRmlsZUFQSS5oYXNGbGFzaFwiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhoci5fX2ZpbGVBcGlYSFIgPSBGaWxlQVBJLnVwbG9hZChjb25maWcpO1xuICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLl9fb3JpZ0Vycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9fb3JpZ0Vycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcmlnLmFwcGx5KHhociwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB3aW5kb3cuWE1MSHR0cFJlcXVlc3QuX19pc0ZpbGVBUElTaGltID0gdHJ1ZTtcbiAgICB3aW5kb3cuRm9ybURhdGEgPSBGb3JtRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24gKGtleSwgdmFsLCBuYW1lKSB7XG4gICAgICAgICAgaWYgKHZhbC5fX2lzRmlsZUFQSUJsb2JTaGltKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuZGF0YVswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2goe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIF9faXNGaWxlQVBJU2hpbTogdHJ1ZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgd2luZG93LkJsb2IgPSBCbG9iID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGIsXG4gICAgICAgIF9faXNGaWxlQVBJQmxvYlNoaW06IHRydWVcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAvKiogQG5hbWVzcGFjZSBGaWxlQVBJLmZvcmNlTG9hZCAqL1xuICAvKiogQG5hbWVzcGFjZSB3aW5kb3cuRmlsZUFQSS5qc1VybCAqL1xuICAvKiogQG5hbWVzcGFjZSB3aW5kb3cuRmlsZUFQSS5qc1BhdGggKi9cblxuICBmdW5jdGlvbiBpc0lucHV0VHlwZUZpbGUoZWxlbSkge1xuICAgIHJldHVybiBlbGVtWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiBlbGVtLmF0dHIoJ3R5cGUnKSAmJiBlbGVtLmF0dHIoJ3R5cGUnKS50b0xvd2VyQ2FzZSgpID09PSAnZmlsZSc7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNGbGFzaCgpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGZvID0gbmV3IEFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJyk7XG4gICAgICBpZiAoZm8pIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChuYXZpZ2F0b3IubWltZVR5cGVzWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddICE9PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPZmZzZXQob2JqKSB7XG4gICAgdmFyIGxlZnQgPSAwLCB0b3AgPSAwO1xuXG4gICAgaWYgKHdpbmRvdy5qUXVlcnkpIHtcbiAgICAgIHJldHVybiBqUXVlcnkob2JqKS5vZmZzZXQoKTtcbiAgICB9XG5cbiAgICBpZiAob2JqLm9mZnNldFBhcmVudCkge1xuICAgICAgZG8ge1xuICAgICAgICBsZWZ0ICs9IChvYmoub2Zmc2V0TGVmdCAtIG9iai5zY3JvbGxMZWZ0KTtcbiAgICAgICAgdG9wICs9IChvYmoub2Zmc2V0VG9wIC0gb2JqLnNjcm9sbFRvcCk7XG4gICAgICAgIG9iaiA9IG9iai5vZmZzZXRQYXJlbnQ7XG4gICAgICB9IHdoaWxlIChvYmopO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHRvcDogdG9wXG4gICAgfTtcbiAgfVxuXG4gIGlmIChGaWxlQVBJLnNob3VsZExvYWQpIHtcbiAgICBGaWxlQVBJLmhhc0ZsYXNoID0gaGFzRmxhc2goKTtcblxuICAgIC8vbG9hZCBGaWxlQVBJXG4gICAgaWYgKEZpbGVBUEkuZm9yY2VMb2FkKSB7XG4gICAgICBGaWxlQVBJLmh0bWw1ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFGaWxlQVBJLnVwbG9hZCkge1xuICAgICAgdmFyIGpzVXJsLCBiYXNlUGF0aCwgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksIGFsbFNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JyksIGksIGluZGV4LCBzcmM7XG4gICAgICBpZiAod2luZG93LkZpbGVBUEkuanNVcmwpIHtcbiAgICAgICAganNVcmwgPSB3aW5kb3cuRmlsZUFQSS5qc1VybDtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93LkZpbGVBUEkuanNQYXRoKSB7XG4gICAgICAgIGJhc2VQYXRoID0gd2luZG93LkZpbGVBUEkuanNQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbFNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzcmMgPSBhbGxTY3JpcHRzW2ldLnNyYztcbiAgICAgICAgICBpbmRleCA9IHNyYy5zZWFyY2goL1xcL25nXFwtZmlsZVxcLXVwbG9hZFtcXC1hLXpBLXowLTlcXC5dKlxcLmpzLyk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGJhc2VQYXRoID0gc3JjLnN1YnN0cmluZygwLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChGaWxlQVBJLnN0YXRpY1BhdGggPT0gbnVsbCkgRmlsZUFQSS5zdGF0aWNQYXRoID0gYmFzZVBhdGg7XG4gICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdzcmMnLCBqc1VybCB8fCBiYXNlUGF0aCArICdGaWxlQVBJLm1pbi5qcycpO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH1cblxuICAgIEZpbGVBUEkubmdmRml4SUUgPSBmdW5jdGlvbiAoZWxlbSwgZmlsZUVsZW0sIGNoYW5nZUZuKSB7XG4gICAgICBpZiAoIWhhc0ZsYXNoKCkpIHtcbiAgICAgICAgdGhyb3cgJ0Fkb2RlIEZsYXNoIFBsYXllciBuZWVkIHRvIGJlIGluc3RhbGxlZC4gVG8gY2hlY2sgYWhlYWQgdXNlIFwiRmlsZUFQSS5oYXNGbGFzaFwiJztcbiAgICAgIH1cbiAgICAgIHZhciBmaXhJbnB1dFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFiZWwgPSBmaWxlRWxlbS5wYXJlbnQoKTtcbiAgICAgICAgaWYgKGVsZW0uYXR0cignZGlzYWJsZWQnKSkge1xuICAgICAgICAgIGlmIChsYWJlbCkgbGFiZWwucmVtb3ZlQ2xhc3MoJ2pzLWZpbGVhcGktd3JhcHBlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghZmlsZUVsZW0uYXR0cignX19uZ2ZfZmxhc2hfJykpIHtcbiAgICAgICAgICAgIGZpbGVFbGVtLnVuYmluZCgnY2hhbmdlJyk7XG4gICAgICAgICAgICBmaWxlRWxlbS51bmJpbmQoJ2NsaWNrJyk7XG4gICAgICAgICAgICBmaWxlRWxlbS5iaW5kKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgIGZpbGVBcGlDaGFuZ2VGbi5hcHBseSh0aGlzLCBbZXZ0XSk7XG4gICAgICAgICAgICAgIGNoYW5nZUZuLmFwcGx5KHRoaXMsIFtldnRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmlsZUVsZW0uYXR0cignX19uZ2ZfZmxhc2hfJywgJ3RydWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFiZWwuYWRkQ2xhc3MoJ2pzLWZpbGVhcGktd3JhcHBlcicpO1xuICAgICAgICAgIGlmICghaXNJbnB1dFR5cGVGaWxlKGVsZW0pKSB7XG4gICAgICAgICAgICBsYWJlbC5jc3MoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJylcbiAgICAgICAgICAgICAgLmNzcygndG9wJywgZ2V0T2Zmc2V0KGVsZW1bMF0pLnRvcCArICdweCcpLmNzcygnbGVmdCcsIGdldE9mZnNldChlbGVtWzBdKS5sZWZ0ICsgJ3B4JylcbiAgICAgICAgICAgICAgLmNzcygnd2lkdGgnLCBlbGVtWzBdLm9mZnNldFdpZHRoICsgJ3B4JykuY3NzKCdoZWlnaHQnLCBlbGVtWzBdLm9mZnNldEhlaWdodCArICdweCcpXG4gICAgICAgICAgICAgIC5jc3MoJ2ZpbHRlcicsICdhbHBoYShvcGFjaXR5PTApJykuY3NzKCdkaXNwbGF5JywgZWxlbS5jc3MoJ2Rpc3BsYXknKSlcbiAgICAgICAgICAgICAgLmNzcygnb3ZlcmZsb3cnLCAnaGlkZGVuJykuY3NzKCd6LWluZGV4JywgJzkwMDAwMCcpXG4gICAgICAgICAgICAgIC5jc3MoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgZmlsZUVsZW0uY3NzKCd3aWR0aCcsIGVsZW1bMF0ub2Zmc2V0V2lkdGggKyAncHgnKS5jc3MoJ2hlaWdodCcsIGVsZW1bMF0ub2Zmc2V0SGVpZ2h0ICsgJ3B4JylcbiAgICAgICAgICAgICAgLmNzcygncG9zaXRpb24nLCAnYWJzb2x1dGUnKS5jc3MoJ3RvcCcsICcwcHgnKS5jc3MoJ2xlZnQnLCAnMHB4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBlbGVtLmJpbmQoJ21vdXNlZW50ZXInLCBmaXhJbnB1dFN0eWxlKTtcblxuICAgICAgdmFyIGZpbGVBcGlDaGFuZ2VGbiA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gRmlsZUFQSS5nZXRGaWxlcyhldnQpO1xuICAgICAgICAvL2p1c3QgYSBkb3VibGUgY2hlY2sgZm9yICMyMzNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChmaWxlc1tpXS5zaXplID09PSB1bmRlZmluZWQpIGZpbGVzW2ldLnNpemUgPSAwO1xuICAgICAgICAgIGlmIChmaWxlc1tpXS5uYW1lID09PSB1bmRlZmluZWQpIGZpbGVzW2ldLm5hbWUgPSAnZmlsZSc7XG4gICAgICAgICAgaWYgKGZpbGVzW2ldLnR5cGUgPT09IHVuZGVmaW5lZCkgZmlsZXNbaV0udHlwZSA9ICd1bmRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXZ0LnRhcmdldCkge1xuICAgICAgICAgIGV2dC50YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBldnQudGFyZ2V0LmZpbGVzID0gZmlsZXM7XG4gICAgICAgIC8vIGlmIGV2dC50YXJnZXQuZmlsZXMgaXMgbm90IHdyaXRhYmxlIHVzZSBoZWxwZXIgZmllbGRcbiAgICAgICAgaWYgKGV2dC50YXJnZXQuZmlsZXMgIT09IGZpbGVzKSB7XG4gICAgICAgICAgZXZ0Ll9fZmlsZXNfID0gZmlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgKGV2dC5fX2ZpbGVzXyB8fCBldnQudGFyZ2V0LmZpbGVzKS5pdGVtID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gKGV2dC5fX2ZpbGVzXyB8fCBldnQudGFyZ2V0LmZpbGVzKVtpXSB8fCBudWxsO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgRmlsZUFQSS5kaXNhYmxlRmlsZUlucHV0ID0gZnVuY3Rpb24gKGVsZW0sIGRpc2FibGUpIHtcbiAgICAgIGlmIChkaXNhYmxlKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoJ2pzLWZpbGVhcGktd3JhcHBlcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5hZGRDbGFzcygnanMtZmlsZWFwaS13cmFwcGVyJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSkoKTtcblxuaWYgKCF3aW5kb3cuRmlsZVJlYWRlcikge1xuICB3aW5kb3cuRmlsZVJlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLCBsb2FkU3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgICBfdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBfdGhpcy5saXN0ZW5lcnNbdHlwZV0gfHwgW107XG4gICAgICBfdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChmbik7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICAgIGlmIChfdGhpcy5saXN0ZW5lcnNbdHlwZV0pIF90aGlzLmxpc3RlbmVyc1t0eXBlXS5zcGxpY2UoX3RoaXMubGlzdGVuZXJzW3R5cGVdLmluZGV4T2YoZm4pLCAxKTtcbiAgICB9O1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHZhciBsaXN0ID0gX3RoaXMubGlzdGVuZXJzW2V2dC50eXBlXTtcbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxpc3RbaV0uY2FsbChfdGhpcywgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbmFib3J0ID0gdGhpcy5vbmVycm9yID0gdGhpcy5vbmxvYWQgPSB0aGlzLm9ubG9hZHN0YXJ0ID0gdGhpcy5vbmxvYWRlbmQgPSB0aGlzLm9ucHJvZ3Jlc3MgPSBudWxsO1xuXG4gICAgdmFyIGNvbnN0cnVjdEV2ZW50ID0gZnVuY3Rpb24gKHR5cGUsIGV2dCkge1xuICAgICAgdmFyIGUgPSB7dHlwZTogdHlwZSwgdGFyZ2V0OiBfdGhpcywgbG9hZGVkOiBldnQubG9hZGVkLCB0b3RhbDogZXZ0LnRvdGFsLCBlcnJvcjogZXZ0LmVycm9yfTtcbiAgICAgIGlmIChldnQucmVzdWx0ICE9IG51bGwpIGUudGFyZ2V0LnJlc3VsdCA9IGV2dC5yZXN1bHQ7XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmICghbG9hZFN0YXJ0ZWQpIHtcbiAgICAgICAgbG9hZFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoX3RoaXMub25sb2Fkc3RhcnQpIF90aGlzLm9ubG9hZHN0YXJ0KGNvbnN0cnVjdEV2ZW50KCdsb2Fkc3RhcnQnLCBldnQpKTtcbiAgICAgIH1cbiAgICAgIHZhciBlO1xuICAgICAgaWYgKGV2dC50eXBlID09PSAnbG9hZCcpIHtcbiAgICAgICAgaWYgKF90aGlzLm9ubG9hZGVuZCkgX3RoaXMub25sb2FkZW5kKGNvbnN0cnVjdEV2ZW50KCdsb2FkZW5kJywgZXZ0KSk7XG4gICAgICAgIGUgPSBjb25zdHJ1Y3RFdmVudCgnbG9hZCcsIGV2dCk7XG4gICAgICAgIGlmIChfdGhpcy5vbmxvYWQpIF90aGlzLm9ubG9hZChlKTtcbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZ0LnR5cGUgPT09ICdwcm9ncmVzcycpIHtcbiAgICAgICAgZSA9IGNvbnN0cnVjdEV2ZW50KCdwcm9ncmVzcycsIGV2dCk7XG4gICAgICAgIGlmIChfdGhpcy5vbnByb2dyZXNzKSBfdGhpcy5vbnByb2dyZXNzKGUpO1xuICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZSA9IGNvbnN0cnVjdEV2ZW50KCdlcnJvcicsIGV2dCk7XG4gICAgICAgIGlmIChfdGhpcy5vbmVycm9yKSBfdGhpcy5vbmVycm9yKGUpO1xuICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZWFkQXNEYXRhVVJMID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgIEZpbGVBUEkucmVhZEFzRGF0YVVSTChmaWxlLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICB0aGlzLnJlYWRBc1RleHQgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgRmlsZUFQSS5yZWFkQXNUZXh0KGZpbGUsIGxpc3RlbmVyKTtcbiAgICB9O1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25nLWZpbGUtdXBsb2FkL2Rpc3QvbmctZmlsZS11cGxvYWQtc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports) {

eval("/**!\n * AngularJS file upload directives and services. Supoorts: file upload/drop/paste, resume, cancel/abort,\n * progress, resize, thumbnail, preview, validation and CORS\n * @author  Danial  <danial.farid@gmail.com>\n * @version 12.2.13\n */\n\nif (window.XMLHttpRequest && !(window.FileAPI && FileAPI.shouldLoad)) {\n  window.XMLHttpRequest.prototype.setRequestHeader = (function (orig) {\n    return function (header, value) {\n      if (header === '__setXHR_') {\n        var val = value(this);\n        // fix for angular < 1.2.0\n        if (val instanceof Function) {\n          val(this);\n        }\n      } else {\n        orig.apply(this, arguments);\n      }\n    };\n  })(window.XMLHttpRequest.prototype.setRequestHeader);\n}\n\nvar ngFileUpload = angular.module('ngFileUpload', []);\n\nngFileUpload.version = '12.2.13';\n\nngFileUpload.service('UploadBase', ['$http', '$q', '$timeout', function ($http, $q, $timeout) {\n  var upload = this;\n  upload.promisesCount = 0;\n\n  this.isResumeSupported = function () {\n    return window.Blob && window.Blob.prototype.slice;\n  };\n\n  var resumeSupported = this.isResumeSupported();\n\n  function sendHttp(config) {\n    config.method = config.method || 'POST';\n    config.headers = config.headers || {};\n\n    var deferred = config._deferred = config._deferred || $q.defer();\n    var promise = deferred.promise;\n\n    function notifyProgress(e) {\n      if (deferred.notify) {\n        deferred.notify(e);\n      }\n      if (promise.progressFunc) {\n        $timeout(function () {\n          promise.progressFunc(e);\n        });\n      }\n    }\n\n    function getNotifyEvent(n) {\n      if (config._start != null && resumeSupported) {\n        return {\n          loaded: n.loaded + config._start,\n          total: (config._file && config._file.size) || n.total,\n          type: n.type, config: config,\n          lengthComputable: true, target: n.target\n        };\n      } else {\n        return n;\n      }\n    }\n\n    if (!config.disableProgress) {\n      config.headers.__setXHR_ = function () {\n        return function (xhr) {\n          if (!xhr || !xhr.upload || !xhr.upload.addEventListener) return;\n          config.__XHR = xhr;\n          if (config.xhrFn) config.xhrFn(xhr);\n          xhr.upload.addEventListener('progress', function (e) {\n            e.config = config;\n            notifyProgress(getNotifyEvent(e));\n          }, false);\n          //fix for firefox not firing upload progress end, also IE8-9\n          xhr.upload.addEventListener('load', function (e) {\n            if (e.lengthComputable) {\n              e.config = config;\n              notifyProgress(getNotifyEvent(e));\n            }\n          }, false);\n        };\n      };\n    }\n\n    function uploadWithAngular() {\n      $http(config).then(function (r) {\n          if (resumeSupported && config._chunkSize && !config._finished && config._file) {\n            var fileSize = config._file && config._file.size || 0;\n            notifyProgress({\n                loaded: Math.min(config._end, fileSize),\n                total: fileSize,\n                config: config,\n                type: 'progress'\n              }\n            );\n            upload.upload(config, true);\n          } else {\n            if (config._finished) delete config._finished;\n            deferred.resolve(r);\n          }\n        }, function (e) {\n          deferred.reject(e);\n        }, function (n) {\n          deferred.notify(n);\n        }\n      );\n    }\n\n    if (!resumeSupported) {\n      uploadWithAngular();\n    } else if (config._chunkSize && config._end && !config._finished) {\n      config._start = config._end;\n      config._end += config._chunkSize;\n      uploadWithAngular();\n    } else if (config.resumeSizeUrl) {\n      $http.get(config.resumeSizeUrl).then(function (resp) {\n        if (config.resumeSizeResponseReader) {\n          config._start = config.resumeSizeResponseReader(resp.data);\n        } else {\n          config._start = parseInt((resp.data.size == null ? resp.data : resp.data.size).toString());\n        }\n        if (config._chunkSize) {\n          config._end = config._start + config._chunkSize;\n        }\n        uploadWithAngular();\n      }, function (e) {\n        throw e;\n      });\n    } else if (config.resumeSize) {\n      config.resumeSize().then(function (size) {\n        config._start = size;\n        if (config._chunkSize) {\n          config._end = config._start + config._chunkSize;\n        }\n        uploadWithAngular();\n      }, function (e) {\n        throw e;\n      });\n    } else {\n      if (config._chunkSize) {\n        config._start = 0;\n        config._end = config._start + config._chunkSize;\n      }\n      uploadWithAngular();\n    }\n\n\n    promise.success = function (fn) {\n      promise.then(function (response) {\n        fn(response.data, response.status, response.headers, config);\n      });\n      return promise;\n    };\n\n    promise.error = function (fn) {\n      promise.then(null, function (response) {\n        fn(response.data, response.status, response.headers, config);\n      });\n      return promise;\n    };\n\n    promise.progress = function (fn) {\n      promise.progressFunc = fn;\n      promise.then(null, null, function (n) {\n        fn(n);\n      });\n      return promise;\n    };\n    promise.abort = promise.pause = function () {\n      if (config.__XHR) {\n        $timeout(function () {\n          config.__XHR.abort();\n        });\n      }\n      return promise;\n    };\n    promise.xhr = function (fn) {\n      config.xhrFn = (function (origXhrFn) {\n        return function () {\n          if (origXhrFn) origXhrFn.apply(promise, arguments);\n          fn.apply(promise, arguments);\n        };\n      })(config.xhrFn);\n      return promise;\n    };\n\n    upload.promisesCount++;\n    if (promise['finally'] && promise['finally'] instanceof Function) {\n      promise['finally'](function () {\n        upload.promisesCount--;\n      });\n    }\n    return promise;\n  }\n\n  this.isUploadInProgress = function () {\n    return upload.promisesCount > 0;\n  };\n\n  this.rename = function (file, name) {\n    file.ngfName = name;\n    return file;\n  };\n\n  this.jsonBlob = function (val) {\n    if (val != null && !angular.isString(val)) {\n      val = JSON.stringify(val);\n    }\n    var blob = new window.Blob([val], {type: 'application/json'});\n    blob._ngfBlob = true;\n    return blob;\n  };\n\n  this.json = function (val) {\n    return angular.toJson(val);\n  };\n\n  function copy(obj) {\n    var clone = {};\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        clone[key] = obj[key];\n      }\n    }\n    return clone;\n  }\n\n  this.isFile = function (file) {\n    return file != null && (file instanceof window.Blob || (file.flashId && file.name && file.size));\n  };\n\n  this.upload = function (config, internal) {\n    function toResumeFile(file, formData) {\n      if (file._ngfBlob) return file;\n      config._file = config._file || file;\n      if (config._start != null && resumeSupported) {\n        if (config._end && config._end >= file.size) {\n          config._finished = true;\n          config._end = file.size;\n        }\n        var slice = file.slice(config._start, config._end || file.size);\n        slice.name = file.name;\n        slice.ngfName = file.ngfName;\n        if (config._chunkSize) {\n          formData.append('_chunkSize', config._chunkSize);\n          formData.append('_currentChunkSize', config._end - config._start);\n          formData.append('_chunkNumber', Math.floor(config._start / config._chunkSize));\n          formData.append('_totalSize', config._file.size);\n        }\n        return slice;\n      }\n      return file;\n    }\n\n    function addFieldToFormData(formData, val, key) {\n      if (val !== undefined) {\n        if (angular.isDate(val)) {\n          val = val.toISOString();\n        }\n        if (angular.isString(val)) {\n          formData.append(key, val);\n        } else if (upload.isFile(val)) {\n          var file = toResumeFile(val, formData);\n          var split = key.split(',');\n          if (split[1]) {\n            file.ngfName = split[1].replace(/^\\s+|\\s+$/g, '');\n            key = split[0];\n          }\n          config._fileKey = config._fileKey || key;\n          formData.append(key, file, file.ngfName || file.name);\n        } else {\n          if (angular.isObject(val)) {\n            if (val.$$ngfCircularDetection) throw 'ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: ' + key;\n\n            val.$$ngfCircularDetection = true;\n            try {\n              for (var k in val) {\n                if (val.hasOwnProperty(k) && k !== '$$ngfCircularDetection') {\n                  var objectKey = config.objectKey == null ? '[i]' : config.objectKey;\n                  if (val.length && parseInt(k) > -1) {\n                    objectKey = config.arrayKey == null ? objectKey : config.arrayKey;\n                  }\n                  addFieldToFormData(formData, val[k], key + objectKey.replace(/[ik]/g, k));\n                }\n              }\n            } finally {\n              delete val.$$ngfCircularDetection;\n            }\n          } else {\n            formData.append(key, val);\n          }\n        }\n      }\n    }\n\n    function digestConfig() {\n      config._chunkSize = upload.translateScalars(config.resumeChunkSize);\n      config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;\n\n      config.headers = config.headers || {};\n      config.headers['Content-Type'] = undefined;\n      config.transformRequest = config.transformRequest ?\n        (angular.isArray(config.transformRequest) ?\n          config.transformRequest : [config.transformRequest]) : [];\n      config.transformRequest.push(function (data) {\n        var formData = new window.FormData(), key;\n        data = data || config.fields || {};\n        if (config.file) {\n          data.file = config.file;\n        }\n        for (key in data) {\n          if (data.hasOwnProperty(key)) {\n            var val = data[key];\n            if (config.formDataAppender) {\n              config.formDataAppender(formData, key, val);\n            } else {\n              addFieldToFormData(formData, val, key);\n            }\n          }\n        }\n\n        return formData;\n      });\n    }\n\n    if (!internal) config = copy(config);\n    if (!config._isDigested) {\n      config._isDigested = true;\n      digestConfig();\n    }\n\n    return sendHttp(config);\n  };\n\n  this.http = function (config) {\n    config = copy(config);\n    config.transformRequest = config.transformRequest || function (data) {\n        if ((window.ArrayBuffer && data instanceof window.ArrayBuffer) || data instanceof window.Blob) {\n          return data;\n        }\n        return $http.defaults.transformRequest[0].apply(this, arguments);\n      };\n    config._chunkSize = upload.translateScalars(config.resumeChunkSize);\n    config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;\n\n    return sendHttp(config);\n  };\n\n  this.translateScalars = function (str) {\n    if (angular.isString(str)) {\n      if (str.search(/kb/i) === str.length - 2) {\n        return parseFloat(str.substring(0, str.length - 2) * 1024);\n      } else if (str.search(/mb/i) === str.length - 2) {\n        return parseFloat(str.substring(0, str.length - 2) * 1048576);\n      } else if (str.search(/gb/i) === str.length - 2) {\n        return parseFloat(str.substring(0, str.length - 2) * 1073741824);\n      } else if (str.search(/b/i) === str.length - 1) {\n        return parseFloat(str.substring(0, str.length - 1));\n      } else if (str.search(/s/i) === str.length - 1) {\n        return parseFloat(str.substring(0, str.length - 1));\n      } else if (str.search(/m/i) === str.length - 1) {\n        return parseFloat(str.substring(0, str.length - 1) * 60);\n      } else if (str.search(/h/i) === str.length - 1) {\n        return parseFloat(str.substring(0, str.length - 1) * 3600);\n      }\n    }\n    return str;\n  };\n\n  this.urlToBlob = function(url) {\n    var defer = $q.defer();\n    $http({url: url, method: 'get', responseType: 'arraybuffer'}).then(function (resp) {\n      var arrayBufferView = new Uint8Array(resp.data);\n      var type = resp.headers('content-type') || 'image/WebP';\n      var blob = new window.Blob([arrayBufferView], {type: type});\n      var matches = url.match(/.*\\/(.+?)(\\?.*)?$/);\n      if (matches.length > 1) {\n        blob.name = matches[1];\n      }\n      defer.resolve(blob);\n    }, function (e) {\n      defer.reject(e);\n    });\n    return defer.promise;\n  };\n\n  this.setDefaults = function (defaults) {\n    this.defaults = defaults || {};\n  };\n\n  this.defaults = {};\n  this.version = ngFileUpload.version;\n}\n\n]);\n\nngFileUpload.service('Upload', ['$parse', '$timeout', '$compile', '$q', 'UploadExif', function ($parse, $timeout, $compile, $q, UploadExif) {\n  var upload = UploadExif;\n  upload.getAttrWithDefaults = function (attr, name) {\n    if (attr[name] != null) return attr[name];\n    var def = upload.defaults[name];\n    return (def == null ? def : (angular.isString(def) ? def : JSON.stringify(def)));\n  };\n\n  upload.attrGetter = function (name, attr, scope, params) {\n    var attrVal = this.getAttrWithDefaults(attr, name);\n    if (scope) {\n      try {\n        if (params) {\n          return $parse(attrVal)(scope, params);\n        } else {\n          return $parse(attrVal)(scope);\n        }\n      } catch (e) {\n        // hangle string value without single qoute\n        if (name.search(/min|max|pattern/i)) {\n          return attrVal;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      return attrVal;\n    }\n  };\n\n  upload.shouldUpdateOn = function (type, attr, scope) {\n    var modelOptions = upload.attrGetter('ngfModelOptions', attr, scope);\n    if (modelOptions && modelOptions.updateOn) {\n      return modelOptions.updateOn.split(' ').indexOf(type) > -1;\n    }\n    return true;\n  };\n\n  upload.emptyPromise = function () {\n    var d = $q.defer();\n    var args = arguments;\n    $timeout(function () {\n      d.resolve.apply(d, args);\n    });\n    return d.promise;\n  };\n\n  upload.rejectPromise = function () {\n    var d = $q.defer();\n    var args = arguments;\n    $timeout(function () {\n      d.reject.apply(d, args);\n    });\n    return d.promise;\n  };\n\n  upload.happyPromise = function (promise, data) {\n    var d = $q.defer();\n    promise.then(function (result) {\n      d.resolve(result);\n    }, function (error) {\n      $timeout(function () {\n        throw error;\n      });\n      d.resolve(data);\n    });\n    return d.promise;\n  };\n\n  function applyExifRotations(files, attr, scope) {\n    var promises = [upload.emptyPromise()];\n    angular.forEach(files, function (f, i) {\n      if (f.type.indexOf('image/jpeg') === 0 && upload.attrGetter('ngfFixOrientation', attr, scope, {$file: f})) {\n        promises.push(upload.happyPromise(upload.applyExifRotation(f), f).then(function (fixedFile) {\n          files.splice(i, 1, fixedFile);\n        }));\n      }\n    });\n    return $q.all(promises);\n  }\n\n  function resizeFile(files, attr, scope, ngModel) {\n    var resizeVal = upload.attrGetter('ngfResize', attr, scope);\n    if (!resizeVal || !upload.isResizeSupported() || !files.length) return upload.emptyPromise();\n    if (resizeVal instanceof Function) {\n      var defer = $q.defer();\n      return resizeVal(files).then(function (p) {\n        resizeWithParams(p, files, attr, scope, ngModel).then(function (r) {\n          defer.resolve(r);\n        }, function (e) {\n          defer.reject(e);\n        });\n      }, function (e) {\n        defer.reject(e);\n      });\n    } else {\n      return resizeWithParams(resizeVal, files, attr, scope, ngModel);\n    }\n  }\n\n  function resizeWithParams(params, files, attr, scope, ngModel) {\n    var promises = [upload.emptyPromise()];\n\n    function handleFile(f, i) {\n      if (f.type.indexOf('image') === 0) {\n        if (params.pattern && !upload.validatePattern(f, params.pattern)) return;\n        params.resizeIf = function (width, height) {\n          return upload.attrGetter('ngfResizeIf', attr, scope,\n            {$width: width, $height: height, $file: f});\n        };\n        var promise = upload.resize(f, params);\n        promises.push(promise);\n        promise.then(function (resizedFile) {\n          files.splice(i, 1, resizedFile);\n        }, function (e) {\n          f.$error = 'resize';\n          (f.$errorMessages = (f.$errorMessages || {})).resize = true;\n          f.$errorParam = (e ? (e.message ? e.message : e) + ': ' : '') + (f && f.name);\n          ngModel.$ngfValidations.push({name: 'resize', valid: false});\n          upload.applyModelValidation(ngModel, files);\n        });\n      }\n    }\n\n    for (var i = 0; i < files.length; i++) {\n      handleFile(files[i], i);\n    }\n    return $q.all(promises);\n  }\n\n  upload.updateModel = function (ngModel, attr, scope, fileChange, files, evt, noDelay) {\n    function update(files, invalidFiles, newFiles, dupFiles, isSingleModel) {\n      attr.$$ngfPrevValidFiles = files;\n      attr.$$ngfPrevInvalidFiles = invalidFiles;\n      var file = files && files.length ? files[0] : null;\n      var invalidFile = invalidFiles && invalidFiles.length ? invalidFiles[0] : null;\n\n      if (ngModel) {\n        upload.applyModelValidation(ngModel, files);\n        ngModel.$setViewValue(isSingleModel ? file : files);\n      }\n\n      if (fileChange) {\n        $parse(fileChange)(scope, {\n          $files: files,\n          $file: file,\n          $newFiles: newFiles,\n          $duplicateFiles: dupFiles,\n          $invalidFiles: invalidFiles,\n          $invalidFile: invalidFile,\n          $event: evt\n        });\n      }\n\n      var invalidModel = upload.attrGetter('ngfModelInvalid', attr);\n      if (invalidModel) {\n        $timeout(function () {\n          $parse(invalidModel).assign(scope, isSingleModel ? invalidFile : invalidFiles);\n        });\n      }\n      $timeout(function () {\n        // scope apply changes\n      });\n    }\n\n    var allNewFiles, dupFiles = [], prevValidFiles, prevInvalidFiles,\n      invalids = [], valids = [];\n\n    function removeDuplicates() {\n      function equals(f1, f2) {\n        return f1.name === f2.name && (f1.$ngfOrigSize || f1.size) === (f2.$ngfOrigSize || f2.size) &&\n          f1.type === f2.type;\n      }\n\n      function isInPrevFiles(f) {\n        var j;\n        for (j = 0; j < prevValidFiles.length; j++) {\n          if (equals(f, prevValidFiles[j])) {\n            return true;\n          }\n        }\n        for (j = 0; j < prevInvalidFiles.length; j++) {\n          if (equals(f, prevInvalidFiles[j])) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      if (files) {\n        allNewFiles = [];\n        dupFiles = [];\n        for (var i = 0; i < files.length; i++) {\n          if (isInPrevFiles(files[i])) {\n            dupFiles.push(files[i]);\n          } else {\n            allNewFiles.push(files[i]);\n          }\n        }\n      }\n    }\n\n    function toArray(v) {\n      return angular.isArray(v) ? v : [v];\n    }\n\n    function resizeAndUpdate() {\n      function updateModel() {\n        $timeout(function () {\n          update(keep ? prevValidFiles.concat(valids) : valids,\n            keep ? prevInvalidFiles.concat(invalids) : invalids,\n            files, dupFiles, isSingleModel);\n        }, options && options.debounce ? options.debounce.change || options.debounce : 0);\n      }\n\n      var resizingFiles = validateAfterResize ? allNewFiles : valids;\n      resizeFile(resizingFiles, attr, scope, ngModel).then(function () {\n        if (validateAfterResize) {\n          upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)\n            .then(function (validationResult) {\n              valids = validationResult.validsFiles;\n              invalids = validationResult.invalidsFiles;\n              updateModel();\n            });\n        } else {\n          updateModel();\n        }\n      }, function () {\n        for (var i = 0; i < resizingFiles.length; i++) {\n          var f = resizingFiles[i];\n          if (f.$error === 'resize') {\n            var index = valids.indexOf(f);\n            if (index > -1) {\n              valids.splice(index, 1);\n              invalids.push(f);\n            }\n            updateModel();\n          }\n        }\n      });\n    }\n\n    prevValidFiles = attr.$$ngfPrevValidFiles || [];\n    prevInvalidFiles = attr.$$ngfPrevInvalidFiles || [];\n    if (ngModel && ngModel.$modelValue) {\n      prevValidFiles = toArray(ngModel.$modelValue);\n    }\n\n    var keep = upload.attrGetter('ngfKeep', attr, scope);\n    allNewFiles = (files || []).slice(0);\n    if (keep === 'distinct' || upload.attrGetter('ngfKeepDistinct', attr, scope) === true) {\n      removeDuplicates(attr, scope);\n    }\n\n    var isSingleModel = !keep && !upload.attrGetter('ngfMultiple', attr, scope) && !upload.attrGetter('multiple', attr);\n\n    if (keep && !allNewFiles.length) return;\n\n    upload.attrGetter('ngfBeforeModelChange', attr, scope, {\n      $files: files,\n      $file: files && files.length ? files[0] : null,\n      $newFiles: allNewFiles,\n      $duplicateFiles: dupFiles,\n      $event: evt\n    });\n\n    var validateAfterResize = upload.attrGetter('ngfValidateAfterResize', attr, scope);\n\n    var options = upload.attrGetter('ngfModelOptions', attr, scope);\n    upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)\n      .then(function (validationResult) {\n      if (noDelay) {\n        update(allNewFiles, [], files, dupFiles, isSingleModel);\n      } else {\n        if ((!options || !options.allowInvalid) && !validateAfterResize) {\n          valids = validationResult.validFiles;\n          invalids = validationResult.invalidFiles;\n        } else {\n          valids = allNewFiles;\n        }\n        if (upload.attrGetter('ngfFixOrientation', attr, scope) && upload.isExifSupported()) {\n          applyExifRotations(valids, attr, scope).then(function () {\n            resizeAndUpdate();\n          });\n        } else {\n          resizeAndUpdate();\n        }\n      }\n    });\n  };\n\n  return upload;\n}]);\n\nngFileUpload.directive('ngfSelect', ['$parse', '$timeout', '$compile', 'Upload', function ($parse, $timeout, $compile, Upload) {\n  var generatedElems = [];\n\n  function isDelayedClickSupported(ua) {\n    // fix for android native browser < 4.4 and safari windows\n    var m = ua.match(/Android[^\\d]*(\\d+)\\.(\\d+)/);\n    if (m && m.length > 2) {\n      var v = Upload.defaults.androidFixMinorVersion || 4;\n      return parseInt(m[1]) < 4 || (parseInt(m[1]) === v && parseInt(m[2]) < v);\n    }\n\n    // safari on windows\n    return ua.indexOf('Chrome') === -1 && /.*Windows.*Safari.*/.test(ua);\n  }\n\n  function linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, upload) {\n    /** @namespace attr.ngfSelect */\n    /** @namespace attr.ngfChange */\n    /** @namespace attr.ngModel */\n    /** @namespace attr.ngfModelOptions */\n    /** @namespace attr.ngfMultiple */\n    /** @namespace attr.ngfCapture */\n    /** @namespace attr.ngfValidate */\n    /** @namespace attr.ngfKeep */\n    var attrGetter = function (name, scope) {\n      return upload.attrGetter(name, attr, scope);\n    };\n\n    function isInputTypeFile() {\n      return elem[0].tagName.toLowerCase() === 'input' && attr.type && attr.type.toLowerCase() === 'file';\n    }\n\n    function fileChangeAttr() {\n      return attrGetter('ngfChange') || attrGetter('ngfSelect');\n    }\n\n    function changeFn(evt) {\n      if (upload.shouldUpdateOn('change', attr, scope)) {\n        var fileList = evt.__files_ || (evt.target && evt.target.files), files = [];\n        /* Handle duplicate call in  IE11 */\n        if (!fileList) return;\n        for (var i = 0; i < fileList.length; i++) {\n          files.push(fileList[i]);\n        }\n        upload.updateModel(ngModel, attr, scope, fileChangeAttr(),\n          files.length ? files : null, evt);\n      }\n    }\n\n    upload.registerModelChangeValidator(ngModel, attr, scope);\n\n    var unwatches = [];\n    if (attrGetter('ngfMultiple')) {\n      unwatches.push(scope.$watch(attrGetter('ngfMultiple'), function () {\n        fileElem.attr('multiple', attrGetter('ngfMultiple', scope));\n      }));\n    }\n    if (attrGetter('ngfCapture')) {\n      unwatches.push(scope.$watch(attrGetter('ngfCapture'), function () {\n        fileElem.attr('capture', attrGetter('ngfCapture', scope));\n      }));\n    }\n    if (attrGetter('ngfAccept')) {\n      unwatches.push(scope.$watch(attrGetter('ngfAccept'), function () {\n        fileElem.attr('accept', attrGetter('ngfAccept', scope));\n      }));\n    }\n    unwatches.push(attr.$observe('accept', function () {\n      fileElem.attr('accept', attrGetter('accept'));\n    }));\n    function bindAttrToFileInput(fileElem, label) {\n      function updateId(val) {\n        fileElem.attr('id', 'ngf-' + val);\n        label.attr('id', 'ngf-label-' + val);\n      }\n\n      for (var i = 0; i < elem[0].attributes.length; i++) {\n        var attribute = elem[0].attributes[i];\n        if (attribute.name !== 'type' && attribute.name !== 'class' && attribute.name !== 'style') {\n          if (attribute.name === 'id') {\n            updateId(attribute.value);\n            unwatches.push(attr.$observe('id', updateId));\n          } else {\n            fileElem.attr(attribute.name, (!attribute.value && (attribute.name === 'required' ||\n            attribute.name === 'multiple')) ? attribute.name : attribute.value);\n          }\n        }\n      }\n    }\n\n    function createFileInput() {\n      if (isInputTypeFile()) {\n        return elem;\n      }\n\n      var fileElem = angular.element('<input type=\"file\">');\n\n      var label = angular.element('<label>upload</label>');\n      label.css('visibility', 'hidden').css('position', 'absolute').css('overflow', 'hidden')\n        .css('width', '0px').css('height', '0px').css('border', 'none')\n        .css('margin', '0px').css('padding', '0px').attr('tabindex', '-1');\n      bindAttrToFileInput(fileElem, label);\n\n      generatedElems.push({el: elem, ref: label});\n\n      document.body.appendChild(label.append(fileElem)[0]);\n\n      return fileElem;\n    }\n\n    function clickHandler(evt) {\n      if (elem.attr('disabled')) return false;\n      if (attrGetter('ngfSelectDisabled', scope)) return;\n\n      var r = detectSwipe(evt);\n      // prevent the click if it is a swipe\n      if (r != null) return r;\n\n      resetModel(evt);\n\n      // fix for md when the element is removed from the DOM and added back #460\n      try {\n        if (!isInputTypeFile() && !document.body.contains(fileElem[0])) {\n          generatedElems.push({el: elem, ref: fileElem.parent()});\n          document.body.appendChild(fileElem.parent()[0]);\n          fileElem.bind('change', changeFn);\n        }\n      } catch (e) {/*ignore*/\n      }\n\n      if (isDelayedClickSupported(navigator.userAgent)) {\n        setTimeout(function () {\n          fileElem[0].click();\n        }, 0);\n      } else {\n        fileElem[0].click();\n      }\n\n      return false;\n    }\n\n\n    var initialTouchStartY = 0;\n    var initialTouchStartX = 0;\n\n    function detectSwipe(evt) {\n      var touches = evt.changedTouches || (evt.originalEvent && evt.originalEvent.changedTouches);\n      if (touches) {\n        if (evt.type === 'touchstart') {\n          initialTouchStartX = touches[0].clientX;\n          initialTouchStartY = touches[0].clientY;\n          return true; // don't block event default\n        } else {\n          // prevent scroll from triggering event\n          if (evt.type === 'touchend') {\n            var currentX = touches[0].clientX;\n            var currentY = touches[0].clientY;\n            if ((Math.abs(currentX - initialTouchStartX) > 20) ||\n              (Math.abs(currentY - initialTouchStartY) > 20)) {\n              evt.stopPropagation();\n              evt.preventDefault();\n              return false;\n            }\n          }\n          return true;\n        }\n      }\n    }\n\n    var fileElem = elem;\n\n    function resetModel(evt) {\n      if (upload.shouldUpdateOn('click', attr, scope) && fileElem.val()) {\n        fileElem.val(null);\n        upload.updateModel(ngModel, attr, scope, fileChangeAttr(), null, evt, true);\n      }\n    }\n\n    if (!isInputTypeFile()) {\n      fileElem = createFileInput();\n    }\n    fileElem.bind('change', changeFn);\n\n    if (!isInputTypeFile()) {\n      elem.bind('click touchstart touchend', clickHandler);\n    } else {\n      elem.bind('click', resetModel);\n    }\n\n    function ie10SameFileSelectFix(evt) {\n      if (fileElem && !fileElem.attr('__ngf_ie10_Fix_')) {\n        if (!fileElem[0].parentNode) {\n          fileElem = null;\n          return;\n        }\n        evt.preventDefault();\n        evt.stopPropagation();\n        fileElem.unbind('click');\n        var clone = fileElem.clone();\n        fileElem.replaceWith(clone);\n        fileElem = clone;\n        fileElem.attr('__ngf_ie10_Fix_', 'true');\n        fileElem.bind('change', changeFn);\n        fileElem.bind('click', ie10SameFileSelectFix);\n        fileElem[0].click();\n        return false;\n      } else {\n        fileElem.removeAttr('__ngf_ie10_Fix_');\n      }\n    }\n\n    if (navigator.appVersion.indexOf('MSIE 10') !== -1) {\n      fileElem.bind('click', ie10SameFileSelectFix);\n    }\n\n    if (ngModel) ngModel.$formatters.push(function (val) {\n      if (val == null || val.length === 0) {\n        if (fileElem.val()) {\n          fileElem.val(null);\n        }\n      }\n      return val;\n    });\n\n    scope.$on('$destroy', function () {\n      if (!isInputTypeFile()) fileElem.parent().remove();\n      angular.forEach(unwatches, function (unwatch) {\n        unwatch();\n      });\n    });\n\n    $timeout(function () {\n      for (var i = 0; i < generatedElems.length; i++) {\n        var g = generatedElems[i];\n        if (!document.body.contains(g.el[0])) {\n          generatedElems.splice(i, 1);\n          g.ref.remove();\n        }\n      }\n    });\n\n    if (window.FileAPI && window.FileAPI.ngfFixIE) {\n      window.FileAPI.ngfFixIE(elem, fileElem, changeFn);\n    }\n  }\n\n  return {\n    restrict: 'AEC',\n    require: '?ngModel',\n    link: function (scope, elem, attr, ngModel) {\n      linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, Upload);\n    }\n  };\n}]);\n\n(function () {\n\n  ngFileUpload.service('UploadDataUrl', ['UploadBase', '$timeout', '$q', function (UploadBase, $timeout, $q) {\n    var upload = UploadBase;\n    upload.base64DataUrl = function (file) {\n      if (angular.isArray(file)) {\n        var d = $q.defer(), count = 0;\n        angular.forEach(file, function (f) {\n          upload.dataUrl(f, true)['finally'](function () {\n            count++;\n            if (count === file.length) {\n              var urls = [];\n              angular.forEach(file, function (ff) {\n                urls.push(ff.$ngfDataUrl);\n              });\n              d.resolve(urls, file);\n            }\n          });\n        });\n        return d.promise;\n      } else {\n        return upload.dataUrl(file, true);\n      }\n    };\n    upload.dataUrl = function (file, disallowObjectUrl) {\n      if (!file) return upload.emptyPromise(file, file);\n      if ((disallowObjectUrl && file.$ngfDataUrl != null) || (!disallowObjectUrl && file.$ngfBlobUrl != null)) {\n        return upload.emptyPromise(disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl, file);\n      }\n      var p = disallowObjectUrl ? file.$$ngfDataUrlPromise : file.$$ngfBlobUrlPromise;\n      if (p) return p;\n\n      var deferred = $q.defer();\n      $timeout(function () {\n        if (window.FileReader && file &&\n          (!window.FileAPI || navigator.userAgent.indexOf('MSIE 8') === -1 || file.size < 20000) &&\n          (!window.FileAPI || navigator.userAgent.indexOf('MSIE 9') === -1 || file.size < 4000000)) {\n          //prefer URL.createObjectURL for handling refrences to files of all sizes\n          //since it doesn´t build a large string in memory\n          var URL = window.URL || window.webkitURL;\n          if (URL && URL.createObjectURL && !disallowObjectUrl) {\n            var url;\n            try {\n              url = URL.createObjectURL(file);\n            } catch (e) {\n              $timeout(function () {\n                file.$ngfBlobUrl = '';\n                deferred.reject();\n              });\n              return;\n            }\n            $timeout(function () {\n              file.$ngfBlobUrl = url;\n              if (url) {\n                deferred.resolve(url, file);\n                upload.blobUrls = upload.blobUrls || [];\n                upload.blobUrlsTotalSize = upload.blobUrlsTotalSize || 0;\n                upload.blobUrls.push({url: url, size: file.size});\n                upload.blobUrlsTotalSize += file.size || 0;\n                var maxMemory = upload.defaults.blobUrlsMaxMemory || 268435456;\n                var maxLength = upload.defaults.blobUrlsMaxQueueSize || 200;\n                while ((upload.blobUrlsTotalSize > maxMemory || upload.blobUrls.length > maxLength) && upload.blobUrls.length > 1) {\n                  var obj = upload.blobUrls.splice(0, 1)[0];\n                  URL.revokeObjectURL(obj.url);\n                  upload.blobUrlsTotalSize -= obj.size;\n                }\n              }\n            });\n          } else {\n            var fileReader = new FileReader();\n            fileReader.onload = function (e) {\n              $timeout(function () {\n                file.$ngfDataUrl = e.target.result;\n                deferred.resolve(e.target.result, file);\n                $timeout(function () {\n                  delete file.$ngfDataUrl;\n                }, 1000);\n              });\n            };\n            fileReader.onerror = function () {\n              $timeout(function () {\n                file.$ngfDataUrl = '';\n                deferred.reject();\n              });\n            };\n            fileReader.readAsDataURL(file);\n          }\n        } else {\n          $timeout(function () {\n            file[disallowObjectUrl ? '$ngfDataUrl' : '$ngfBlobUrl'] = '';\n            deferred.reject();\n          });\n        }\n      });\n\n      if (disallowObjectUrl) {\n        p = file.$$ngfDataUrlPromise = deferred.promise;\n      } else {\n        p = file.$$ngfBlobUrlPromise = deferred.promise;\n      }\n      p['finally'](function () {\n        delete file[disallowObjectUrl ? '$$ngfDataUrlPromise' : '$$ngfBlobUrlPromise'];\n      });\n      return p;\n    };\n    return upload;\n  }]);\n\n  function getTagType(el) {\n    if (el.tagName.toLowerCase() === 'img') return 'image';\n    if (el.tagName.toLowerCase() === 'audio') return 'audio';\n    if (el.tagName.toLowerCase() === 'video') return 'video';\n    return /./;\n  }\n\n  function linkFileDirective(Upload, $timeout, scope, elem, attr, directiveName, resizeParams, isBackground) {\n    function constructDataUrl(file) {\n      var disallowObjectUrl = Upload.attrGetter('ngfNoObjectUrl', attr, scope);\n      Upload.dataUrl(file, disallowObjectUrl)['finally'](function () {\n        $timeout(function () {\n          var src = (disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl;\n          if (isBackground) {\n            elem.css('background-image', 'url(\\'' + (src || '') + '\\')');\n          } else {\n            elem.attr('src', src);\n          }\n          if (src) {\n            elem.removeClass('ng-hide');\n          } else {\n            elem.addClass('ng-hide');\n          }\n        });\n      });\n    }\n\n    $timeout(function () {\n      var unwatch = scope.$watch(attr[directiveName], function (file) {\n        var size = resizeParams;\n        if (directiveName === 'ngfThumbnail') {\n          if (!size) {\n            size = {\n              width: elem[0].naturalWidth || elem[0].clientWidth,\n              height: elem[0].naturalHeight || elem[0].clientHeight\n            };\n          }\n          if (size.width === 0 && window.getComputedStyle) {\n            var style = getComputedStyle(elem[0]);\n            if (style.width && style.width.indexOf('px') > -1 && style.height && style.height.indexOf('px') > -1) {\n              size = {\n                width: parseInt(style.width.slice(0, -2)),\n                height: parseInt(style.height.slice(0, -2))\n              };\n            }\n          }\n        }\n\n        if (angular.isString(file)) {\n          elem.removeClass('ng-hide');\n          if (isBackground) {\n            return elem.css('background-image', 'url(\\'' + file + '\\')');\n          } else {\n            return elem.attr('src', file);\n          }\n        }\n        if (file && file.type && file.type.search(getTagType(elem[0])) === 0 &&\n          (!isBackground || file.type.indexOf('image') === 0)) {\n          if (size && Upload.isResizeSupported()) {\n            size.resizeIf = function (width, height) {\n              return Upload.attrGetter('ngfResizeIf', attr, scope,\n                {$width: width, $height: height, $file: file});\n            };\n            Upload.resize(file, size).then(\n              function (f) {\n                constructDataUrl(f);\n              }, function (e) {\n                throw e;\n              }\n            );\n          } else {\n            constructDataUrl(file);\n          }\n        } else {\n          elem.addClass('ng-hide');\n        }\n      });\n\n      scope.$on('$destroy', function () {\n        unwatch();\n      });\n    });\n  }\n\n\n  /** @namespace attr.ngfSrc */\n  /** @namespace attr.ngfNoObjectUrl */\n  ngFileUpload.directive('ngfSrc', ['Upload', '$timeout', function (Upload, $timeout) {\n    return {\n      restrict: 'AE',\n      link: function (scope, elem, attr) {\n        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfSrc',\n          Upload.attrGetter('ngfResize', attr, scope), false);\n      }\n    };\n  }]);\n\n  /** @namespace attr.ngfBackground */\n  /** @namespace attr.ngfNoObjectUrl */\n  ngFileUpload.directive('ngfBackground', ['Upload', '$timeout', function (Upload, $timeout) {\n    return {\n      restrict: 'AE',\n      link: function (scope, elem, attr) {\n        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfBackground',\n          Upload.attrGetter('ngfResize', attr, scope), true);\n      }\n    };\n  }]);\n\n  /** @namespace attr.ngfThumbnail */\n  /** @namespace attr.ngfAsBackground */\n  /** @namespace attr.ngfSize */\n  /** @namespace attr.ngfNoObjectUrl */\n  ngFileUpload.directive('ngfThumbnail', ['Upload', '$timeout', function (Upload, $timeout) {\n    return {\n      restrict: 'AE',\n      link: function (scope, elem, attr) {\n        var size = Upload.attrGetter('ngfSize', attr, scope);\n        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfThumbnail', size,\n          Upload.attrGetter('ngfAsBackground', attr, scope));\n      }\n    };\n  }]);\n\n  ngFileUpload.config(['$compileProvider', function ($compileProvider) {\n    if ($compileProvider.imgSrcSanitizationWhitelist) $compileProvider.imgSrcSanitizationWhitelist(/^\\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);\n    if ($compileProvider.aHrefSanitizationWhitelist) $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);\n  }]);\n\n  ngFileUpload.filter('ngfDataUrl', ['UploadDataUrl', '$sce', function (UploadDataUrl, $sce) {\n    return function (file, disallowObjectUrl, trustedUrl) {\n      if (angular.isString(file)) {\n        return $sce.trustAsResourceUrl(file);\n      }\n      var src = file && ((disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl);\n      if (file && !src) {\n        if (!file.$ngfDataUrlFilterInProgress && angular.isObject(file)) {\n          file.$ngfDataUrlFilterInProgress = true;\n          UploadDataUrl.dataUrl(file, disallowObjectUrl);\n        }\n        return '';\n      }\n      if (file) delete file.$ngfDataUrlFilterInProgress;\n      return (file && src ? (trustedUrl ? $sce.trustAsResourceUrl(src) : src) : file) || '';\n    };\n  }]);\n\n})();\n\nngFileUpload.service('UploadValidate', ['UploadDataUrl', '$q', '$timeout', function (UploadDataUrl, $q, $timeout) {\n  var upload = UploadDataUrl;\n\n  function globStringToRegex(str) {\n    var regexp = '', excludes = [];\n    if (str.length > 2 && str[0] === '/' && str[str.length - 1] === '/') {\n      regexp = str.substring(1, str.length - 1);\n    } else {\n      var split = str.split(',');\n      if (split.length > 1) {\n        for (var i = 0; i < split.length; i++) {\n          var r = globStringToRegex(split[i]);\n          if (r.regexp) {\n            regexp += '(' + r.regexp + ')';\n            if (i < split.length - 1) {\n              regexp += '|';\n            }\n          } else {\n            excludes = excludes.concat(r.excludes);\n          }\n        }\n      } else {\n        if (str.indexOf('!') === 0) {\n          excludes.push('^((?!' + globStringToRegex(str.substring(1)).regexp + ').)*$');\n        } else {\n          if (str.indexOf('.') === 0) {\n            str = '*' + str;\n          }\n          regexp = '^' + str.replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\-]', 'g'), '\\\\$&') + '$';\n          regexp = regexp.replace(/\\\\\\*/g, '.*').replace(/\\\\\\?/g, '.');\n        }\n      }\n    }\n    return {regexp: regexp, excludes: excludes};\n  }\n\n  upload.validatePattern = function (file, val) {\n    if (!val) {\n      return true;\n    }\n    var pattern = globStringToRegex(val), valid = true;\n    if (pattern.regexp && pattern.regexp.length) {\n      var regexp = new RegExp(pattern.regexp, 'i');\n      valid = (file.type != null && regexp.test(file.type)) ||\n        (file.name != null && regexp.test(file.name));\n    }\n    var len = pattern.excludes.length;\n    while (len--) {\n      var exclude = new RegExp(pattern.excludes[len], 'i');\n      valid = valid && (file.type == null || exclude.test(file.type)) &&\n        (file.name == null || exclude.test(file.name));\n    }\n    return valid;\n  };\n\n  upload.ratioToFloat = function (val) {\n    var r = val.toString(), xIndex = r.search(/[x:]/i);\n    if (xIndex > -1) {\n      r = parseFloat(r.substring(0, xIndex)) / parseFloat(r.substring(xIndex + 1));\n    } else {\n      r = parseFloat(r);\n    }\n    return r;\n  };\n\n  upload.registerModelChangeValidator = function (ngModel, attr, scope) {\n    if (ngModel) {\n      ngModel.$formatters.push(function (files) {\n        if (ngModel.$dirty) {\n          var filesArray = files;\n          if (files && !angular.isArray(files)) {\n            filesArray = [files];\n          }\n          upload.validate(filesArray, 0, ngModel, attr, scope).then(function () {\n            upload.applyModelValidation(ngModel, filesArray);\n          });\n        }\n        return files;\n      });\n    }\n  };\n\n  function markModelAsDirty(ngModel, files) {\n    if (files != null && !ngModel.$dirty) {\n      if (ngModel.$setDirty) {\n        ngModel.$setDirty();\n      } else {\n        ngModel.$dirty = true;\n      }\n    }\n  }\n\n  upload.applyModelValidation = function (ngModel, files) {\n    markModelAsDirty(ngModel, files);\n    angular.forEach(ngModel.$ngfValidations, function (validation) {\n      ngModel.$setValidity(validation.name, validation.valid);\n    });\n  };\n\n  upload.getValidationAttr = function (attr, scope, name, validationName, file) {\n    var dName = 'ngf' + name[0].toUpperCase() + name.substr(1);\n    var val = upload.attrGetter(dName, attr, scope, {$file: file});\n    if (val == null) {\n      val = upload.attrGetter('ngfValidate', attr, scope, {$file: file});\n      if (val) {\n        var split = (validationName || name).split('.');\n        val = val[split[0]];\n        if (split.length > 1) {\n          val = val && val[split[1]];\n        }\n      }\n    }\n    return val;\n  };\n\n  upload.validate = function (files, prevLength, ngModel, attr, scope) {\n    ngModel = ngModel || {};\n    ngModel.$ngfValidations = ngModel.$ngfValidations || [];\n\n    angular.forEach(ngModel.$ngfValidations, function (v) {\n      v.valid = true;\n    });\n\n    var attrGetter = function (name, params) {\n      return upload.attrGetter(name, attr, scope, params);\n    };\n\n    var ignoredErrors = (upload.attrGetter('ngfIgnoreInvalid', attr, scope) || '').split(' ');\n    var runAllValidation = upload.attrGetter('ngfRunAllValidations', attr, scope);\n\n    if (files == null || files.length === 0) {\n      return upload.emptyPromise({'validFiles': files, 'invalidFiles': []});\n    }\n\n    files = files.length === undefined ? [files] : files.slice(0);\n    var invalidFiles = [];\n\n    function validateSync(name, validationName, fn) {\n      if (files) {\n        var i = files.length, valid = null;\n        while (i--) {\n          var file = files[i];\n          if (file) {\n            var val = upload.getValidationAttr(attr, scope, name, validationName, file);\n            if (val != null) {\n              if (!fn(file, val, i)) {\n                if (ignoredErrors.indexOf(name) === -1) {\n                  file.$error = name;\n                  (file.$errorMessages = (file.$errorMessages || {}))[name] = true;\n                  file.$errorParam = val;\n                  if (invalidFiles.indexOf(file) === -1) {\n                    invalidFiles.push(file);\n                  }\n                  if (!runAllValidation) {\n                    files.splice(i, 1);\n                  }\n                  valid = false;\n                } else {\n                  files.splice(i, 1);\n                }\n              }\n            }\n          }\n        }\n        if (valid !== null) {\n          ngModel.$ngfValidations.push({name: name, valid: valid});\n        }\n      }\n    }\n\n    validateSync('pattern', null, upload.validatePattern);\n    validateSync('minSize', 'size.min', function (file, val) {\n      return file.size + 0.1 >= upload.translateScalars(val);\n    });\n    validateSync('maxSize', 'size.max', function (file, val) {\n      return file.size - 0.1 <= upload.translateScalars(val);\n    });\n    var totalSize = 0;\n    validateSync('maxTotalSize', null, function (file, val) {\n      totalSize += file.size;\n      if (totalSize > upload.translateScalars(val)) {\n        files.splice(0, files.length);\n        return false;\n      }\n      return true;\n    });\n\n    validateSync('validateFn', null, function (file, r) {\n      return r === true || r === null || r === '';\n    });\n\n    if (!files.length) {\n      return upload.emptyPromise({'validFiles': [], 'invalidFiles': invalidFiles});\n    }\n\n    function validateAsync(name, validationName, type, asyncFn, fn) {\n      function resolveResult(defer, file, val) {\n        function resolveInternal(fn) {\n          if (fn()) {\n            if (ignoredErrors.indexOf(name) === -1) {\n              file.$error = name;\n              (file.$errorMessages = (file.$errorMessages || {}))[name] = true;\n              file.$errorParam = val;\n              if (invalidFiles.indexOf(file) === -1) {\n                invalidFiles.push(file);\n              }\n              if (!runAllValidation) {\n                var i = files.indexOf(file);\n                if (i > -1) files.splice(i, 1);\n              }\n              defer.resolve(false);\n            } else {\n              var j = files.indexOf(file);\n              if (j > -1) files.splice(j, 1);\n              defer.resolve(true);\n            }\n          } else {\n            defer.resolve(true);\n          }\n        }\n\n        if (val != null) {\n          asyncFn(file, val).then(function (d) {\n            resolveInternal(function () {\n              return !fn(d, val);\n            });\n          }, function () {\n            resolveInternal(function () {\n              return attrGetter('ngfValidateForce', {$file: file});\n            });\n          });\n        } else {\n          defer.resolve(true);\n        }\n      }\n\n      var promises = [upload.emptyPromise(true)];\n      if (files) {\n        files = files.length === undefined ? [files] : files;\n        angular.forEach(files, function (file) {\n          var defer = $q.defer();\n          promises.push(defer.promise);\n          if (type && (file.type == null || file.type.search(type) !== 0)) {\n            defer.resolve(true);\n            return;\n          }\n          if (name === 'dimensions' && upload.attrGetter('ngfDimensions', attr) != null) {\n            upload.imageDimensions(file).then(function (d) {\n              resolveResult(defer, file,\n                attrGetter('ngfDimensions', {$file: file, $width: d.width, $height: d.height}));\n            }, function () {\n              defer.resolve(false);\n            });\n          } else if (name === 'duration' && upload.attrGetter('ngfDuration', attr) != null) {\n            upload.mediaDuration(file).then(function (d) {\n              resolveResult(defer, file,\n                attrGetter('ngfDuration', {$file: file, $duration: d}));\n            }, function () {\n              defer.resolve(false);\n            });\n          } else {\n            resolveResult(defer, file,\n              upload.getValidationAttr(attr, scope, name, validationName, file));\n          }\n        });\n      }\n      var deffer = $q.defer();\n      $q.all(promises).then(function (values) {\n        var isValid = true;\n        for (var i = 0; i < values.length; i++) {\n          if (!values[i]) {\n            isValid = false;\n            break;\n          }\n        }\n        ngModel.$ngfValidations.push({name: name, valid: isValid});\n        deffer.resolve(isValid);\n      });\n      return deffer.promise;\n    }\n\n    var deffer = $q.defer();\n    var promises = [];\n\n    promises.push(validateAsync('maxHeight', 'height.max', /image/,\n      this.imageDimensions, function (d, val) {\n        return d.height <= val;\n      }));\n    promises.push(validateAsync('minHeight', 'height.min', /image/,\n      this.imageDimensions, function (d, val) {\n        return d.height >= val;\n      }));\n    promises.push(validateAsync('maxWidth', 'width.max', /image/,\n      this.imageDimensions, function (d, val) {\n        return d.width <= val;\n      }));\n    promises.push(validateAsync('minWidth', 'width.min', /image/,\n      this.imageDimensions, function (d, val) {\n        return d.width >= val;\n      }));\n    promises.push(validateAsync('dimensions', null, /image/,\n      function (file, val) {\n        return upload.emptyPromise(val);\n      }, function (r) {\n        return r;\n      }));\n    promises.push(validateAsync('ratio', null, /image/,\n      this.imageDimensions, function (d, val) {\n        var split = val.toString().split(','), valid = false;\n        for (var i = 0; i < split.length; i++) {\n          if (Math.abs((d.width / d.height) - upload.ratioToFloat(split[i])) < 0.01) {\n            valid = true;\n          }\n        }\n        return valid;\n      }));\n    promises.push(validateAsync('maxRatio', 'ratio.max', /image/,\n      this.imageDimensions, function (d, val) {\n        return (d.width / d.height) - upload.ratioToFloat(val) < 0.0001;\n      }));\n    promises.push(validateAsync('minRatio', 'ratio.min', /image/,\n      this.imageDimensions, function (d, val) {\n        return (d.width / d.height) - upload.ratioToFloat(val) > -0.0001;\n      }));\n    promises.push(validateAsync('maxDuration', 'duration.max', /audio|video/,\n      this.mediaDuration, function (d, val) {\n        return d <= upload.translateScalars(val);\n      }));\n    promises.push(validateAsync('minDuration', 'duration.min', /audio|video/,\n      this.mediaDuration, function (d, val) {\n        return d >= upload.translateScalars(val);\n      }));\n    promises.push(validateAsync('duration', null, /audio|video/,\n      function (file, val) {\n        return upload.emptyPromise(val);\n      }, function (r) {\n        return r;\n      }));\n\n    promises.push(validateAsync('validateAsyncFn', null, null,\n      function (file, val) {\n        return val;\n      }, function (r) {\n        return r === true || r === null || r === '';\n      }));\n\n    $q.all(promises).then(function () {\n\n      if (runAllValidation) {\n        for (var i = 0; i < files.length; i++) {\n          var file = files[i];\n          if (file.$error) {\n            files.splice(i--, 1);\n          }\n        }\n      }\n\n      runAllValidation = false;\n      validateSync('maxFiles', null, function (file, val, i) {\n        return prevLength + i < val;\n      });\n\n      deffer.resolve({'validFiles': files, 'invalidFiles': invalidFiles});\n    });\n    return deffer.promise;\n  };\n\n  upload.imageDimensions = function (file) {\n    if (file.$ngfWidth && file.$ngfHeight) {\n      var d = $q.defer();\n      $timeout(function () {\n        d.resolve({width: file.$ngfWidth, height: file.$ngfHeight});\n      });\n      return d.promise;\n    }\n    if (file.$ngfDimensionPromise) return file.$ngfDimensionPromise;\n\n    var deferred = $q.defer();\n    $timeout(function () {\n      if (file.type.indexOf('image') !== 0) {\n        deferred.reject('not image');\n        return;\n      }\n      upload.dataUrl(file).then(function (dataUrl) {\n        var img = angular.element('<img>').attr('src', dataUrl)\n          .css('visibility', 'hidden').css('position', 'fixed')\n          .css('max-width', 'none !important').css('max-height', 'none !important');\n\n        function success() {\n          var width = img[0].naturalWidth || img[0].clientWidth;\n          var height = img[0].naturalHeight || img[0].clientHeight;\n          img.remove();\n          file.$ngfWidth = width;\n          file.$ngfHeight = height;\n          deferred.resolve({width: width, height: height});\n        }\n\n        function error() {\n          img.remove();\n          deferred.reject('load error');\n        }\n\n        img.on('load', success);\n        img.on('error', error);\n\n        var secondsCounter = 0;\n        function checkLoadErrorInCaseOfNoCallback() {\n          $timeout(function () {\n            if (img[0].parentNode) {\n              if (img[0].clientWidth) {\n                success();\n              } else if (secondsCounter++ > 10) {\n                error();\n              } else {\n                checkLoadErrorInCaseOfNoCallback();\n              }\n            }\n          }, 1000);\n        }\n\n        checkLoadErrorInCaseOfNoCallback();\n\n        angular.element(document.getElementsByTagName('body')[0]).append(img);\n      }, function () {\n        deferred.reject('load error');\n      });\n    });\n\n    file.$ngfDimensionPromise = deferred.promise;\n    file.$ngfDimensionPromise['finally'](function () {\n      delete file.$ngfDimensionPromise;\n    });\n    return file.$ngfDimensionPromise;\n  };\n\n  upload.mediaDuration = function (file) {\n    if (file.$ngfDuration) {\n      var d = $q.defer();\n      $timeout(function () {\n        d.resolve(file.$ngfDuration);\n      });\n      return d.promise;\n    }\n    if (file.$ngfDurationPromise) return file.$ngfDurationPromise;\n\n    var deferred = $q.defer();\n    $timeout(function () {\n      if (file.type.indexOf('audio') !== 0 && file.type.indexOf('video') !== 0) {\n        deferred.reject('not media');\n        return;\n      }\n      upload.dataUrl(file).then(function (dataUrl) {\n        var el = angular.element(file.type.indexOf('audio') === 0 ? '<audio>' : '<video>')\n          .attr('src', dataUrl).css('visibility', 'none').css('position', 'fixed');\n\n        function success() {\n          var duration = el[0].duration;\n          file.$ngfDuration = duration;\n          el.remove();\n          deferred.resolve(duration);\n        }\n\n        function error() {\n          el.remove();\n          deferred.reject('load error');\n        }\n\n        el.on('loadedmetadata', success);\n        el.on('error', error);\n        var count = 0;\n\n        function checkLoadError() {\n          $timeout(function () {\n            if (el[0].parentNode) {\n              if (el[0].duration) {\n                success();\n              } else if (count > 10) {\n                error();\n              } else {\n                checkLoadError();\n              }\n            }\n          }, 1000);\n        }\n\n        checkLoadError();\n\n        angular.element(document.body).append(el);\n      }, function () {\n        deferred.reject('load error');\n      });\n    });\n\n    file.$ngfDurationPromise = deferred.promise;\n    file.$ngfDurationPromise['finally'](function () {\n      delete file.$ngfDurationPromise;\n    });\n    return file.$ngfDurationPromise;\n  };\n  return upload;\n}\n]);\n\nngFileUpload.service('UploadResize', ['UploadValidate', '$q', function (UploadValidate, $q) {\n  var upload = UploadValidate;\n\n  /**\n   * Conserve aspect ratio of the original region. Useful when shrinking/enlarging\n   * images to fit into a certain area.\n   * Source:  http://stackoverflow.com/a/14731922\n   *\n   * @param {Number} srcWidth Source area width\n   * @param {Number} srcHeight Source area height\n   * @param {Number} maxWidth Nestable area maximum available width\n   * @param {Number} maxHeight Nestable area maximum available height\n   * @return {Object} { width, height }\n   */\n  var calculateAspectRatioFit = function (srcWidth, srcHeight, maxWidth, maxHeight, centerCrop) {\n    var ratio = centerCrop ? Math.max(maxWidth / srcWidth, maxHeight / srcHeight) :\n      Math.min(maxWidth / srcWidth, maxHeight / srcHeight);\n    return {\n      width: srcWidth * ratio, height: srcHeight * ratio,\n      marginX: srcWidth * ratio - maxWidth, marginY: srcHeight * ratio - maxHeight\n    };\n  };\n\n  // Extracted from https://github.com/romelgomez/angular-firebase-image-upload/blob/master/app/scripts/fileUpload.js#L89\n  var resize = function (imagen, width, height, quality, type, ratio, centerCrop, resizeIf) {\n    var deferred = $q.defer();\n    var canvasElement = document.createElement('canvas');\n    var imageElement = document.createElement('img');\n    imageElement.setAttribute('style', 'visibility:hidden;position:fixed;z-index:-100000');\n    document.body.appendChild(imageElement);\n\n    imageElement.onload = function () {\n      var imgWidth = imageElement.width, imgHeight = imageElement.height;\n      imageElement.parentNode.removeChild(imageElement);\n      if (resizeIf != null && resizeIf(imgWidth, imgHeight) === false) {\n        deferred.reject('resizeIf');\n        return;\n      }\n      try {\n        if (ratio) {\n          var ratioFloat = upload.ratioToFloat(ratio);\n          var imgRatio = imgWidth / imgHeight;\n          if (imgRatio < ratioFloat) {\n            width = imgWidth;\n            height = width / ratioFloat;\n          } else {\n            height = imgHeight;\n            width = height * ratioFloat;\n          }\n        }\n        if (!width) {\n          width = imgWidth;\n        }\n        if (!height) {\n          height = imgHeight;\n        }\n        var dimensions = calculateAspectRatioFit(imgWidth, imgHeight, width, height, centerCrop);\n        canvasElement.width = Math.min(dimensions.width, width);\n        canvasElement.height = Math.min(dimensions.height, height);\n        var context = canvasElement.getContext('2d');\n        context.drawImage(imageElement,\n          Math.min(0, -dimensions.marginX / 2), Math.min(0, -dimensions.marginY / 2),\n          dimensions.width, dimensions.height);\n        deferred.resolve(canvasElement.toDataURL(type || 'image/WebP', quality || 0.934));\n      } catch (e) {\n        deferred.reject(e);\n      }\n    };\n    imageElement.onerror = function () {\n      imageElement.parentNode.removeChild(imageElement);\n      deferred.reject();\n    };\n    imageElement.src = imagen;\n    return deferred.promise;\n  };\n\n  upload.dataUrltoBlob = function (dataurl, name, origSize) {\n    var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],\n      bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);\n    while (n--) {\n      u8arr[n] = bstr.charCodeAt(n);\n    }\n    var blob = new window.Blob([u8arr], {type: mime});\n    blob.name = name;\n    blob.$ngfOrigSize = origSize;\n    return blob;\n  };\n\n  upload.isResizeSupported = function () {\n    var elem = document.createElement('canvas');\n    return window.atob && elem.getContext && elem.getContext('2d') && window.Blob;\n  };\n\n  if (upload.isResizeSupported()) {\n    // add name getter to the blob constructor prototype\n    Object.defineProperty(window.Blob.prototype, 'name', {\n      get: function () {\n        return this.$ngfName;\n      },\n      set: function (v) {\n        this.$ngfName = v;\n      },\n      configurable: true\n    });\n  }\n\n  upload.resize = function (file, options) {\n    if (file.type.indexOf('image') !== 0) return upload.emptyPromise(file);\n\n    var deferred = $q.defer();\n    upload.dataUrl(file, true).then(function (url) {\n      resize(url, options.width, options.height, options.quality, options.type || file.type,\n        options.ratio, options.centerCrop, options.resizeIf)\n        .then(function (dataUrl) {\n          if (file.type === 'image/jpeg' && options.restoreExif !== false) {\n            try {\n              dataUrl = upload.restoreExif(url, dataUrl);\n            } catch (e) {\n              setTimeout(function () {throw e;}, 1);\n            }\n          }\n          try {\n            var blob = upload.dataUrltoBlob(dataUrl, file.name, file.size);\n            deferred.resolve(blob);\n          } catch (e) {\n            deferred.reject(e);\n          }\n        }, function (r) {\n          if (r === 'resizeIf') {\n            deferred.resolve(file);\n          }\n          deferred.reject(r);\n        });\n    }, function (e) {\n      deferred.reject(e);\n    });\n    return deferred.promise;\n  };\n\n  return upload;\n}]);\n\n(function () {\n  ngFileUpload.directive('ngfDrop', ['$parse', '$timeout', '$window', 'Upload', '$http', '$q',\n    function ($parse, $timeout, $window, Upload, $http, $q) {\n      return {\n        restrict: 'AEC',\n        require: '?ngModel',\n        link: function (scope, elem, attr, ngModel) {\n          linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, Upload, $http, $q);\n        }\n      };\n    }]);\n\n  ngFileUpload.directive('ngfNoFileDrop', function () {\n    return function (scope, elem) {\n      if (dropAvailable()) elem.css('display', 'none');\n    };\n  });\n\n  ngFileUpload.directive('ngfDropAvailable', ['$parse', '$timeout', 'Upload', function ($parse, $timeout, Upload) {\n    return function (scope, elem, attr) {\n      if (dropAvailable()) {\n        var model = $parse(Upload.attrGetter('ngfDropAvailable', attr));\n        $timeout(function () {\n          model(scope);\n          if (model.assign) {\n            model.assign(scope, true);\n          }\n        });\n      }\n    };\n  }]);\n\n  function linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, upload, $http, $q) {\n    var available = dropAvailable();\n\n    var attrGetter = function (name, scope, params) {\n      return upload.attrGetter(name, attr, scope, params);\n    };\n\n    if (attrGetter('dropAvailable')) {\n      $timeout(function () {\n        if (scope[attrGetter('dropAvailable')]) {\n          scope[attrGetter('dropAvailable')].value = available;\n        } else {\n          scope[attrGetter('dropAvailable')] = available;\n        }\n      });\n    }\n    if (!available) {\n      if (attrGetter('ngfHideOnDropNotAvailable', scope) === true) {\n        elem.css('display', 'none');\n      }\n      return;\n    }\n\n    function isDisabled() {\n      return elem.attr('disabled') || attrGetter('ngfDropDisabled', scope);\n    }\n\n    if (attrGetter('ngfSelect') == null) {\n      upload.registerModelChangeValidator(ngModel, attr, scope);\n    }\n\n    var leaveTimeout = null;\n    var stopPropagation = $parse(attrGetter('ngfStopPropagation'));\n    var dragOverDelay = 1;\n    var actualDragOverClass;\n\n    elem[0].addEventListener('dragover', function (evt) {\n      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;\n      evt.preventDefault();\n      if (stopPropagation(scope)) evt.stopPropagation();\n      // handling dragover events from the Chrome download bar\n      if (navigator.userAgent.indexOf('Chrome') > -1) {\n        var b = evt.dataTransfer.effectAllowed;\n        evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';\n      }\n      $timeout.cancel(leaveTimeout);\n      if (!actualDragOverClass) {\n        actualDragOverClass = 'C';\n        calculateDragOverClass(scope, attr, evt, function (clazz) {\n          actualDragOverClass = clazz;\n          elem.addClass(actualDragOverClass);\n          attrGetter('ngfDrag', scope, {$isDragging: true, $class: actualDragOverClass, $event: evt});\n        });\n      }\n    }, false);\n    elem[0].addEventListener('dragenter', function (evt) {\n      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;\n      evt.preventDefault();\n      if (stopPropagation(scope)) evt.stopPropagation();\n    }, false);\n    elem[0].addEventListener('dragleave', function (evt) {\n      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;\n      evt.preventDefault();\n      if (stopPropagation(scope)) evt.stopPropagation();\n      leaveTimeout = $timeout(function () {\n        if (actualDragOverClass) elem.removeClass(actualDragOverClass);\n        actualDragOverClass = null;\n        attrGetter('ngfDrag', scope, {$isDragging: false, $event: evt});\n      }, dragOverDelay || 100);\n    }, false);\n    elem[0].addEventListener('drop', function (evt) {\n      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;\n      evt.preventDefault();\n      if (stopPropagation(scope)) evt.stopPropagation();\n      if (actualDragOverClass) elem.removeClass(actualDragOverClass);\n      actualDragOverClass = null;\n      extractFilesAndUpdateModel(evt.dataTransfer, evt, 'dropUrl');\n    }, false);\n    elem[0].addEventListener('paste', function (evt) {\n      if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&\n        attrGetter('ngfEnableFirefoxPaste', scope)) {\n        evt.preventDefault();\n      }\n      if (isDisabled() || !upload.shouldUpdateOn('paste', attr, scope)) return;\n      extractFilesAndUpdateModel(evt.clipboardData || evt.originalEvent.clipboardData, evt, 'pasteUrl');\n    }, false);\n\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&\n      attrGetter('ngfEnableFirefoxPaste', scope)) {\n      elem.attr('contenteditable', true);\n      elem.on('keypress', function (e) {\n        if (!e.metaKey && !e.ctrlKey) {\n          e.preventDefault();\n        }\n      });\n    }\n\n    function extractFilesAndUpdateModel(source, evt, updateOnType) {\n      if (!source) return;\n      // html needs to be calculated on the same process otherwise the data will be wiped\n      // after promise resolve or setTimeout.\n      var html;\n      try {\n        html = source && source.getData && source.getData('text/html');\n      } catch (e) {/* Fix IE11 that throw error calling getData */\n      }\n      extractFiles(source.items, source.files, attrGetter('ngfAllowDir', scope) !== false,\n        attrGetter('multiple') || attrGetter('ngfMultiple', scope)).then(function (files) {\n        if (files.length) {\n          updateModel(files, evt);\n        } else {\n          extractFilesFromHtml(updateOnType, html).then(function (files) {\n            updateModel(files, evt);\n          });\n        }\n      });\n    }\n\n    function updateModel(files, evt) {\n      upload.updateModel(ngModel, attr, scope, attrGetter('ngfChange') || attrGetter('ngfDrop'), files, evt);\n    }\n\n    function extractFilesFromHtml(updateOn, html) {\n      if (!upload.shouldUpdateOn(updateOn, attr, scope) || typeof html !== 'string') return upload.rejectPromise([]);\n      var urls = [];\n      html.replace(/<(img src|img [^>]* src) *=\\\"([^\\\"]*)\\\"/gi, function (m, n, src) {\n        urls.push(src);\n      });\n      var promises = [], files = [];\n      if (urls.length) {\n        angular.forEach(urls, function (url) {\n          promises.push(upload.urlToBlob(url).then(function (blob) {\n            files.push(blob);\n          }));\n        });\n        var defer = $q.defer();\n        $q.all(promises).then(function () {\n          defer.resolve(files);\n        }, function (e) {\n          defer.reject(e);\n        });\n        return defer.promise;\n      }\n      return upload.emptyPromise();\n    }\n\n    function calculateDragOverClass(scope, attr, evt, callback) {\n      var obj = attrGetter('ngfDragOverClass', scope, {$event: evt}), dClass = 'dragover';\n      if (angular.isString(obj)) {\n        dClass = obj;\n      } else if (obj) {\n        if (obj.delay) dragOverDelay = obj.delay;\n        if (obj.accept || obj.reject) {\n          var items = evt.dataTransfer.items;\n          if (items == null || !items.length) {\n            dClass = obj.accept;\n          } else {\n            var pattern = obj.pattern || attrGetter('ngfPattern', scope, {$event: evt});\n            var len = items.length;\n            while (len--) {\n              if (!upload.validatePattern(items[len], pattern)) {\n                dClass = obj.reject;\n                break;\n              } else {\n                dClass = obj.accept;\n              }\n            }\n          }\n        }\n      }\n      callback(dClass);\n    }\n\n    function extractFiles(items, fileList, allowDir, multiple) {\n      var maxFiles = upload.getValidationAttr(attr, scope, 'maxFiles');\n      if (maxFiles == null) {\n        maxFiles = Number.MAX_VALUE;\n      }\n      var maxTotalSize = upload.getValidationAttr(attr, scope, 'maxTotalSize');\n      if (maxTotalSize == null) {\n        maxTotalSize = Number.MAX_VALUE;\n      }\n      var includeDir = attrGetter('ngfIncludeDir', scope);\n      var files = [], totalSize = 0;\n\n      function traverseFileTree(entry, path) {\n        var defer = $q.defer();\n        if (entry != null) {\n          if (entry.isDirectory) {\n            var promises = [upload.emptyPromise()];\n            if (includeDir) {\n              var file = {type: 'directory'};\n              file.name = file.path = (path || '') + entry.name;\n              files.push(file);\n            }\n            var dirReader = entry.createReader();\n            var entries = [];\n            var readEntries = function () {\n              dirReader.readEntries(function (results) {\n                try {\n                  if (!results.length) {\n                    angular.forEach(entries.slice(0), function (e) {\n                      if (files.length <= maxFiles && totalSize <= maxTotalSize) {\n                        promises.push(traverseFileTree(e, (path ? path : '') + entry.name + '/'));\n                      }\n                    });\n                    $q.all(promises).then(function () {\n                      defer.resolve();\n                    }, function (e) {\n                      defer.reject(e);\n                    });\n                  } else {\n                    entries = entries.concat(Array.prototype.slice.call(results || [], 0));\n                    readEntries();\n                  }\n                } catch (e) {\n                  defer.reject(e);\n                }\n              }, function (e) {\n                defer.reject(e);\n              });\n            };\n            readEntries();\n          } else {\n            entry.file(function (file) {\n              try {\n                file.path = (path ? path : '') + file.name;\n                if (includeDir) {\n                  file = upload.rename(file, file.path);\n                }\n                files.push(file);\n                totalSize += file.size;\n                defer.resolve();\n              } catch (e) {\n                defer.reject(e);\n              }\n            }, function (e) {\n              defer.reject(e);\n            });\n          }\n        }\n        return defer.promise;\n      }\n\n      var promises = [upload.emptyPromise()];\n\n      if (items && items.length > 0 && $window.location.protocol !== 'file:') {\n        for (var i = 0; i < items.length; i++) {\n          if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {\n            var entry = items[i].webkitGetAsEntry();\n            if (entry.isDirectory && !allowDir) {\n              continue;\n            }\n            if (entry != null) {\n              promises.push(traverseFileTree(entry));\n            }\n          } else {\n            var f = items[i].getAsFile();\n            if (f != null) {\n              files.push(f);\n              totalSize += f.size;\n            }\n          }\n          if (files.length > maxFiles || totalSize > maxTotalSize ||\n            (!multiple && files.length > 0)) break;\n        }\n      } else {\n        if (fileList != null) {\n          for (var j = 0; j < fileList.length; j++) {\n            var file = fileList.item(j);\n            if (file.type || file.size > 0) {\n              files.push(file);\n              totalSize += file.size;\n            }\n            if (files.length > maxFiles || totalSize > maxTotalSize ||\n              (!multiple && files.length > 0)) break;\n          }\n        }\n      }\n\n      var defer = $q.defer();\n      $q.all(promises).then(function () {\n        if (!multiple && !includeDir && files.length) {\n          var i = 0;\n          while (files[i] && files[i].type === 'directory') i++;\n          defer.resolve([files[i]]);\n        } else {\n          defer.resolve(files);\n        }\n      }, function (e) {\n        defer.reject(e);\n      });\n\n      return defer.promise;\n    }\n  }\n\n  function dropAvailable() {\n    var div = document.createElement('div');\n    return ('draggable' in div) && ('ondrop' in div) && !/Edge\\/12./i.test(navigator.userAgent);\n  }\n\n})();\n\n// customized version of https://github.com/exif-js/exif-js\nngFileUpload.service('UploadExif', ['UploadResize', '$q', function (UploadResize, $q) {\n  var upload = UploadResize;\n\n  upload.isExifSupported = function () {\n    return window.FileReader && new FileReader().readAsArrayBuffer && upload.isResizeSupported();\n  };\n\n  function applyTransform(ctx, orientation, width, height) {\n    switch (orientation) {\n      case 2:\n        return ctx.transform(-1, 0, 0, 1, width, 0);\n      case 3:\n        return ctx.transform(-1, 0, 0, -1, width, height);\n      case 4:\n        return ctx.transform(1, 0, 0, -1, 0, height);\n      case 5:\n        return ctx.transform(0, 1, 1, 0, 0, 0);\n      case 6:\n        return ctx.transform(0, 1, -1, 0, height, 0);\n      case 7:\n        return ctx.transform(0, -1, -1, 0, height, width);\n      case 8:\n        return ctx.transform(0, -1, 1, 0, 0, width);\n    }\n  }\n\n  upload.readOrientation = function (file) {\n    var defer = $q.defer();\n    var reader = new FileReader();\n    var slicedFile = file.slice ? file.slice(0, 64 * 1024) : file;\n    reader.readAsArrayBuffer(slicedFile);\n    reader.onerror = function (e) {\n      return defer.reject(e);\n    };\n    reader.onload = function (e) {\n      var result = {orientation: 1};\n      var view = new DataView(this.result);\n      if (view.getUint16(0, false) !== 0xFFD8) return defer.resolve(result);\n\n      var length = view.byteLength,\n        offset = 2;\n      while (offset < length) {\n        var marker = view.getUint16(offset, false);\n        offset += 2;\n        if (marker === 0xFFE1) {\n          if (view.getUint32(offset += 2, false) !== 0x45786966) return defer.resolve(result);\n\n          var little = view.getUint16(offset += 6, false) === 0x4949;\n          offset += view.getUint32(offset + 4, little);\n          var tags = view.getUint16(offset, little);\n          offset += 2;\n          for (var i = 0; i < tags; i++)\n            if (view.getUint16(offset + (i * 12), little) === 0x0112) {\n              var orientation = view.getUint16(offset + (i * 12) + 8, little);\n              if (orientation >= 2 && orientation <= 8) {\n                view.setUint16(offset + (i * 12) + 8, 1, little);\n                result.fixedArrayBuffer = e.target.result;\n              }\n              result.orientation = orientation;\n              return defer.resolve(result);\n            }\n        } else if ((marker & 0xFF00) !== 0xFF00) break;\n        else offset += view.getUint16(offset, false);\n      }\n      return defer.resolve(result);\n    };\n    return defer.promise;\n  };\n\n  function arrayBufferToBase64(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var len = bytes.byteLength;\n    for (var i = 0; i < len; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n  }\n\n  upload.applyExifRotation = function (file) {\n    if (file.type.indexOf('image/jpeg') !== 0) {\n      return upload.emptyPromise(file);\n    }\n\n    var deferred = $q.defer();\n    upload.readOrientation(file).then(function (result) {\n      if (result.orientation < 2 || result.orientation > 8) {\n        return deferred.resolve(file);\n      }\n      upload.dataUrl(file, true).then(function (url) {\n        var canvas = document.createElement('canvas');\n        var img = document.createElement('img');\n\n        img.onload = function () {\n          try {\n            canvas.width = result.orientation > 4 ? img.height : img.width;\n            canvas.height = result.orientation > 4 ? img.width : img.height;\n            var ctx = canvas.getContext('2d');\n            applyTransform(ctx, result.orientation, img.width, img.height);\n            ctx.drawImage(img, 0, 0);\n            var dataUrl = canvas.toDataURL(file.type || 'image/WebP', 0.934);\n            dataUrl = upload.restoreExif(arrayBufferToBase64(result.fixedArrayBuffer), dataUrl);\n            var blob = upload.dataUrltoBlob(dataUrl, file.name);\n            deferred.resolve(blob);\n          } catch (e) {\n            return deferred.reject(e);\n          }\n        };\n        img.onerror = function () {\n          deferred.reject();\n        };\n        img.src = url;\n      }, function (e) {\n        deferred.reject(e);\n      });\n    }, function (e) {\n      deferred.reject(e);\n    });\n    return deferred.promise;\n  };\n\n  upload.restoreExif = function (orig, resized) {\n    var ExifRestorer = {};\n\n    ExifRestorer.KEY_STR = 'ABCDEFGHIJKLMNOP' +\n      'QRSTUVWXYZabcdef' +\n      'ghijklmnopqrstuv' +\n      'wxyz0123456789+/' +\n      '=';\n\n    ExifRestorer.encode64 = function (input) {\n      var output = '',\n        chr1, chr2, chr3 = '',\n        enc1, enc2, enc3, enc4 = '',\n        i = 0;\n\n      do {\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n          enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n          enc4 = 64;\n        }\n\n        output = output +\n          this.KEY_STR.charAt(enc1) +\n          this.KEY_STR.charAt(enc2) +\n          this.KEY_STR.charAt(enc3) +\n          this.KEY_STR.charAt(enc4);\n        chr1 = chr2 = chr3 = '';\n        enc1 = enc2 = enc3 = enc4 = '';\n      } while (i < input.length);\n\n      return output;\n    };\n\n    ExifRestorer.restore = function (origFileBase64, resizedFileBase64) {\n      if (origFileBase64.match('data:image/jpeg;base64,')) {\n        origFileBase64 = origFileBase64.replace('data:image/jpeg;base64,', '');\n      }\n\n      var rawImage = this.decode64(origFileBase64);\n      var segments = this.slice2Segments(rawImage);\n\n      var image = this.exifManipulation(resizedFileBase64, segments);\n\n      return 'data:image/jpeg;base64,' + this.encode64(image);\n    };\n\n\n    ExifRestorer.exifManipulation = function (resizedFileBase64, segments) {\n      var exifArray = this.getExifArray(segments),\n        newImageArray = this.insertExif(resizedFileBase64, exifArray);\n      return new Uint8Array(newImageArray);\n    };\n\n\n    ExifRestorer.getExifArray = function (segments) {\n      var seg;\n      for (var x = 0; x < segments.length; x++) {\n        seg = segments[x];\n        if (seg[0] === 255 & seg[1] === 225) //(ff e1)\n        {\n          return seg;\n        }\n      }\n      return [];\n    };\n\n\n    ExifRestorer.insertExif = function (resizedFileBase64, exifArray) {\n      var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', ''),\n        buf = this.decode64(imageData),\n        separatePoint = buf.indexOf(255, 3),\n        mae = buf.slice(0, separatePoint),\n        ato = buf.slice(separatePoint),\n        array = mae;\n\n      array = array.concat(exifArray);\n      array = array.concat(ato);\n      return array;\n    };\n\n\n    ExifRestorer.slice2Segments = function (rawImageArray) {\n      var head = 0,\n        segments = [];\n\n      while (1) {\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {\n          break;\n        }\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {\n          head += 2;\n        }\n        else {\n          var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],\n            endPoint = head + length + 2,\n            seg = rawImageArray.slice(head, endPoint);\n          segments.push(seg);\n          head = endPoint;\n        }\n        if (head > rawImageArray.length) {\n          break;\n        }\n      }\n\n      return segments;\n    };\n\n\n    ExifRestorer.decode64 = function (input) {\n      var chr1, chr2, chr3 = '',\n        enc1, enc2, enc3, enc4 = '',\n        i = 0,\n        buf = [];\n\n      // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n      var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n      if (base64test.exec(input)) {\n        console.log('There were invalid base64 characters in the input text.\\n' +\n          'Valid base64 characters are A-Z, a-z, 0-9, ' + ', ' / ',and \"=\"\\n' +\n          'Expect errors in decoding.');\n      }\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n      do {\n        enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        buf.push(chr1);\n\n        if (enc3 !== 64) {\n          buf.push(chr2);\n        }\n        if (enc4 !== 64) {\n          buf.push(chr3);\n        }\n\n        chr1 = chr2 = chr3 = '';\n        enc1 = enc2 = enc3 = enc4 = '';\n\n      } while (i < input.length);\n\n      return buf;\n    };\n\n    return ExifRestorer.restore(orig, resized);  //<= EXIF\n  };\n\n  return upload;\n}]);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L25nLWZpbGUtdXBsb2FkL2Rpc3QvbmctZmlsZS11cGxvYWQuanM/MzhiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiohXG4gKiBBbmd1bGFySlMgZmlsZSB1cGxvYWQgZGlyZWN0aXZlcyBhbmQgc2VydmljZXMuIFN1cG9vcnRzOiBmaWxlIHVwbG9hZC9kcm9wL3Bhc3RlLCByZXN1bWUsIGNhbmNlbC9hYm9ydCxcbiAqIHByb2dyZXNzLCByZXNpemUsIHRodW1ibmFpbCwgcHJldmlldywgdmFsaWRhdGlvbiBhbmQgQ09SU1xuICogQGF1dGhvciAgRGFuaWFsICA8ZGFuaWFsLmZhcmlkQGdtYWlsLmNvbT5cbiAqIEB2ZXJzaW9uIDEyLjIuMTNcbiAqL1xuXG5pZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmICEod2luZG93LkZpbGVBUEkgJiYgRmlsZUFQSS5zaG91bGRMb2FkKSkge1xuICB3aW5kb3cuWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNldFJlcXVlc3RIZWFkZXIgPSAoZnVuY3Rpb24gKG9yaWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhlYWRlciwgdmFsdWUpIHtcbiAgICAgIGlmIChoZWFkZXIgPT09ICdfX3NldFhIUl8nKSB7XG4gICAgICAgIHZhciB2YWwgPSB2YWx1ZSh0aGlzKTtcbiAgICAgICAgLy8gZml4IGZvciBhbmd1bGFyIDwgMS4yLjBcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgdmFsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkod2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyKTtcbn1cblxudmFyIG5nRmlsZVVwbG9hZCA9IGFuZ3VsYXIubW9kdWxlKCduZ0ZpbGVVcGxvYWQnLCBbXSk7XG5cbm5nRmlsZVVwbG9hZC52ZXJzaW9uID0gJzEyLjIuMTMnO1xuXG5uZ0ZpbGVVcGxvYWQuc2VydmljZSgnVXBsb2FkQmFzZScsIFsnJGh0dHAnLCAnJHEnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAoJGh0dHAsICRxLCAkdGltZW91dCkge1xuICB2YXIgdXBsb2FkID0gdGhpcztcbiAgdXBsb2FkLnByb21pc2VzQ291bnQgPSAwO1xuXG4gIHRoaXMuaXNSZXN1bWVTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5CbG9iICYmIHdpbmRvdy5CbG9iLnByb3RvdHlwZS5zbGljZTtcbiAgfTtcblxuICB2YXIgcmVzdW1lU3VwcG9ydGVkID0gdGhpcy5pc1Jlc3VtZVN1cHBvcnRlZCgpO1xuXG4gIGZ1bmN0aW9uIHNlbmRIdHRwKGNvbmZpZykge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kIHx8ICdQT1NUJztcbiAgICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gICAgdmFyIGRlZmVycmVkID0gY29uZmlnLl9kZWZlcnJlZCA9IGNvbmZpZy5fZGVmZXJyZWQgfHwgJHEuZGVmZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG5cbiAgICBmdW5jdGlvbiBub3RpZnlQcm9ncmVzcyhlKSB7XG4gICAgICBpZiAoZGVmZXJyZWQubm90aWZ5KSB7XG4gICAgICAgIGRlZmVycmVkLm5vdGlmeShlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9taXNlLnByb2dyZXNzRnVuYykge1xuICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvbWlzZS5wcm9ncmVzc0Z1bmMoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE5vdGlmeUV2ZW50KG4pIHtcbiAgICAgIGlmIChjb25maWcuX3N0YXJ0ICE9IG51bGwgJiYgcmVzdW1lU3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG9hZGVkOiBuLmxvYWRlZCArIGNvbmZpZy5fc3RhcnQsXG4gICAgICAgICAgdG90YWw6IChjb25maWcuX2ZpbGUgJiYgY29uZmlnLl9maWxlLnNpemUpIHx8IG4udG90YWwsXG4gICAgICAgICAgdHlwZTogbi50eXBlLCBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiB0cnVlLCB0YXJnZXQ6IG4udGFyZ2V0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZy5kaXNhYmxlUHJvZ3Jlc3MpIHtcbiAgICAgIGNvbmZpZy5oZWFkZXJzLl9fc2V0WEhSXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgICBpZiAoIXhociB8fCAheGhyLnVwbG9hZCB8fCAheGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKSByZXR1cm47XG4gICAgICAgICAgY29uZmlnLl9fWEhSID0geGhyO1xuICAgICAgICAgIGlmIChjb25maWcueGhyRm4pIGNvbmZpZy54aHJGbih4aHIpO1xuICAgICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICBub3RpZnlQcm9ncmVzcyhnZXROb3RpZnlFdmVudChlKSk7XG4gICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIC8vZml4IGZvciBmaXJlZm94IG5vdCBmaXJpbmcgdXBsb2FkIHByb2dyZXNzIGVuZCwgYWxzbyBJRTgtOVxuICAgICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgIGUuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgICBub3RpZnlQcm9ncmVzcyhnZXROb3RpZnlFdmVudChlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGxvYWRXaXRoQW5ndWxhcigpIHtcbiAgICAgICRodHRwKGNvbmZpZykudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgIGlmIChyZXN1bWVTdXBwb3J0ZWQgJiYgY29uZmlnLl9jaHVua1NpemUgJiYgIWNvbmZpZy5fZmluaXNoZWQgJiYgY29uZmlnLl9maWxlKSB7XG4gICAgICAgICAgICB2YXIgZmlsZVNpemUgPSBjb25maWcuX2ZpbGUgJiYgY29uZmlnLl9maWxlLnNpemUgfHwgMDtcbiAgICAgICAgICAgIG5vdGlmeVByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IE1hdGgubWluKGNvbmZpZy5fZW5kLCBmaWxlU2l6ZSksXG4gICAgICAgICAgICAgICAgdG90YWw6IGZpbGVTaXplLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdwcm9ncmVzcydcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHVwbG9hZC51cGxvYWQoY29uZmlnLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZmluaXNoZWQpIGRlbGV0ZSBjb25maWcuX2ZpbmlzaGVkO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAobikge1xuICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShuKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3VtZVN1cHBvcnRlZCkge1xuICAgICAgdXBsb2FkV2l0aEFuZ3VsYXIoKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5fY2h1bmtTaXplICYmIGNvbmZpZy5fZW5kICYmICFjb25maWcuX2ZpbmlzaGVkKSB7XG4gICAgICBjb25maWcuX3N0YXJ0ID0gY29uZmlnLl9lbmQ7XG4gICAgICBjb25maWcuX2VuZCArPSBjb25maWcuX2NodW5rU2l6ZTtcbiAgICAgIHVwbG9hZFdpdGhBbmd1bGFyKCk7XG4gICAgfSBlbHNlIGlmIChjb25maWcucmVzdW1lU2l6ZVVybCkge1xuICAgICAgJGh0dHAuZ2V0KGNvbmZpZy5yZXN1bWVTaXplVXJsKS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgIGlmIChjb25maWcucmVzdW1lU2l6ZVJlc3BvbnNlUmVhZGVyKSB7XG4gICAgICAgICAgY29uZmlnLl9zdGFydCA9IGNvbmZpZy5yZXN1bWVTaXplUmVzcG9uc2VSZWFkZXIocmVzcC5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25maWcuX3N0YXJ0ID0gcGFyc2VJbnQoKHJlc3AuZGF0YS5zaXplID09IG51bGwgPyByZXNwLmRhdGEgOiByZXNwLmRhdGEuc2l6ZSkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fY2h1bmtTaXplKSB7XG4gICAgICAgICAgY29uZmlnLl9lbmQgPSBjb25maWcuX3N0YXJ0ICsgY29uZmlnLl9jaHVua1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgdXBsb2FkV2l0aEFuZ3VsYXIoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5yZXN1bWVTaXplKSB7XG4gICAgICBjb25maWcucmVzdW1lU2l6ZSgpLnRoZW4oZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgY29uZmlnLl9zdGFydCA9IHNpemU7XG4gICAgICAgIGlmIChjb25maWcuX2NodW5rU2l6ZSkge1xuICAgICAgICAgIGNvbmZpZy5fZW5kID0gY29uZmlnLl9zdGFydCArIGNvbmZpZy5fY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIHVwbG9hZFdpdGhBbmd1bGFyKCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb25maWcuX2NodW5rU2l6ZSkge1xuICAgICAgICBjb25maWcuX3N0YXJ0ID0gMDtcbiAgICAgICAgY29uZmlnLl9lbmQgPSBjb25maWcuX3N0YXJ0ICsgY29uZmlnLl9jaHVua1NpemU7XG4gICAgICB9XG4gICAgICB1cGxvYWRXaXRoQW5ndWxhcigpO1xuICAgIH1cblxuXG4gICAgcHJvbWlzZS5zdWNjZXNzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGZuKHJlc3BvbnNlLmRhdGEsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuaGVhZGVycywgY29uZmlnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIHByb21pc2UuZXJyb3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHByb21pc2UudGhlbihudWxsLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgZm4ocmVzcG9uc2UuZGF0YSwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5oZWFkZXJzLCBjb25maWcpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgcHJvbWlzZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcHJvbWlzZS5wcm9ncmVzc0Z1bmMgPSBmbjtcbiAgICAgIHByb21pc2UudGhlbihudWxsLCBudWxsLCBmdW5jdGlvbiAobikge1xuICAgICAgICBmbihuKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgICBwcm9taXNlLmFib3J0ID0gcHJvbWlzZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb25maWcuX19YSFIpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbmZpZy5fX1hIUi5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gICAgcHJvbWlzZS54aHIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGNvbmZpZy54aHJGbiA9IChmdW5jdGlvbiAob3JpZ1hockZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG9yaWdYaHJGbikgb3JpZ1hockZuLmFwcGx5KHByb21pc2UsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZm4uYXBwbHkocHJvbWlzZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKGNvbmZpZy54aHJGbik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgdXBsb2FkLnByb21pc2VzQ291bnQrKztcbiAgICBpZiAocHJvbWlzZVsnZmluYWxseSddICYmIHByb21pc2VbJ2ZpbmFsbHknXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBwcm9taXNlWydmaW5hbGx5J10oZnVuY3Rpb24gKCkge1xuICAgICAgICB1cGxvYWQucHJvbWlzZXNDb3VudC0tO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdGhpcy5pc1VwbG9hZEluUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVwbG9hZC5wcm9taXNlc0NvdW50ID4gMDtcbiAgfTtcblxuICB0aGlzLnJlbmFtZSA9IGZ1bmN0aW9uIChmaWxlLCBuYW1lKSB7XG4gICAgZmlsZS5uZ2ZOYW1lID0gbmFtZTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfTtcblxuICB0aGlzLmpzb25CbG9iID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICh2YWwgIT0gbnVsbCAmJiAhYW5ndWxhci5pc1N0cmluZyh2YWwpKSB7XG4gICAgICB2YWwgPSBKU09OLnN0cmluZ2lmeSh2YWwpO1xuICAgIH1cbiAgICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbdmFsXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ30pO1xuICAgIGJsb2IuX25nZkJsb2IgPSB0cnVlO1xuICAgIHJldHVybiBibG9iO1xuICB9O1xuXG4gIHRoaXMuanNvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gYW5ndWxhci50b0pzb24odmFsKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHZhciBjbG9uZSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjbG9uZVtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIHRoaXMuaXNGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICByZXR1cm4gZmlsZSAhPSBudWxsICYmIChmaWxlIGluc3RhbmNlb2Ygd2luZG93LkJsb2IgfHwgKGZpbGUuZmxhc2hJZCAmJiBmaWxlLm5hbWUgJiYgZmlsZS5zaXplKSk7XG4gIH07XG5cbiAgdGhpcy51cGxvYWQgPSBmdW5jdGlvbiAoY29uZmlnLCBpbnRlcm5hbCkge1xuICAgIGZ1bmN0aW9uIHRvUmVzdW1lRmlsZShmaWxlLCBmb3JtRGF0YSkge1xuICAgICAgaWYgKGZpbGUuX25nZkJsb2IpIHJldHVybiBmaWxlO1xuICAgICAgY29uZmlnLl9maWxlID0gY29uZmlnLl9maWxlIHx8IGZpbGU7XG4gICAgICBpZiAoY29uZmlnLl9zdGFydCAhPSBudWxsICYmIHJlc3VtZVN1cHBvcnRlZCkge1xuICAgICAgICBpZiAoY29uZmlnLl9lbmQgJiYgY29uZmlnLl9lbmQgPj0gZmlsZS5zaXplKSB7XG4gICAgICAgICAgY29uZmlnLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgY29uZmlnLl9lbmQgPSBmaWxlLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNsaWNlID0gZmlsZS5zbGljZShjb25maWcuX3N0YXJ0LCBjb25maWcuX2VuZCB8fCBmaWxlLnNpemUpO1xuICAgICAgICBzbGljZS5uYW1lID0gZmlsZS5uYW1lO1xuICAgICAgICBzbGljZS5uZ2ZOYW1lID0gZmlsZS5uZ2ZOYW1lO1xuICAgICAgICBpZiAoY29uZmlnLl9jaHVua1NpemUpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ19jaHVua1NpemUnLCBjb25maWcuX2NodW5rU2l6ZSk7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdfY3VycmVudENodW5rU2l6ZScsIGNvbmZpZy5fZW5kIC0gY29uZmlnLl9zdGFydCk7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdfY2h1bmtOdW1iZXInLCBNYXRoLmZsb29yKGNvbmZpZy5fc3RhcnQgLyBjb25maWcuX2NodW5rU2l6ZSkpO1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnX3RvdGFsU2l6ZScsIGNvbmZpZy5fZmlsZS5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRGaWVsZFRvRm9ybURhdGEoZm9ybURhdGEsIHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNEYXRlKHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSB2YWwudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ndWxhci5pc1N0cmluZyh2YWwpKSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsKTtcbiAgICAgICAgfSBlbHNlIGlmICh1cGxvYWQuaXNGaWxlKHZhbCkpIHtcbiAgICAgICAgICB2YXIgZmlsZSA9IHRvUmVzdW1lRmlsZSh2YWwsIGZvcm1EYXRhKTtcbiAgICAgICAgICB2YXIgc3BsaXQgPSBrZXkuc3BsaXQoJywnKTtcbiAgICAgICAgICBpZiAoc3BsaXRbMV0pIHtcbiAgICAgICAgICAgIGZpbGUubmdmTmFtZSA9IHNwbGl0WzFdLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICAgICAgICAgIGtleSA9IHNwbGl0WzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25maWcuX2ZpbGVLZXkgPSBjb25maWcuX2ZpbGVLZXkgfHwga2V5O1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIGZpbGUsIGZpbGUubmdmTmFtZSB8fCBmaWxlLm5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgIGlmICh2YWwuJCRuZ2ZDaXJjdWxhckRldGVjdGlvbikgdGhyb3cgJ25nRmlsZVVwbG9hZDogQ2lyY3VsYXIgcmVmZXJlbmNlIGluIGNvbmZpZy5kYXRhLiBNYWtlIHN1cmUgc3BlY2lmaWVkIGRhdGEgZm9yIFVwbG9hZC51cGxvYWQoKSBoYXMgbm8gY2lyY3VsYXIgcmVmZXJlbmNlOiAnICsga2V5O1xuXG4gICAgICAgICAgICB2YWwuJCRuZ2ZDaXJjdWxhckRldGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIHZhbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwuaGFzT3duUHJvcGVydHkoaykgJiYgayAhPT0gJyQkbmdmQ2lyY3VsYXJEZXRlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0S2V5ID0gY29uZmlnLm9iamVjdEtleSA9PSBudWxsID8gJ1tpXScgOiBjb25maWcub2JqZWN0S2V5O1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggJiYgcGFyc2VJbnQoaykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RLZXkgPSBjb25maWcuYXJyYXlLZXkgPT0gbnVsbCA/IG9iamVjdEtleSA6IGNvbmZpZy5hcnJheUtleTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFkZEZpZWxkVG9Gb3JtRGF0YShmb3JtRGF0YSwgdmFsW2tdLCBrZXkgKyBvYmplY3RLZXkucmVwbGFjZSgvW2lrXS9nLCBrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBkZWxldGUgdmFsLiQkbmdmQ2lyY3VsYXJEZXRlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlnZXN0Q29uZmlnKCkge1xuICAgICAgY29uZmlnLl9jaHVua1NpemUgPSB1cGxvYWQudHJhbnNsYXRlU2NhbGFycyhjb25maWcucmVzdW1lQ2h1bmtTaXplKTtcbiAgICAgIGNvbmZpZy5fY2h1bmtTaXplID0gY29uZmlnLl9jaHVua1NpemUgPyBwYXJzZUludChjb25maWcuX2NodW5rU2l6ZS50b1N0cmluZygpKSA6IG51bGw7XG5cbiAgICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgICBjb25maWcuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB1bmRlZmluZWQ7XG4gICAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdCA9IGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0ID9cbiAgICAgICAgKGFuZ3VsYXIuaXNBcnJheShjb25maWcudHJhbnNmb3JtUmVxdWVzdCkgP1xuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0IDogW2NvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XSkgOiBbXTtcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0LnB1c2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IHdpbmRvdy5Gb3JtRGF0YSgpLCBrZXk7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IGNvbmZpZy5maWVsZHMgfHwge307XG4gICAgICAgIGlmIChjb25maWcuZmlsZSkge1xuICAgICAgICAgIGRhdGEuZmlsZSA9IGNvbmZpZy5maWxlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5mb3JtRGF0YUFwcGVuZGVyKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5mb3JtRGF0YUFwcGVuZGVyKGZvcm1EYXRhLCBrZXksIHZhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRGaWVsZFRvRm9ybURhdGEoZm9ybURhdGEsIHZhbCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWludGVybmFsKSBjb25maWcgPSBjb3B5KGNvbmZpZyk7XG4gICAgaWYgKCFjb25maWcuX2lzRGlnZXN0ZWQpIHtcbiAgICAgIGNvbmZpZy5faXNEaWdlc3RlZCA9IHRydWU7XG4gICAgICBkaWdlc3RDb25maWcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VuZEh0dHAoY29uZmlnKTtcbiAgfTtcblxuICB0aGlzLmh0dHAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgY29uZmlnID0gY29weShjb25maWcpO1xuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0ID0gY29uZmlnLnRyYW5zZm9ybVJlcXVlc3QgfHwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCh3aW5kb3cuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIHdpbmRvdy5BcnJheUJ1ZmZlcikgfHwgZGF0YSBpbnN0YW5jZW9mIHdpbmRvdy5CbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRodHRwLmRlZmF1bHRzLnRyYW5zZm9ybVJlcXVlc3RbMF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY29uZmlnLl9jaHVua1NpemUgPSB1cGxvYWQudHJhbnNsYXRlU2NhbGFycyhjb25maWcucmVzdW1lQ2h1bmtTaXplKTtcbiAgICBjb25maWcuX2NodW5rU2l6ZSA9IGNvbmZpZy5fY2h1bmtTaXplID8gcGFyc2VJbnQoY29uZmlnLl9jaHVua1NpemUudG9TdHJpbmcoKSkgOiBudWxsO1xuXG4gICAgcmV0dXJuIHNlbmRIdHRwKGNvbmZpZyk7XG4gIH07XG5cbiAgdGhpcy50cmFuc2xhdGVTY2FsYXJzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHN0cikpIHtcbiAgICAgIGlmIChzdHIuc2VhcmNoKC9rYi9pKSA9PT0gc3RyLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMikgKiAxMDI0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyLnNlYXJjaCgvbWIvaSkgPT09IHN0ci5sZW5ndGggLSAyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDIpICogMTA0ODU3Nik7XG4gICAgICB9IGVsc2UgaWYgKHN0ci5zZWFyY2goL2diL2kpID09PSBzdHIubGVuZ3RoIC0gMikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAyKSAqIDEwNzM3NDE4MjQpO1xuICAgICAgfSBlbHNlIGlmIChzdHIuc2VhcmNoKC9iL2kpID09PSBzdHIubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0ci5zZWFyY2goL3MvaSkgPT09IHN0ci5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyLnNlYXJjaCgvbS9pKSA9PT0gc3RyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSkgKiA2MCk7XG4gICAgICB9IGVsc2UgaWYgKHN0ci5zZWFyY2goL2gvaSkgPT09IHN0ci5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpICogMzYwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgdGhpcy51cmxUb0Jsb2IgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB2YXIgZGVmZXIgPSAkcS5kZWZlcigpO1xuICAgICRodHRwKHt1cmw6IHVybCwgbWV0aG9kOiAnZ2V0JywgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInfSkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgdmFyIGFycmF5QnVmZmVyVmlldyA9IG5ldyBVaW50OEFycmF5KHJlc3AuZGF0YSk7XG4gICAgICB2YXIgdHlwZSA9IHJlc3AuaGVhZGVycygnY29udGVudC10eXBlJykgfHwgJ2ltYWdlL1dlYlAnO1xuICAgICAgdmFyIGJsb2IgPSBuZXcgd2luZG93LkJsb2IoW2FycmF5QnVmZmVyVmlld10sIHt0eXBlOiB0eXBlfSk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHVybC5tYXRjaCgvLipcXC8oLis/KShcXD8uKik/JC8pO1xuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBibG9iLm5hbWUgPSBtYXRjaGVzWzFdO1xuICAgICAgfVxuICAgICAgZGVmZXIucmVzb2x2ZShibG9iKTtcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgZGVmZXIucmVqZWN0KGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlci5wcm9taXNlO1xuICB9O1xuXG4gIHRoaXMuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmYXVsdHMpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHMgfHwge307XG4gIH07XG5cbiAgdGhpcy5kZWZhdWx0cyA9IHt9O1xuICB0aGlzLnZlcnNpb24gPSBuZ0ZpbGVVcGxvYWQudmVyc2lvbjtcbn1cblxuXSk7XG5cbm5nRmlsZVVwbG9hZC5zZXJ2aWNlKCdVcGxvYWQnLCBbJyRwYXJzZScsICckdGltZW91dCcsICckY29tcGlsZScsICckcScsICdVcGxvYWRFeGlmJywgZnVuY3Rpb24gKCRwYXJzZSwgJHRpbWVvdXQsICRjb21waWxlLCAkcSwgVXBsb2FkRXhpZikge1xuICB2YXIgdXBsb2FkID0gVXBsb2FkRXhpZjtcbiAgdXBsb2FkLmdldEF0dHJXaXRoRGVmYXVsdHMgPSBmdW5jdGlvbiAoYXR0ciwgbmFtZSkge1xuICAgIGlmIChhdHRyW25hbWVdICE9IG51bGwpIHJldHVybiBhdHRyW25hbWVdO1xuICAgIHZhciBkZWYgPSB1cGxvYWQuZGVmYXVsdHNbbmFtZV07XG4gICAgcmV0dXJuIChkZWYgPT0gbnVsbCA/IGRlZiA6IChhbmd1bGFyLmlzU3RyaW5nKGRlZikgPyBkZWYgOiBKU09OLnN0cmluZ2lmeShkZWYpKSk7XG4gIH07XG5cbiAgdXBsb2FkLmF0dHJHZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSwgYXR0ciwgc2NvcGUsIHBhcmFtcykge1xuICAgIHZhciBhdHRyVmFsID0gdGhpcy5nZXRBdHRyV2l0aERlZmF1bHRzKGF0dHIsIG5hbWUpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgIHJldHVybiAkcGFyc2UoYXR0clZhbCkoc2NvcGUsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRwYXJzZShhdHRyVmFsKShzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaGFuZ2xlIHN0cmluZyB2YWx1ZSB3aXRob3V0IHNpbmdsZSBxb3V0ZVxuICAgICAgICBpZiAobmFtZS5zZWFyY2goL21pbnxtYXh8cGF0dGVybi9pKSkge1xuICAgICAgICAgIHJldHVybiBhdHRyVmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF0dHJWYWw7XG4gICAgfVxuICB9O1xuXG4gIHVwbG9hZC5zaG91bGRVcGRhdGVPbiA9IGZ1bmN0aW9uICh0eXBlLCBhdHRyLCBzY29wZSkge1xuICAgIHZhciBtb2RlbE9wdGlvbnMgPSB1cGxvYWQuYXR0ckdldHRlcignbmdmTW9kZWxPcHRpb25zJywgYXR0ciwgc2NvcGUpO1xuICAgIGlmIChtb2RlbE9wdGlvbnMgJiYgbW9kZWxPcHRpb25zLnVwZGF0ZU9uKSB7XG4gICAgICByZXR1cm4gbW9kZWxPcHRpb25zLnVwZGF0ZU9uLnNwbGl0KCcgJykuaW5kZXhPZih0eXBlKSA+IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB1cGxvYWQuZW1wdHlQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkID0gJHEuZGVmZXIoKTtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkLnJlc29sdmUuYXBwbHkoZCwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgfTtcblxuICB1cGxvYWQucmVqZWN0UHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZCA9ICRxLmRlZmVyKCk7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZC5yZWplY3QuYXBwbHkoZCwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgfTtcblxuICB1cGxvYWQuaGFwcHlQcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UsIGRhdGEpIHtcbiAgICB2YXIgZCA9ICRxLmRlZmVyKCk7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIGQucmVzb2x2ZShyZXN1bHQpO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuICAgICAgZC5yZXNvbHZlKGRhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiBkLnByb21pc2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXBwbHlFeGlmUm90YXRpb25zKGZpbGVzLCBhdHRyLCBzY29wZSkge1xuICAgIHZhciBwcm9taXNlcyA9IFt1cGxvYWQuZW1wdHlQcm9taXNlKCldO1xuICAgIGFuZ3VsYXIuZm9yRWFjaChmaWxlcywgZnVuY3Rpb24gKGYsIGkpIHtcbiAgICAgIGlmIChmLnR5cGUuaW5kZXhPZignaW1hZ2UvanBlZycpID09PSAwICYmIHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZGaXhPcmllbnRhdGlvbicsIGF0dHIsIHNjb3BlLCB7JGZpbGU6IGZ9KSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKHVwbG9hZC5oYXBweVByb21pc2UodXBsb2FkLmFwcGx5RXhpZlJvdGF0aW9uKGYpLCBmKS50aGVuKGZ1bmN0aW9uIChmaXhlZEZpbGUpIHtcbiAgICAgICAgICBmaWxlcy5zcGxpY2UoaSwgMSwgZml4ZWRGaWxlKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzaXplRmlsZShmaWxlcywgYXR0ciwgc2NvcGUsIG5nTW9kZWwpIHtcbiAgICB2YXIgcmVzaXplVmFsID0gdXBsb2FkLmF0dHJHZXR0ZXIoJ25nZlJlc2l6ZScsIGF0dHIsIHNjb3BlKTtcbiAgICBpZiAoIXJlc2l6ZVZhbCB8fCAhdXBsb2FkLmlzUmVzaXplU3VwcG9ydGVkKCkgfHwgIWZpbGVzLmxlbmd0aCkgcmV0dXJuIHVwbG9hZC5lbXB0eVByb21pc2UoKTtcbiAgICBpZiAocmVzaXplVmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG4gICAgICByZXR1cm4gcmVzaXplVmFsKGZpbGVzKS50aGVuKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJlc2l6ZVdpdGhQYXJhbXMocCwgZmlsZXMsIGF0dHIsIHNjb3BlLCBuZ01vZGVsKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgZGVmZXIucmVzb2x2ZShyKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZGVmZXIucmVqZWN0KGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNpemVXaXRoUGFyYW1zKHJlc2l6ZVZhbCwgZmlsZXMsIGF0dHIsIHNjb3BlLCBuZ01vZGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNpemVXaXRoUGFyYW1zKHBhcmFtcywgZmlsZXMsIGF0dHIsIHNjb3BlLCBuZ01vZGVsKSB7XG4gICAgdmFyIHByb21pc2VzID0gW3VwbG9hZC5lbXB0eVByb21pc2UoKV07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVGaWxlKGYsIGkpIHtcbiAgICAgIGlmIChmLnR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuICAgICAgICBpZiAocGFyYW1zLnBhdHRlcm4gJiYgIXVwbG9hZC52YWxpZGF0ZVBhdHRlcm4oZiwgcGFyYW1zLnBhdHRlcm4pKSByZXR1cm47XG4gICAgICAgIHBhcmFtcy5yZXNpemVJZiA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZSZXNpemVJZicsIGF0dHIsIHNjb3BlLFxuICAgICAgICAgICAgeyR3aWR0aDogd2lkdGgsICRoZWlnaHQ6IGhlaWdodCwgJGZpbGU6IGZ9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB1cGxvYWQucmVzaXplKGYsIHBhcmFtcyk7XG4gICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzaXplZEZpbGUpIHtcbiAgICAgICAgICBmaWxlcy5zcGxpY2UoaSwgMSwgcmVzaXplZEZpbGUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGYuJGVycm9yID0gJ3Jlc2l6ZSc7XG4gICAgICAgICAgKGYuJGVycm9yTWVzc2FnZXMgPSAoZi4kZXJyb3JNZXNzYWdlcyB8fCB7fSkpLnJlc2l6ZSA9IHRydWU7XG4gICAgICAgICAgZi4kZXJyb3JQYXJhbSA9IChlID8gKGUubWVzc2FnZSA/IGUubWVzc2FnZSA6IGUpICsgJzogJyA6ICcnKSArIChmICYmIGYubmFtZSk7XG4gICAgICAgICAgbmdNb2RlbC4kbmdmVmFsaWRhdGlvbnMucHVzaCh7bmFtZTogJ3Jlc2l6ZScsIHZhbGlkOiBmYWxzZX0pO1xuICAgICAgICAgIHVwbG9hZC5hcHBseU1vZGVsVmFsaWRhdGlvbihuZ01vZGVsLCBmaWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZUZpbGUoZmlsZXNbaV0sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcbiAgfVxuXG4gIHVwbG9hZC51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIChuZ01vZGVsLCBhdHRyLCBzY29wZSwgZmlsZUNoYW5nZSwgZmlsZXMsIGV2dCwgbm9EZWxheSkge1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShmaWxlcywgaW52YWxpZEZpbGVzLCBuZXdGaWxlcywgZHVwRmlsZXMsIGlzU2luZ2xlTW9kZWwpIHtcbiAgICAgIGF0dHIuJCRuZ2ZQcmV2VmFsaWRGaWxlcyA9IGZpbGVzO1xuICAgICAgYXR0ci4kJG5nZlByZXZJbnZhbGlkRmlsZXMgPSBpbnZhbGlkRmlsZXM7XG4gICAgICB2YXIgZmlsZSA9IGZpbGVzICYmIGZpbGVzLmxlbmd0aCA/IGZpbGVzWzBdIDogbnVsbDtcbiAgICAgIHZhciBpbnZhbGlkRmlsZSA9IGludmFsaWRGaWxlcyAmJiBpbnZhbGlkRmlsZXMubGVuZ3RoID8gaW52YWxpZEZpbGVzWzBdIDogbnVsbDtcblxuICAgICAgaWYgKG5nTW9kZWwpIHtcbiAgICAgICAgdXBsb2FkLmFwcGx5TW9kZWxWYWxpZGF0aW9uKG5nTW9kZWwsIGZpbGVzKTtcbiAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKGlzU2luZ2xlTW9kZWwgPyBmaWxlIDogZmlsZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsZUNoYW5nZSkge1xuICAgICAgICAkcGFyc2UoZmlsZUNoYW5nZSkoc2NvcGUsIHtcbiAgICAgICAgICAkZmlsZXM6IGZpbGVzLFxuICAgICAgICAgICRmaWxlOiBmaWxlLFxuICAgICAgICAgICRuZXdGaWxlczogbmV3RmlsZXMsXG4gICAgICAgICAgJGR1cGxpY2F0ZUZpbGVzOiBkdXBGaWxlcyxcbiAgICAgICAgICAkaW52YWxpZEZpbGVzOiBpbnZhbGlkRmlsZXMsXG4gICAgICAgICAgJGludmFsaWRGaWxlOiBpbnZhbGlkRmlsZSxcbiAgICAgICAgICAkZXZlbnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGludmFsaWRNb2RlbCA9IHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZNb2RlbEludmFsaWQnLCBhdHRyKTtcbiAgICAgIGlmIChpbnZhbGlkTW9kZWwpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICRwYXJzZShpbnZhbGlkTW9kZWwpLmFzc2lnbihzY29wZSwgaXNTaW5nbGVNb2RlbCA/IGludmFsaWRGaWxlIDogaW52YWxpZEZpbGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHNjb3BlIGFwcGx5IGNoYW5nZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhbGxOZXdGaWxlcywgZHVwRmlsZXMgPSBbXSwgcHJldlZhbGlkRmlsZXMsIHByZXZJbnZhbGlkRmlsZXMsXG4gICAgICBpbnZhbGlkcyA9IFtdLCB2YWxpZHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMoKSB7XG4gICAgICBmdW5jdGlvbiBlcXVhbHMoZjEsIGYyKSB7XG4gICAgICAgIHJldHVybiBmMS5uYW1lID09PSBmMi5uYW1lICYmIChmMS4kbmdmT3JpZ1NpemUgfHwgZjEuc2l6ZSkgPT09IChmMi4kbmdmT3JpZ1NpemUgfHwgZjIuc2l6ZSkgJiZcbiAgICAgICAgICBmMS50eXBlID09PSBmMi50eXBlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0luUHJldkZpbGVzKGYpIHtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBwcmV2VmFsaWRGaWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChlcXVhbHMoZiwgcHJldlZhbGlkRmlsZXNbal0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHByZXZJbnZhbGlkRmlsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoZXF1YWxzKGYsIHByZXZJbnZhbGlkRmlsZXNbal0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsZXMpIHtcbiAgICAgICAgYWxsTmV3RmlsZXMgPSBbXTtcbiAgICAgICAgZHVwRmlsZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpc0luUHJldkZpbGVzKGZpbGVzW2ldKSkge1xuICAgICAgICAgICAgZHVwRmlsZXMucHVzaChmaWxlc1tpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsbE5ld0ZpbGVzLnB1c2goZmlsZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkodikge1xuICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNBcnJheSh2KSA/IHYgOiBbdl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplQW5kVXBkYXRlKCkge1xuICAgICAgZnVuY3Rpb24gdXBkYXRlTW9kZWwoKSB7XG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1cGRhdGUoa2VlcCA/IHByZXZWYWxpZEZpbGVzLmNvbmNhdCh2YWxpZHMpIDogdmFsaWRzLFxuICAgICAgICAgICAga2VlcCA/IHByZXZJbnZhbGlkRmlsZXMuY29uY2F0KGludmFsaWRzKSA6IGludmFsaWRzLFxuICAgICAgICAgICAgZmlsZXMsIGR1cEZpbGVzLCBpc1NpbmdsZU1vZGVsKTtcbiAgICAgICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmRlYm91bmNlID8gb3B0aW9ucy5kZWJvdW5jZS5jaGFuZ2UgfHwgb3B0aW9ucy5kZWJvdW5jZSA6IDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzaXppbmdGaWxlcyA9IHZhbGlkYXRlQWZ0ZXJSZXNpemUgPyBhbGxOZXdGaWxlcyA6IHZhbGlkcztcbiAgICAgIHJlc2l6ZUZpbGUocmVzaXppbmdGaWxlcywgYXR0ciwgc2NvcGUsIG5nTW9kZWwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodmFsaWRhdGVBZnRlclJlc2l6ZSkge1xuICAgICAgICAgIHVwbG9hZC52YWxpZGF0ZShhbGxOZXdGaWxlcywga2VlcCA/IHByZXZWYWxpZEZpbGVzLmxlbmd0aCA6IDAsIG5nTW9kZWwsIGF0dHIsIHNjb3BlKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgdmFsaWRzID0gdmFsaWRhdGlvblJlc3VsdC52YWxpZHNGaWxlcztcbiAgICAgICAgICAgICAgaW52YWxpZHMgPSB2YWxpZGF0aW9uUmVzdWx0LmludmFsaWRzRmlsZXM7XG4gICAgICAgICAgICAgIHVwZGF0ZU1vZGVsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cGRhdGVNb2RlbCgpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzaXppbmdGaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBmID0gcmVzaXppbmdGaWxlc1tpXTtcbiAgICAgICAgICBpZiAoZi4kZXJyb3IgPT09ICdyZXNpemUnKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB2YWxpZHMuaW5kZXhPZihmKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgIHZhbGlkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICBpbnZhbGlkcy5wdXNoKGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTW9kZWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHByZXZWYWxpZEZpbGVzID0gYXR0ci4kJG5nZlByZXZWYWxpZEZpbGVzIHx8IFtdO1xuICAgIHByZXZJbnZhbGlkRmlsZXMgPSBhdHRyLiQkbmdmUHJldkludmFsaWRGaWxlcyB8fCBbXTtcbiAgICBpZiAobmdNb2RlbCAmJiBuZ01vZGVsLiRtb2RlbFZhbHVlKSB7XG4gICAgICBwcmV2VmFsaWRGaWxlcyA9IHRvQXJyYXkobmdNb2RlbC4kbW9kZWxWYWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGtlZXAgPSB1cGxvYWQuYXR0ckdldHRlcignbmdmS2VlcCcsIGF0dHIsIHNjb3BlKTtcbiAgICBhbGxOZXdGaWxlcyA9IChmaWxlcyB8fCBbXSkuc2xpY2UoMCk7XG4gICAgaWYgKGtlZXAgPT09ICdkaXN0aW5jdCcgfHwgdXBsb2FkLmF0dHJHZXR0ZXIoJ25nZktlZXBEaXN0aW5jdCcsIGF0dHIsIHNjb3BlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmVtb3ZlRHVwbGljYXRlcyhhdHRyLCBzY29wZSk7XG4gICAgfVxuXG4gICAgdmFyIGlzU2luZ2xlTW9kZWwgPSAha2VlcCAmJiAhdXBsb2FkLmF0dHJHZXR0ZXIoJ25nZk11bHRpcGxlJywgYXR0ciwgc2NvcGUpICYmICF1cGxvYWQuYXR0ckdldHRlcignbXVsdGlwbGUnLCBhdHRyKTtcblxuICAgIGlmIChrZWVwICYmICFhbGxOZXdGaWxlcy5sZW5ndGgpIHJldHVybjtcblxuICAgIHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZCZWZvcmVNb2RlbENoYW5nZScsIGF0dHIsIHNjb3BlLCB7XG4gICAgICAkZmlsZXM6IGZpbGVzLFxuICAgICAgJGZpbGU6IGZpbGVzICYmIGZpbGVzLmxlbmd0aCA/IGZpbGVzWzBdIDogbnVsbCxcbiAgICAgICRuZXdGaWxlczogYWxsTmV3RmlsZXMsXG4gICAgICAkZHVwbGljYXRlRmlsZXM6IGR1cEZpbGVzLFxuICAgICAgJGV2ZW50OiBldnRcbiAgICB9KTtcblxuICAgIHZhciB2YWxpZGF0ZUFmdGVyUmVzaXplID0gdXBsb2FkLmF0dHJHZXR0ZXIoJ25nZlZhbGlkYXRlQWZ0ZXJSZXNpemUnLCBhdHRyLCBzY29wZSk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZNb2RlbE9wdGlvbnMnLCBhdHRyLCBzY29wZSk7XG4gICAgdXBsb2FkLnZhbGlkYXRlKGFsbE5ld0ZpbGVzLCBrZWVwID8gcHJldlZhbGlkRmlsZXMubGVuZ3RoIDogMCwgbmdNb2RlbCwgYXR0ciwgc2NvcGUpXG4gICAgICAudGhlbihmdW5jdGlvbiAodmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgaWYgKG5vRGVsYXkpIHtcbiAgICAgICAgdXBkYXRlKGFsbE5ld0ZpbGVzLCBbXSwgZmlsZXMsIGR1cEZpbGVzLCBpc1NpbmdsZU1vZGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoIW9wdGlvbnMgfHwgIW9wdGlvbnMuYWxsb3dJbnZhbGlkKSAmJiAhdmFsaWRhdGVBZnRlclJlc2l6ZSkge1xuICAgICAgICAgIHZhbGlkcyA9IHZhbGlkYXRpb25SZXN1bHQudmFsaWRGaWxlcztcbiAgICAgICAgICBpbnZhbGlkcyA9IHZhbGlkYXRpb25SZXN1bHQuaW52YWxpZEZpbGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkcyA9IGFsbE5ld0ZpbGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGxvYWQuYXR0ckdldHRlcignbmdmRml4T3JpZW50YXRpb24nLCBhdHRyLCBzY29wZSkgJiYgdXBsb2FkLmlzRXhpZlN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgYXBwbHlFeGlmUm90YXRpb25zKHZhbGlkcywgYXR0ciwgc2NvcGUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzaXplQW5kVXBkYXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzaXplQW5kVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gdXBsb2FkO1xufV0pO1xuXG5uZ0ZpbGVVcGxvYWQuZGlyZWN0aXZlKCduZ2ZTZWxlY3QnLCBbJyRwYXJzZScsICckdGltZW91dCcsICckY29tcGlsZScsICdVcGxvYWQnLCBmdW5jdGlvbiAoJHBhcnNlLCAkdGltZW91dCwgJGNvbXBpbGUsIFVwbG9hZCkge1xuICB2YXIgZ2VuZXJhdGVkRWxlbXMgPSBbXTtcblxuICBmdW5jdGlvbiBpc0RlbGF5ZWRDbGlja1N1cHBvcnRlZCh1YSkge1xuICAgIC8vIGZpeCBmb3IgYW5kcm9pZCBuYXRpdmUgYnJvd3NlciA8IDQuNCBhbmQgc2FmYXJpIHdpbmRvd3NcbiAgICB2YXIgbSA9IHVhLm1hdGNoKC9BbmRyb2lkW15cXGRdKihcXGQrKVxcLihcXGQrKS8pO1xuICAgIGlmIChtICYmIG0ubGVuZ3RoID4gMikge1xuICAgICAgdmFyIHYgPSBVcGxvYWQuZGVmYXVsdHMuYW5kcm9pZEZpeE1pbm9yVmVyc2lvbiB8fCA0O1xuICAgICAgcmV0dXJuIHBhcnNlSW50KG1bMV0pIDwgNCB8fCAocGFyc2VJbnQobVsxXSkgPT09IHYgJiYgcGFyc2VJbnQobVsyXSkgPCB2KTtcbiAgICB9XG5cbiAgICAvLyBzYWZhcmkgb24gd2luZG93c1xuICAgIHJldHVybiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgLy4qV2luZG93cy4qU2FmYXJpLiovLnRlc3QodWEpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlua0ZpbGVTZWxlY3Qoc2NvcGUsIGVsZW0sIGF0dHIsIG5nTW9kZWwsICRwYXJzZSwgJHRpbWVvdXQsICRjb21waWxlLCB1cGxvYWQpIHtcbiAgICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZlNlbGVjdCAqL1xuICAgIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmQ2hhbmdlICovXG4gICAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ01vZGVsICovXG4gICAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ2ZNb2RlbE9wdGlvbnMgKi9cbiAgICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZk11bHRpcGxlICovXG4gICAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ2ZDYXB0dXJlICovXG4gICAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ2ZWYWxpZGF0ZSAqL1xuICAgIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmS2VlcCAqL1xuICAgIHZhciBhdHRyR2V0dGVyID0gZnVuY3Rpb24gKG5hbWUsIHNjb3BlKSB7XG4gICAgICByZXR1cm4gdXBsb2FkLmF0dHJHZXR0ZXIobmFtZSwgYXR0ciwgc2NvcGUpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc0lucHV0VHlwZUZpbGUoKSB7XG4gICAgICByZXR1cm4gZWxlbVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgYXR0ci50eXBlICYmIGF0dHIudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZmlsZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsZUNoYW5nZUF0dHIoKSB7XG4gICAgICByZXR1cm4gYXR0ckdldHRlcignbmdmQ2hhbmdlJykgfHwgYXR0ckdldHRlcignbmdmU2VsZWN0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlRm4oZXZ0KSB7XG4gICAgICBpZiAodXBsb2FkLnNob3VsZFVwZGF0ZU9uKCdjaGFuZ2UnLCBhdHRyLCBzY29wZSkpIHtcbiAgICAgICAgdmFyIGZpbGVMaXN0ID0gZXZ0Ll9fZmlsZXNfIHx8IChldnQudGFyZ2V0ICYmIGV2dC50YXJnZXQuZmlsZXMpLCBmaWxlcyA9IFtdO1xuICAgICAgICAvKiBIYW5kbGUgZHVwbGljYXRlIGNhbGwgaW4gIElFMTEgKi9cbiAgICAgICAgaWYgKCFmaWxlTGlzdCkgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZmlsZXMucHVzaChmaWxlTGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBsb2FkLnVwZGF0ZU1vZGVsKG5nTW9kZWwsIGF0dHIsIHNjb3BlLCBmaWxlQ2hhbmdlQXR0cigpLFxuICAgICAgICAgIGZpbGVzLmxlbmd0aCA/IGZpbGVzIDogbnVsbCwgZXZ0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGxvYWQucmVnaXN0ZXJNb2RlbENoYW5nZVZhbGlkYXRvcihuZ01vZGVsLCBhdHRyLCBzY29wZSk7XG5cbiAgICB2YXIgdW53YXRjaGVzID0gW107XG4gICAgaWYgKGF0dHJHZXR0ZXIoJ25nZk11bHRpcGxlJykpIHtcbiAgICAgIHVud2F0Y2hlcy5wdXNoKHNjb3BlLiR3YXRjaChhdHRyR2V0dGVyKCduZ2ZNdWx0aXBsZScpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZpbGVFbGVtLmF0dHIoJ211bHRpcGxlJywgYXR0ckdldHRlcignbmdmTXVsdGlwbGUnLCBzY29wZSkpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoYXR0ckdldHRlcignbmdmQ2FwdHVyZScpKSB7XG4gICAgICB1bndhdGNoZXMucHVzaChzY29wZS4kd2F0Y2goYXR0ckdldHRlcignbmdmQ2FwdHVyZScpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZpbGVFbGVtLmF0dHIoJ2NhcHR1cmUnLCBhdHRyR2V0dGVyKCduZ2ZDYXB0dXJlJywgc2NvcGUpKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGF0dHJHZXR0ZXIoJ25nZkFjY2VwdCcpKSB7XG4gICAgICB1bndhdGNoZXMucHVzaChzY29wZS4kd2F0Y2goYXR0ckdldHRlcignbmdmQWNjZXB0JyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmlsZUVsZW0uYXR0cignYWNjZXB0JywgYXR0ckdldHRlcignbmdmQWNjZXB0Jywgc2NvcGUpKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdW53YXRjaGVzLnB1c2goYXR0ci4kb2JzZXJ2ZSgnYWNjZXB0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZmlsZUVsZW0uYXR0cignYWNjZXB0JywgYXR0ckdldHRlcignYWNjZXB0JykpO1xuICAgIH0pKTtcbiAgICBmdW5jdGlvbiBiaW5kQXR0clRvRmlsZUlucHV0KGZpbGVFbGVtLCBsYWJlbCkge1xuICAgICAgZnVuY3Rpb24gdXBkYXRlSWQodmFsKSB7XG4gICAgICAgIGZpbGVFbGVtLmF0dHIoJ2lkJywgJ25nZi0nICsgdmFsKTtcbiAgICAgICAgbGFiZWwuYXR0cignaWQnLCAnbmdmLWxhYmVsLScgKyB2YWwpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1bMF0uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gZWxlbVswXS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICBpZiAoYXR0cmlidXRlLm5hbWUgIT09ICd0eXBlJyAmJiBhdHRyaWJ1dGUubmFtZSAhPT0gJ2NsYXNzJyAmJiBhdHRyaWJ1dGUubmFtZSAhPT0gJ3N0eWxlJykge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGUubmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgdXBkYXRlSWQoYXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgICAgIHVud2F0Y2hlcy5wdXNoKGF0dHIuJG9ic2VydmUoJ2lkJywgdXBkYXRlSWQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsZUVsZW0uYXR0cihhdHRyaWJ1dGUubmFtZSwgKCFhdHRyaWJ1dGUudmFsdWUgJiYgKGF0dHJpYnV0ZS5uYW1lID09PSAncmVxdWlyZWQnIHx8XG4gICAgICAgICAgICBhdHRyaWJ1dGUubmFtZSA9PT0gJ211bHRpcGxlJykpID8gYXR0cmlidXRlLm5hbWUgOiBhdHRyaWJ1dGUudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbGVJbnB1dCgpIHtcbiAgICAgIGlmIChpc0lucHV0VHlwZUZpbGUoKSkge1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbGVFbGVtID0gYW5ndWxhci5lbGVtZW50KCc8aW5wdXQgdHlwZT1cImZpbGVcIj4nKTtcblxuICAgICAgdmFyIGxhYmVsID0gYW5ndWxhci5lbGVtZW50KCc8bGFiZWw+dXBsb2FkPC9sYWJlbD4nKTtcbiAgICAgIGxhYmVsLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKS5jc3MoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJykuY3NzKCdvdmVyZmxvdycsICdoaWRkZW4nKVxuICAgICAgICAuY3NzKCd3aWR0aCcsICcwcHgnKS5jc3MoJ2hlaWdodCcsICcwcHgnKS5jc3MoJ2JvcmRlcicsICdub25lJylcbiAgICAgICAgLmNzcygnbWFyZ2luJywgJzBweCcpLmNzcygncGFkZGluZycsICcwcHgnKS5hdHRyKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgYmluZEF0dHJUb0ZpbGVJbnB1dChmaWxlRWxlbSwgbGFiZWwpO1xuXG4gICAgICBnZW5lcmF0ZWRFbGVtcy5wdXNoKHtlbDogZWxlbSwgcmVmOiBsYWJlbH0pO1xuXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxhYmVsLmFwcGVuZChmaWxlRWxlbSlbMF0pO1xuXG4gICAgICByZXR1cm4gZmlsZUVsZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGV2dCkge1xuICAgICAgaWYgKGVsZW0uYXR0cignZGlzYWJsZWQnKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGF0dHJHZXR0ZXIoJ25nZlNlbGVjdERpc2FibGVkJywgc2NvcGUpKSByZXR1cm47XG5cbiAgICAgIHZhciByID0gZGV0ZWN0U3dpcGUoZXZ0KTtcbiAgICAgIC8vIHByZXZlbnQgdGhlIGNsaWNrIGlmIGl0IGlzIGEgc3dpcGVcbiAgICAgIGlmIChyICE9IG51bGwpIHJldHVybiByO1xuXG4gICAgICByZXNldE1vZGVsKGV2dCk7XG5cbiAgICAgIC8vIGZpeCBmb3IgbWQgd2hlbiB0aGUgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSBhbmQgYWRkZWQgYmFjayAjNDYwXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlzSW5wdXRUeXBlRmlsZSgpICYmICFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGZpbGVFbGVtWzBdKSkge1xuICAgICAgICAgIGdlbmVyYXRlZEVsZW1zLnB1c2goe2VsOiBlbGVtLCByZWY6IGZpbGVFbGVtLnBhcmVudCgpfSk7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmaWxlRWxlbS5wYXJlbnQoKVswXSk7XG4gICAgICAgICAgZmlsZUVsZW0uYmluZCgnY2hhbmdlJywgY2hhbmdlRm4pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7LyppZ25vcmUqL1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWxheWVkQ2xpY2tTdXBwb3J0ZWQobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZmlsZUVsZW1bMF0uY2xpY2soKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlRWxlbVswXS5jbGljaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICB2YXIgaW5pdGlhbFRvdWNoU3RhcnRZID0gMDtcbiAgICB2YXIgaW5pdGlhbFRvdWNoU3RhcnRYID0gMDtcblxuICAgIGZ1bmN0aW9uIGRldGVjdFN3aXBlKGV2dCkge1xuICAgICAgdmFyIHRvdWNoZXMgPSBldnQuY2hhbmdlZFRvdWNoZXMgfHwgKGV2dC5vcmlnaW5hbEV2ZW50ICYmIGV2dC5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcbiAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgIGlmIChldnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgaW5pdGlhbFRvdWNoU3RhcnRYID0gdG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgIGluaXRpYWxUb3VjaFN0YXJ0WSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZG9uJ3QgYmxvY2sgZXZlbnQgZGVmYXVsdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByZXZlbnQgc2Nyb2xsIGZyb20gdHJpZ2dlcmluZyBldmVudFxuICAgICAgICAgIGlmIChldnQudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRYID0gdG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRZID0gdG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyhjdXJyZW50WCAtIGluaXRpYWxUb3VjaFN0YXJ0WCkgPiAyMCkgfHxcbiAgICAgICAgICAgICAgKE1hdGguYWJzKGN1cnJlbnRZIC0gaW5pdGlhbFRvdWNoU3RhcnRZKSA+IDIwKSkge1xuICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpbGVFbGVtID0gZWxlbTtcblxuICAgIGZ1bmN0aW9uIHJlc2V0TW9kZWwoZXZ0KSB7XG4gICAgICBpZiAodXBsb2FkLnNob3VsZFVwZGF0ZU9uKCdjbGljaycsIGF0dHIsIHNjb3BlKSAmJiBmaWxlRWxlbS52YWwoKSkge1xuICAgICAgICBmaWxlRWxlbS52YWwobnVsbCk7XG4gICAgICAgIHVwbG9hZC51cGRhdGVNb2RlbChuZ01vZGVsLCBhdHRyLCBzY29wZSwgZmlsZUNoYW5nZUF0dHIoKSwgbnVsbCwgZXZ0LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzSW5wdXRUeXBlRmlsZSgpKSB7XG4gICAgICBmaWxlRWxlbSA9IGNyZWF0ZUZpbGVJbnB1dCgpO1xuICAgIH1cbiAgICBmaWxlRWxlbS5iaW5kKCdjaGFuZ2UnLCBjaGFuZ2VGbik7XG5cbiAgICBpZiAoIWlzSW5wdXRUeXBlRmlsZSgpKSB7XG4gICAgICBlbGVtLmJpbmQoJ2NsaWNrIHRvdWNoc3RhcnQgdG91Y2hlbmQnLCBjbGlja0hhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmJpbmQoJ2NsaWNrJywgcmVzZXRNb2RlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWUxMFNhbWVGaWxlU2VsZWN0Rml4KGV2dCkge1xuICAgICAgaWYgKGZpbGVFbGVtICYmICFmaWxlRWxlbS5hdHRyKCdfX25nZl9pZTEwX0ZpeF8nKSkge1xuICAgICAgICBpZiAoIWZpbGVFbGVtWzBdLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBmaWxlRWxlbSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZpbGVFbGVtLnVuYmluZCgnY2xpY2snKTtcbiAgICAgICAgdmFyIGNsb25lID0gZmlsZUVsZW0uY2xvbmUoKTtcbiAgICAgICAgZmlsZUVsZW0ucmVwbGFjZVdpdGgoY2xvbmUpO1xuICAgICAgICBmaWxlRWxlbSA9IGNsb25lO1xuICAgICAgICBmaWxlRWxlbS5hdHRyKCdfX25nZl9pZTEwX0ZpeF8nLCAndHJ1ZScpO1xuICAgICAgICBmaWxlRWxlbS5iaW5kKCdjaGFuZ2UnLCBjaGFuZ2VGbik7XG4gICAgICAgIGZpbGVFbGVtLmJpbmQoJ2NsaWNrJywgaWUxMFNhbWVGaWxlU2VsZWN0Rml4KTtcbiAgICAgICAgZmlsZUVsZW1bMF0uY2xpY2soKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsZUVsZW0ucmVtb3ZlQXR0cignX19uZ2ZfaWUxMF9GaXhfJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoJ01TSUUgMTAnKSAhPT0gLTEpIHtcbiAgICAgIGZpbGVFbGVtLmJpbmQoJ2NsaWNrJywgaWUxMFNhbWVGaWxlU2VsZWN0Rml4KTtcbiAgICB9XG5cbiAgICBpZiAobmdNb2RlbCkgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChmaWxlRWxlbS52YWwoKSkge1xuICAgICAgICAgIGZpbGVFbGVtLnZhbChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9KTtcblxuICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzSW5wdXRUeXBlRmlsZSgpKSBmaWxlRWxlbS5wYXJlbnQoKS5yZW1vdmUoKTtcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1bndhdGNoZXMsIGZ1bmN0aW9uICh1bndhdGNoKSB7XG4gICAgICAgIHVud2F0Y2goKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW5lcmF0ZWRFbGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZyA9IGdlbmVyYXRlZEVsZW1zW2ldO1xuICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZy5lbFswXSkpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRFbGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgZy5yZWYucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh3aW5kb3cuRmlsZUFQSSAmJiB3aW5kb3cuRmlsZUFQSS5uZ2ZGaXhJRSkge1xuICAgICAgd2luZG93LkZpbGVBUEkubmdmRml4SUUoZWxlbSwgZmlsZUVsZW0sIGNoYW5nZUZuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQUVDJyxcbiAgICByZXF1aXJlOiAnP25nTW9kZWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbSwgYXR0ciwgbmdNb2RlbCkge1xuICAgICAgbGlua0ZpbGVTZWxlY3Qoc2NvcGUsIGVsZW0sIGF0dHIsIG5nTW9kZWwsICRwYXJzZSwgJHRpbWVvdXQsICRjb21waWxlLCBVcGxvYWQpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICBuZ0ZpbGVVcGxvYWQuc2VydmljZSgnVXBsb2FkRGF0YVVybCcsIFsnVXBsb2FkQmFzZScsICckdGltZW91dCcsICckcScsIGZ1bmN0aW9uIChVcGxvYWRCYXNlLCAkdGltZW91dCwgJHEpIHtcbiAgICB2YXIgdXBsb2FkID0gVXBsb2FkQmFzZTtcbiAgICB1cGxvYWQuYmFzZTY0RGF0YVVybCA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICBpZiAoYW5ndWxhci5pc0FycmF5KGZpbGUpKSB7XG4gICAgICAgIHZhciBkID0gJHEuZGVmZXIoKSwgY291bnQgPSAwO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goZmlsZSwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICB1cGxvYWQuZGF0YVVybChmLCB0cnVlKVsnZmluYWxseSddKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IGZpbGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciB1cmxzID0gW107XG4gICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmaWxlLCBmdW5jdGlvbiAoZmYpIHtcbiAgICAgICAgICAgICAgICB1cmxzLnB1c2goZmYuJG5nZkRhdGFVcmwpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZC5yZXNvbHZlKHVybHMsIGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1cGxvYWQuZGF0YVVybChmaWxlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHVwbG9hZC5kYXRhVXJsID0gZnVuY3Rpb24gKGZpbGUsIGRpc2FsbG93T2JqZWN0VXJsKSB7XG4gICAgICBpZiAoIWZpbGUpIHJldHVybiB1cGxvYWQuZW1wdHlQcm9taXNlKGZpbGUsIGZpbGUpO1xuICAgICAgaWYgKChkaXNhbGxvd09iamVjdFVybCAmJiBmaWxlLiRuZ2ZEYXRhVXJsICE9IG51bGwpIHx8ICghZGlzYWxsb3dPYmplY3RVcmwgJiYgZmlsZS4kbmdmQmxvYlVybCAhPSBudWxsKSkge1xuICAgICAgICByZXR1cm4gdXBsb2FkLmVtcHR5UHJvbWlzZShkaXNhbGxvd09iamVjdFVybCA/IGZpbGUuJG5nZkRhdGFVcmwgOiBmaWxlLiRuZ2ZCbG9iVXJsLCBmaWxlKTtcbiAgICAgIH1cbiAgICAgIHZhciBwID0gZGlzYWxsb3dPYmplY3RVcmwgPyBmaWxlLiQkbmdmRGF0YVVybFByb21pc2UgOiBmaWxlLiQkbmdmQmxvYlVybFByb21pc2U7XG4gICAgICBpZiAocCkgcmV0dXJuIHA7XG5cbiAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh3aW5kb3cuRmlsZVJlYWRlciAmJiBmaWxlICYmXG4gICAgICAgICAgKCF3aW5kb3cuRmlsZUFQSSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgOCcpID09PSAtMSB8fCBmaWxlLnNpemUgPCAyMDAwMCkgJiZcbiAgICAgICAgICAoIXdpbmRvdy5GaWxlQVBJIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRSA5JykgPT09IC0xIHx8IGZpbGUuc2l6ZSA8IDQwMDAwMDApKSB7XG4gICAgICAgICAgLy9wcmVmZXIgVVJMLmNyZWF0ZU9iamVjdFVSTCBmb3IgaGFuZGxpbmcgcmVmcmVuY2VzIHRvIGZpbGVzIG9mIGFsbCBzaXplc1xuICAgICAgICAgIC8vc2luY2UgaXQgZG9lc27CtHQgYnVpbGQgYSBsYXJnZSBzdHJpbmcgaW4gbWVtb3J5XG4gICAgICAgICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcbiAgICAgICAgICBpZiAoVVJMICYmIFVSTC5jcmVhdGVPYmplY3RVUkwgJiYgIWRpc2FsbG93T2JqZWN0VXJsKSB7XG4gICAgICAgICAgICB2YXIgdXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZpbGUuJG5nZkJsb2JVcmwgPSAnJztcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZmlsZS4kbmdmQmxvYlVybCA9IHVybDtcbiAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodXJsLCBmaWxlKTtcbiAgICAgICAgICAgICAgICB1cGxvYWQuYmxvYlVybHMgPSB1cGxvYWQuYmxvYlVybHMgfHwgW107XG4gICAgICAgICAgICAgICAgdXBsb2FkLmJsb2JVcmxzVG90YWxTaXplID0gdXBsb2FkLmJsb2JVcmxzVG90YWxTaXplIHx8IDA7XG4gICAgICAgICAgICAgICAgdXBsb2FkLmJsb2JVcmxzLnB1c2goe3VybDogdXJsLCBzaXplOiBmaWxlLnNpemV9KTtcbiAgICAgICAgICAgICAgICB1cGxvYWQuYmxvYlVybHNUb3RhbFNpemUgKz0gZmlsZS5zaXplIHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIG1heE1lbW9yeSA9IHVwbG9hZC5kZWZhdWx0cy5ibG9iVXJsc01heE1lbW9yeSB8fCAyNjg0MzU0NTY7XG4gICAgICAgICAgICAgICAgdmFyIG1heExlbmd0aCA9IHVwbG9hZC5kZWZhdWx0cy5ibG9iVXJsc01heFF1ZXVlU2l6ZSB8fCAyMDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCh1cGxvYWQuYmxvYlVybHNUb3RhbFNpemUgPiBtYXhNZW1vcnkgfHwgdXBsb2FkLmJsb2JVcmxzLmxlbmd0aCA+IG1heExlbmd0aCkgJiYgdXBsb2FkLmJsb2JVcmxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB1cGxvYWQuYmxvYlVybHMuc3BsaWNlKDAsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmoudXJsKTtcbiAgICAgICAgICAgICAgICAgIHVwbG9hZC5ibG9iVXJsc1RvdGFsU2l6ZSAtPSBvYmouc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmaWxlLiRuZ2ZEYXRhVXJsID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZS50YXJnZXQucmVzdWx0LCBmaWxlKTtcbiAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgZmlsZS4kbmdmRGF0YVVybDtcbiAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZmlsZS4kbmdmRGF0YVVybCA9ICcnO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZpbGVbZGlzYWxsb3dPYmplY3RVcmwgPyAnJG5nZkRhdGFVcmwnIDogJyRuZ2ZCbG9iVXJsJ10gPSAnJztcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGRpc2FsbG93T2JqZWN0VXJsKSB7XG4gICAgICAgIHAgPSBmaWxlLiQkbmdmRGF0YVVybFByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcCA9IGZpbGUuJCRuZ2ZCbG9iVXJsUHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9XG4gICAgICBwWydmaW5hbGx5J10oZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgZmlsZVtkaXNhbGxvd09iamVjdFVybCA/ICckJG5nZkRhdGFVcmxQcm9taXNlJyA6ICckJG5nZkJsb2JVcmxQcm9taXNlJ107XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH07XG4gICAgcmV0dXJuIHVwbG9hZDtcbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIGdldFRhZ1R5cGUoZWwpIHtcbiAgICBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykgcmV0dXJuICdpbWFnZSc7XG4gICAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2F1ZGlvJykgcmV0dXJuICdhdWRpbyc7XG4gICAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvJykgcmV0dXJuICd2aWRlbyc7XG4gICAgcmV0dXJuIC8uLztcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmtGaWxlRGlyZWN0aXZlKFVwbG9hZCwgJHRpbWVvdXQsIHNjb3BlLCBlbGVtLCBhdHRyLCBkaXJlY3RpdmVOYW1lLCByZXNpemVQYXJhbXMsIGlzQmFja2dyb3VuZCkge1xuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdERhdGFVcmwoZmlsZSkge1xuICAgICAgdmFyIGRpc2FsbG93T2JqZWN0VXJsID0gVXBsb2FkLmF0dHJHZXR0ZXIoJ25nZk5vT2JqZWN0VXJsJywgYXR0ciwgc2NvcGUpO1xuICAgICAgVXBsb2FkLmRhdGFVcmwoZmlsZSwgZGlzYWxsb3dPYmplY3RVcmwpWydmaW5hbGx5J10oZnVuY3Rpb24gKCkge1xuICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNyYyA9IChkaXNhbGxvd09iamVjdFVybCA/IGZpbGUuJG5nZkRhdGFVcmwgOiBmaWxlLiRuZ2ZCbG9iVXJsKSB8fCBmaWxlLiRuZ2ZEYXRhVXJsO1xuICAgICAgICAgIGlmIChpc0JhY2tncm91bmQpIHtcbiAgICAgICAgICAgIGVsZW0uY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgJ3VybChcXCcnICsgKHNyYyB8fCAnJykgKyAnXFwnKScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtLmF0dHIoJ3NyYycsIHNyYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoJ25nLWhpZGUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5hZGRDbGFzcygnbmctaGlkZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdW53YXRjaCA9IHNjb3BlLiR3YXRjaChhdHRyW2RpcmVjdGl2ZU5hbWVdLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IHJlc2l6ZVBhcmFtcztcbiAgICAgICAgaWYgKGRpcmVjdGl2ZU5hbWUgPT09ICduZ2ZUaHVtYm5haWwnKSB7XG4gICAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgICBzaXplID0ge1xuICAgICAgICAgICAgICB3aWR0aDogZWxlbVswXS5uYXR1cmFsV2lkdGggfHwgZWxlbVswXS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtWzBdLm5hdHVyYWxIZWlnaHQgfHwgZWxlbVswXS5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaXplLndpZHRoID09PSAwICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1bMF0pO1xuICAgICAgICAgICAgaWYgKHN0eWxlLndpZHRoICYmIHN0eWxlLndpZHRoLmluZGV4T2YoJ3B4JykgPiAtMSAmJiBzdHlsZS5oZWlnaHQgJiYgc3R5bGUuaGVpZ2h0LmluZGV4T2YoJ3B4JykgPiAtMSkge1xuICAgICAgICAgICAgICBzaXplID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJzZUludChzdHlsZS53aWR0aC5zbGljZSgwLCAtMikpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQoc3R5bGUuaGVpZ2h0LnNsaWNlKDAsIC0yKSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ndWxhci5pc1N0cmluZyhmaWxlKSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQ2xhc3MoJ25nLWhpZGUnKTtcbiAgICAgICAgICBpZiAoaXNCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnLCAndXJsKFxcJycgKyBmaWxlICsgJ1xcJyknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uYXR0cignc3JjJywgZmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlICYmIGZpbGUudHlwZSAmJiBmaWxlLnR5cGUuc2VhcmNoKGdldFRhZ1R5cGUoZWxlbVswXSkpID09PSAwICYmXG4gICAgICAgICAgKCFpc0JhY2tncm91bmQgfHwgZmlsZS50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApKSB7XG4gICAgICAgICAgaWYgKHNpemUgJiYgVXBsb2FkLmlzUmVzaXplU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHNpemUucmVzaXplSWYgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICByZXR1cm4gVXBsb2FkLmF0dHJHZXR0ZXIoJ25nZlJlc2l6ZUlmJywgYXR0ciwgc2NvcGUsXG4gICAgICAgICAgICAgICAgeyR3aWR0aDogd2lkdGgsICRoZWlnaHQ6IGhlaWdodCwgJGZpbGU6IGZpbGV9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBVcGxvYWQucmVzaXplKGZpbGUsIHNpemUpLnRoZW4oXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0RGF0YVVybChmKTtcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3REYXRhVXJsKGZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLmFkZENsYXNzKCduZy1oaWRlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB1bndhdGNoKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ2ZTcmMgKi9cbiAgLyoqIEBuYW1lc3BhY2UgYXR0ci5uZ2ZOb09iamVjdFVybCAqL1xuICBuZ0ZpbGVVcGxvYWQuZGlyZWN0aXZlKCduZ2ZTcmMnLCBbJ1VwbG9hZCcsICckdGltZW91dCcsIGZ1bmN0aW9uIChVcGxvYWQsICR0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQUUnLFxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtLCBhdHRyKSB7XG4gICAgICAgIGxpbmtGaWxlRGlyZWN0aXZlKFVwbG9hZCwgJHRpbWVvdXQsIHNjb3BlLCBlbGVtLCBhdHRyLCAnbmdmU3JjJyxcbiAgICAgICAgICBVcGxvYWQuYXR0ckdldHRlcignbmdmUmVzaXplJywgYXR0ciwgc2NvcGUpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xuXG4gIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmQmFja2dyb3VuZCAqL1xuICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZk5vT2JqZWN0VXJsICovXG4gIG5nRmlsZVVwbG9hZC5kaXJlY3RpdmUoJ25nZkJhY2tncm91bmQnLCBbJ1VwbG9hZCcsICckdGltZW91dCcsIGZ1bmN0aW9uIChVcGxvYWQsICR0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQUUnLFxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtLCBhdHRyKSB7XG4gICAgICAgIGxpbmtGaWxlRGlyZWN0aXZlKFVwbG9hZCwgJHRpbWVvdXQsIHNjb3BlLCBlbGVtLCBhdHRyLCAnbmdmQmFja2dyb3VuZCcsXG4gICAgICAgICAgVXBsb2FkLmF0dHJHZXR0ZXIoJ25nZlJlc2l6ZScsIGF0dHIsIHNjb3BlKSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xuXG4gIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmVGh1bWJuYWlsICovXG4gIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmQXNCYWNrZ3JvdW5kICovXG4gIC8qKiBAbmFtZXNwYWNlIGF0dHIubmdmU2l6ZSAqL1xuICAvKiogQG5hbWVzcGFjZSBhdHRyLm5nZk5vT2JqZWN0VXJsICovXG4gIG5nRmlsZVVwbG9hZC5kaXJlY3RpdmUoJ25nZlRodW1ibmFpbCcsIFsnVXBsb2FkJywgJyR0aW1lb3V0JywgZnVuY3Rpb24gKFVwbG9hZCwgJHRpbWVvdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBRScsXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW0sIGF0dHIpIHtcbiAgICAgICAgdmFyIHNpemUgPSBVcGxvYWQuYXR0ckdldHRlcignbmdmU2l6ZScsIGF0dHIsIHNjb3BlKTtcbiAgICAgICAgbGlua0ZpbGVEaXJlY3RpdmUoVXBsb2FkLCAkdGltZW91dCwgc2NvcGUsIGVsZW0sIGF0dHIsICduZ2ZUaHVtYm5haWwnLCBzaXplLFxuICAgICAgICAgIFVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZBc0JhY2tncm91bmQnLCBhdHRyLCBzY29wZSkpO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuICBuZ0ZpbGVVcGxvYWQuY29uZmlnKFsnJGNvbXBpbGVQcm92aWRlcicsIGZ1bmN0aW9uICgkY29tcGlsZVByb3ZpZGVyKSB7XG4gICAgaWYgKCRjb21waWxlUHJvdmlkZXIuaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0KSAkY29tcGlsZVByb3ZpZGVyLmltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdCgvXlxccyooaHR0cHM/fGZ0cHxtYWlsdG98dGVsfHdlYmNhbHxsb2NhbHxmaWxlfGRhdGF8YmxvYik6Lyk7XG4gICAgaWYgKCRjb21waWxlUHJvdmlkZXIuYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3QpICRjb21waWxlUHJvdmlkZXIuYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3QoL15cXHMqKGh0dHBzP3xmdHB8bWFpbHRvfHRlbHx3ZWJjYWx8bG9jYWx8ZmlsZXxkYXRhfGJsb2IpOi8pO1xuICB9XSk7XG5cbiAgbmdGaWxlVXBsb2FkLmZpbHRlcignbmdmRGF0YVVybCcsIFsnVXBsb2FkRGF0YVVybCcsICckc2NlJywgZnVuY3Rpb24gKFVwbG9hZERhdGFVcmwsICRzY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZpbGUsIGRpc2FsbG93T2JqZWN0VXJsLCB0cnVzdGVkVXJsKSB7XG4gICAgICBpZiAoYW5ndWxhci5pc1N0cmluZyhmaWxlKSkge1xuICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzUmVzb3VyY2VVcmwoZmlsZSk7XG4gICAgICB9XG4gICAgICB2YXIgc3JjID0gZmlsZSAmJiAoKGRpc2FsbG93T2JqZWN0VXJsID8gZmlsZS4kbmdmRGF0YVVybCA6IGZpbGUuJG5nZkJsb2JVcmwpIHx8IGZpbGUuJG5nZkRhdGFVcmwpO1xuICAgICAgaWYgKGZpbGUgJiYgIXNyYykge1xuICAgICAgICBpZiAoIWZpbGUuJG5nZkRhdGFVcmxGaWx0ZXJJblByb2dyZXNzICYmIGFuZ3VsYXIuaXNPYmplY3QoZmlsZSkpIHtcbiAgICAgICAgICBmaWxlLiRuZ2ZEYXRhVXJsRmlsdGVySW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgVXBsb2FkRGF0YVVybC5kYXRhVXJsKGZpbGUsIGRpc2FsbG93T2JqZWN0VXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAoZmlsZSkgZGVsZXRlIGZpbGUuJG5nZkRhdGFVcmxGaWx0ZXJJblByb2dyZXNzO1xuICAgICAgcmV0dXJuIChmaWxlICYmIHNyYyA/ICh0cnVzdGVkVXJsID8gJHNjZS50cnVzdEFzUmVzb3VyY2VVcmwoc3JjKSA6IHNyYykgOiBmaWxlKSB8fCAnJztcbiAgICB9O1xuICB9XSk7XG5cbn0pKCk7XG5cbm5nRmlsZVVwbG9hZC5zZXJ2aWNlKCdVcGxvYWRWYWxpZGF0ZScsIFsnVXBsb2FkRGF0YVVybCcsICckcScsICckdGltZW91dCcsIGZ1bmN0aW9uIChVcGxvYWREYXRhVXJsLCAkcSwgJHRpbWVvdXQpIHtcbiAgdmFyIHVwbG9hZCA9IFVwbG9hZERhdGFVcmw7XG5cbiAgZnVuY3Rpb24gZ2xvYlN0cmluZ1RvUmVnZXgoc3RyKSB7XG4gICAgdmFyIHJlZ2V4cCA9ICcnLCBleGNsdWRlcyA9IFtdO1xuICAgIGlmIChzdHIubGVuZ3RoID4gMiAmJiBzdHJbMF0gPT09ICcvJyAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICAgIHJlZ2V4cCA9IHN0ci5zdWJzdHJpbmcoMSwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3BsaXQgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgciA9IGdsb2JTdHJpbmdUb1JlZ2V4KHNwbGl0W2ldKTtcbiAgICAgICAgICBpZiAoci5yZWdleHApIHtcbiAgICAgICAgICAgIHJlZ2V4cCArPSAnKCcgKyByLnJlZ2V4cCArICcpJztcbiAgICAgICAgICAgIGlmIChpIDwgc3BsaXQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICByZWdleHAgKz0gJ3wnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGNsdWRlcyA9IGV4Y2x1ZGVzLmNvbmNhdChyLmV4Y2x1ZGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdHIuaW5kZXhPZignIScpID09PSAwKSB7XG4gICAgICAgICAgZXhjbHVkZXMucHVzaCgnXigoPyEnICsgZ2xvYlN0cmluZ1RvUmVnZXgoc3RyLnN1YnN0cmluZygxKSkucmVnZXhwICsgJykuKSokJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgIHN0ciA9ICcqJyArIHN0cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnZXhwID0gJ14nICsgc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnWy5cXFxcXFxcXCsqP1xcXFxbXFxcXF5cXFxcXSQoKXt9PSE8Pnw6XFxcXC1dJywgJ2cnKSwgJ1xcXFwkJicpICsgJyQnO1xuICAgICAgICAgIHJlZ2V4cCA9IHJlZ2V4cC5yZXBsYWNlKC9cXFxcXFwqL2csICcuKicpLnJlcGxhY2UoL1xcXFxcXD8vZywgJy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge3JlZ2V4cDogcmVnZXhwLCBleGNsdWRlczogZXhjbHVkZXN9O1xuICB9XG5cbiAgdXBsb2FkLnZhbGlkYXRlUGF0dGVybiA9IGZ1bmN0aW9uIChmaWxlLCB2YWwpIHtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gZ2xvYlN0cmluZ1RvUmVnZXgodmFsKSwgdmFsaWQgPSB0cnVlO1xuICAgIGlmIChwYXR0ZXJuLnJlZ2V4cCAmJiBwYXR0ZXJuLnJlZ2V4cC5sZW5ndGgpIHtcbiAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVnZXhwLCAnaScpO1xuICAgICAgdmFsaWQgPSAoZmlsZS50eXBlICE9IG51bGwgJiYgcmVnZXhwLnRlc3QoZmlsZS50eXBlKSkgfHxcbiAgICAgICAgKGZpbGUubmFtZSAhPSBudWxsICYmIHJlZ2V4cC50ZXN0KGZpbGUubmFtZSkpO1xuICAgIH1cbiAgICB2YXIgbGVuID0gcGF0dGVybi5leGNsdWRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICB2YXIgZXhjbHVkZSA9IG5ldyBSZWdFeHAocGF0dGVybi5leGNsdWRlc1tsZW5dLCAnaScpO1xuICAgICAgdmFsaWQgPSB2YWxpZCAmJiAoZmlsZS50eXBlID09IG51bGwgfHwgZXhjbHVkZS50ZXN0KGZpbGUudHlwZSkpICYmXG4gICAgICAgIChmaWxlLm5hbWUgPT0gbnVsbCB8fCBleGNsdWRlLnRlc3QoZmlsZS5uYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfTtcblxuICB1cGxvYWQucmF0aW9Ub0Zsb2F0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhciByID0gdmFsLnRvU3RyaW5nKCksIHhJbmRleCA9IHIuc2VhcmNoKC9beDpdL2kpO1xuICAgIGlmICh4SW5kZXggPiAtMSkge1xuICAgICAgciA9IHBhcnNlRmxvYXQoci5zdWJzdHJpbmcoMCwgeEluZGV4KSkgLyBwYXJzZUZsb2F0KHIuc3Vic3RyaW5nKHhJbmRleCArIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IHBhcnNlRmxvYXQocik7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIHVwbG9hZC5yZWdpc3Rlck1vZGVsQ2hhbmdlVmFsaWRhdG9yID0gZnVuY3Rpb24gKG5nTW9kZWwsIGF0dHIsIHNjb3BlKSB7XG4gICAgaWYgKG5nTW9kZWwpIHtcbiAgICAgIG5nTW9kZWwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgaWYgKG5nTW9kZWwuJGRpcnR5KSB7XG4gICAgICAgICAgdmFyIGZpbGVzQXJyYXkgPSBmaWxlcztcbiAgICAgICAgICBpZiAoZmlsZXMgJiYgIWFuZ3VsYXIuaXNBcnJheShmaWxlcykpIHtcbiAgICAgICAgICAgIGZpbGVzQXJyYXkgPSBbZmlsZXNdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGxvYWQudmFsaWRhdGUoZmlsZXNBcnJheSwgMCwgbmdNb2RlbCwgYXR0ciwgc2NvcGUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXBsb2FkLmFwcGx5TW9kZWxWYWxpZGF0aW9uKG5nTW9kZWwsIGZpbGVzQXJyYXkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYXJrTW9kZWxBc0RpcnR5KG5nTW9kZWwsIGZpbGVzKSB7XG4gICAgaWYgKGZpbGVzICE9IG51bGwgJiYgIW5nTW9kZWwuJGRpcnR5KSB7XG4gICAgICBpZiAobmdNb2RlbC4kc2V0RGlydHkpIHtcbiAgICAgICAgbmdNb2RlbC4kc2V0RGlydHkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5nTW9kZWwuJGRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGxvYWQuYXBwbHlNb2RlbFZhbGlkYXRpb24gPSBmdW5jdGlvbiAobmdNb2RlbCwgZmlsZXMpIHtcbiAgICBtYXJrTW9kZWxBc0RpcnR5KG5nTW9kZWwsIGZpbGVzKTtcbiAgICBhbmd1bGFyLmZvckVhY2gobmdNb2RlbC4kbmdmVmFsaWRhdGlvbnMsIGZ1bmN0aW9uICh2YWxpZGF0aW9uKSB7XG4gICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSh2YWxpZGF0aW9uLm5hbWUsIHZhbGlkYXRpb24udmFsaWQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHVwbG9hZC5nZXRWYWxpZGF0aW9uQXR0ciA9IGZ1bmN0aW9uIChhdHRyLCBzY29wZSwgbmFtZSwgdmFsaWRhdGlvbk5hbWUsIGZpbGUpIHtcbiAgICB2YXIgZE5hbWUgPSAnbmdmJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpO1xuICAgIHZhciB2YWwgPSB1cGxvYWQuYXR0ckdldHRlcihkTmFtZSwgYXR0ciwgc2NvcGUsIHskZmlsZTogZmlsZX0pO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdmFsID0gdXBsb2FkLmF0dHJHZXR0ZXIoJ25nZlZhbGlkYXRlJywgYXR0ciwgc2NvcGUsIHskZmlsZTogZmlsZX0pO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICB2YXIgc3BsaXQgPSAodmFsaWRhdGlvbk5hbWUgfHwgbmFtZSkuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFsID0gdmFsW3NwbGl0WzBdXTtcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YWwgPSB2YWwgJiYgdmFsW3NwbGl0WzFdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9O1xuXG4gIHVwbG9hZC52YWxpZGF0ZSA9IGZ1bmN0aW9uIChmaWxlcywgcHJldkxlbmd0aCwgbmdNb2RlbCwgYXR0ciwgc2NvcGUpIHtcbiAgICBuZ01vZGVsID0gbmdNb2RlbCB8fCB7fTtcbiAgICBuZ01vZGVsLiRuZ2ZWYWxpZGF0aW9ucyA9IG5nTW9kZWwuJG5nZlZhbGlkYXRpb25zIHx8IFtdO1xuXG4gICAgYW5ndWxhci5mb3JFYWNoKG5nTW9kZWwuJG5nZlZhbGlkYXRpb25zLCBmdW5jdGlvbiAodikge1xuICAgICAgdi52YWxpZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICB2YXIgYXR0ckdldHRlciA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgIHJldHVybiB1cGxvYWQuYXR0ckdldHRlcihuYW1lLCBhdHRyLCBzY29wZSwgcGFyYW1zKTtcbiAgICB9O1xuXG4gICAgdmFyIGlnbm9yZWRFcnJvcnMgPSAodXBsb2FkLmF0dHJHZXR0ZXIoJ25nZklnbm9yZUludmFsaWQnLCBhdHRyLCBzY29wZSkgfHwgJycpLnNwbGl0KCcgJyk7XG4gICAgdmFyIHJ1bkFsbFZhbGlkYXRpb24gPSB1cGxvYWQuYXR0ckdldHRlcignbmdmUnVuQWxsVmFsaWRhdGlvbnMnLCBhdHRyLCBzY29wZSk7XG5cbiAgICBpZiAoZmlsZXMgPT0gbnVsbCB8fCBmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1cGxvYWQuZW1wdHlQcm9taXNlKHsndmFsaWRGaWxlcyc6IGZpbGVzLCAnaW52YWxpZEZpbGVzJzogW119KTtcbiAgICB9XG5cbiAgICBmaWxlcyA9IGZpbGVzLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gW2ZpbGVzXSA6IGZpbGVzLnNsaWNlKDApO1xuICAgIHZhciBpbnZhbGlkRmlsZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYyhuYW1lLCB2YWxpZGF0aW9uTmFtZSwgZm4pIHtcbiAgICAgIGlmIChmaWxlcykge1xuICAgICAgICB2YXIgaSA9IGZpbGVzLmxlbmd0aCwgdmFsaWQgPSBudWxsO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdmFyIGZpbGUgPSBmaWxlc1tpXTtcbiAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHVwbG9hZC5nZXRWYWxpZGF0aW9uQXR0cihhdHRyLCBzY29wZSwgbmFtZSwgdmFsaWRhdGlvbk5hbWUsIGZpbGUpO1xuICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICghZm4oZmlsZSwgdmFsLCBpKSkge1xuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkRXJyb3JzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBmaWxlLiRlcnJvciA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAoZmlsZS4kZXJyb3JNZXNzYWdlcyA9IChmaWxlLiRlcnJvck1lc3NhZ2VzIHx8IHt9KSlbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgZmlsZS4kZXJyb3JQYXJhbSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkRmlsZXMuaW5kZXhPZihmaWxlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXJ1bkFsbFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZmlsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWQgIT09IG51bGwpIHtcbiAgICAgICAgICBuZ01vZGVsLiRuZ2ZWYWxpZGF0aW9ucy5wdXNoKHtuYW1lOiBuYW1lLCB2YWxpZDogdmFsaWR9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlU3luYygncGF0dGVybicsIG51bGwsIHVwbG9hZC52YWxpZGF0ZVBhdHRlcm4pO1xuICAgIHZhbGlkYXRlU3luYygnbWluU2l6ZScsICdzaXplLm1pbicsIGZ1bmN0aW9uIChmaWxlLCB2YWwpIHtcbiAgICAgIHJldHVybiBmaWxlLnNpemUgKyAwLjEgPj0gdXBsb2FkLnRyYW5zbGF0ZVNjYWxhcnModmFsKTtcbiAgICB9KTtcbiAgICB2YWxpZGF0ZVN5bmMoJ21heFNpemUnLCAnc2l6ZS5tYXgnLCBmdW5jdGlvbiAoZmlsZSwgdmFsKSB7XG4gICAgICByZXR1cm4gZmlsZS5zaXplIC0gMC4xIDw9IHVwbG9hZC50cmFuc2xhdGVTY2FsYXJzKHZhbCk7XG4gICAgfSk7XG4gICAgdmFyIHRvdGFsU2l6ZSA9IDA7XG4gICAgdmFsaWRhdGVTeW5jKCdtYXhUb3RhbFNpemUnLCBudWxsLCBmdW5jdGlvbiAoZmlsZSwgdmFsKSB7XG4gICAgICB0b3RhbFNpemUgKz0gZmlsZS5zaXplO1xuICAgICAgaWYgKHRvdGFsU2l6ZSA+IHVwbG9hZC50cmFuc2xhdGVTY2FsYXJzKHZhbCkpIHtcbiAgICAgICAgZmlsZXMuc3BsaWNlKDAsIGZpbGVzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgdmFsaWRhdGVTeW5jKCd2YWxpZGF0ZUZuJywgbnVsbCwgZnVuY3Rpb24gKGZpbGUsIHIpIHtcbiAgICAgIHJldHVybiByID09PSB0cnVlIHx8IHIgPT09IG51bGwgfHwgciA9PT0gJyc7XG4gICAgfSk7XG5cbiAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVwbG9hZC5lbXB0eVByb21pc2Uoeyd2YWxpZEZpbGVzJzogW10sICdpbnZhbGlkRmlsZXMnOiBpbnZhbGlkRmlsZXN9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKG5hbWUsIHZhbGlkYXRpb25OYW1lLCB0eXBlLCBhc3luY0ZuLCBmbikge1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVJlc3VsdChkZWZlciwgZmlsZSwgdmFsKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVJbnRlcm5hbChmbikge1xuICAgICAgICAgIGlmIChmbigpKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlZEVycm9ycy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICBmaWxlLiRlcnJvciA9IG5hbWU7XG4gICAgICAgICAgICAgIChmaWxlLiRlcnJvck1lc3NhZ2VzID0gKGZpbGUuJGVycm9yTWVzc2FnZXMgfHwge30pKVtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgIGZpbGUuJGVycm9yUGFyYW0gPSB2YWw7XG4gICAgICAgICAgICAgIGlmIChpbnZhbGlkRmlsZXMuaW5kZXhPZihmaWxlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkRmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXJ1bkFsbFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGZpbGVzLmluZGV4T2YoZmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAtMSkgZmlsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGogPSBmaWxlcy5pbmRleE9mKGZpbGUpO1xuICAgICAgICAgICAgICBpZiAoaiA+IC0xKSBmaWxlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgYXN5bmNGbihmaWxlLCB2YWwpLnRoZW4oZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJlc29sdmVJbnRlcm5hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhZm4oZCwgdmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmVJbnRlcm5hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhdHRyR2V0dGVyKCduZ2ZWYWxpZGF0ZUZvcmNlJywgeyRmaWxlOiBmaWxlfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZlci5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlcyA9IFt1cGxvYWQuZW1wdHlQcm9taXNlKHRydWUpXTtcbiAgICAgIGlmIChmaWxlcykge1xuICAgICAgICBmaWxlcyA9IGZpbGVzLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gW2ZpbGVzXSA6IGZpbGVzO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goZmlsZXMsIGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgdmFyIGRlZmVyID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGRlZmVyLnByb21pc2UpO1xuICAgICAgICAgIGlmICh0eXBlICYmIChmaWxlLnR5cGUgPT0gbnVsbCB8fCBmaWxlLnR5cGUuc2VhcmNoKHR5cGUpICE9PSAwKSkge1xuICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdkaW1lbnNpb25zJyAmJiB1cGxvYWQuYXR0ckdldHRlcignbmdmRGltZW5zaW9ucycsIGF0dHIpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHVwbG9hZC5pbWFnZURpbWVuc2lvbnMoZmlsZSkudGhlbihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICByZXNvbHZlUmVzdWx0KGRlZmVyLCBmaWxlLFxuICAgICAgICAgICAgICAgIGF0dHJHZXR0ZXIoJ25nZkRpbWVuc2lvbnMnLCB7JGZpbGU6IGZpbGUsICR3aWR0aDogZC53aWR0aCwgJGhlaWdodDogZC5oZWlnaHR9KSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnZHVyYXRpb24nICYmIHVwbG9hZC5hdHRyR2V0dGVyKCduZ2ZEdXJhdGlvbicsIGF0dHIpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHVwbG9hZC5tZWRpYUR1cmF0aW9uKGZpbGUpLnRoZW4oZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZVJlc3VsdChkZWZlciwgZmlsZSxcbiAgICAgICAgICAgICAgICBhdHRyR2V0dGVyKCduZ2ZEdXJhdGlvbicsIHskZmlsZTogZmlsZSwgJGR1cmF0aW9uOiBkfSkpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlUmVzdWx0KGRlZmVyLCBmaWxlLFxuICAgICAgICAgICAgICB1cGxvYWQuZ2V0VmFsaWRhdGlvbkF0dHIoYXR0ciwgc2NvcGUsIG5hbWUsIHZhbGlkYXRpb25OYW1lLCBmaWxlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBkZWZmZXIgPSAkcS5kZWZlcigpO1xuICAgICAgJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghdmFsdWVzW2ldKSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmdNb2RlbC4kbmdmVmFsaWRhdGlvbnMucHVzaCh7bmFtZTogbmFtZSwgdmFsaWQ6IGlzVmFsaWR9KTtcbiAgICAgICAgZGVmZmVyLnJlc29sdmUoaXNWYWxpZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZWZmZXIucHJvbWlzZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmZmVyID0gJHEuZGVmZXIoKTtcbiAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygnbWF4SGVpZ2h0JywgJ2hlaWdodC5tYXgnLCAvaW1hZ2UvLFxuICAgICAgdGhpcy5pbWFnZURpbWVuc2lvbnMsIGZ1bmN0aW9uIChkLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGQuaGVpZ2h0IDw9IHZhbDtcbiAgICAgIH0pKTtcbiAgICBwcm9taXNlcy5wdXNoKHZhbGlkYXRlQXN5bmMoJ21pbkhlaWdodCcsICdoZWlnaHQubWluJywgL2ltYWdlLyxcbiAgICAgIHRoaXMuaW1hZ2VEaW1lbnNpb25zLCBmdW5jdGlvbiAoZCwgdmFsKSB7XG4gICAgICAgIHJldHVybiBkLmhlaWdodCA+PSB2YWw7XG4gICAgICB9KSk7XG4gICAgcHJvbWlzZXMucHVzaCh2YWxpZGF0ZUFzeW5jKCdtYXhXaWR0aCcsICd3aWR0aC5tYXgnLCAvaW1hZ2UvLFxuICAgICAgdGhpcy5pbWFnZURpbWVuc2lvbnMsIGZ1bmN0aW9uIChkLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGQud2lkdGggPD0gdmFsO1xuICAgICAgfSkpO1xuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygnbWluV2lkdGgnLCAnd2lkdGgubWluJywgL2ltYWdlLyxcbiAgICAgIHRoaXMuaW1hZ2VEaW1lbnNpb25zLCBmdW5jdGlvbiAoZCwgdmFsKSB7XG4gICAgICAgIHJldHVybiBkLndpZHRoID49IHZhbDtcbiAgICAgIH0pKTtcbiAgICBwcm9taXNlcy5wdXNoKHZhbGlkYXRlQXN5bmMoJ2RpbWVuc2lvbnMnLCBudWxsLCAvaW1hZ2UvLFxuICAgICAgZnVuY3Rpb24gKGZpbGUsIHZhbCkge1xuICAgICAgICByZXR1cm4gdXBsb2FkLmVtcHR5UHJvbWlzZSh2YWwpO1xuICAgICAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9KSk7XG4gICAgcHJvbWlzZXMucHVzaCh2YWxpZGF0ZUFzeW5jKCdyYXRpbycsIG51bGwsIC9pbWFnZS8sXG4gICAgICB0aGlzLmltYWdlRGltZW5zaW9ucywgZnVuY3Rpb24gKGQsIHZhbCkge1xuICAgICAgICB2YXIgc3BsaXQgPSB2YWwudG9TdHJpbmcoKS5zcGxpdCgnLCcpLCB2YWxpZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKChkLndpZHRoIC8gZC5oZWlnaHQpIC0gdXBsb2FkLnJhdGlvVG9GbG9hdChzcGxpdFtpXSkpIDwgMC4wMSkge1xuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICB9KSk7XG4gICAgcHJvbWlzZXMucHVzaCh2YWxpZGF0ZUFzeW5jKCdtYXhSYXRpbycsICdyYXRpby5tYXgnLCAvaW1hZ2UvLFxuICAgICAgdGhpcy5pbWFnZURpbWVuc2lvbnMsIGZ1bmN0aW9uIChkLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIChkLndpZHRoIC8gZC5oZWlnaHQpIC0gdXBsb2FkLnJhdGlvVG9GbG9hdCh2YWwpIDwgMC4wMDAxO1xuICAgICAgfSkpO1xuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygnbWluUmF0aW8nLCAncmF0aW8ubWluJywgL2ltYWdlLyxcbiAgICAgIHRoaXMuaW1hZ2VEaW1lbnNpb25zLCBmdW5jdGlvbiAoZCwgdmFsKSB7XG4gICAgICAgIHJldHVybiAoZC53aWR0aCAvIGQuaGVpZ2h0KSAtIHVwbG9hZC5yYXRpb1RvRmxvYXQodmFsKSA+IC0wLjAwMDE7XG4gICAgICB9KSk7XG4gICAgcHJvbWlzZXMucHVzaCh2YWxpZGF0ZUFzeW5jKCdtYXhEdXJhdGlvbicsICdkdXJhdGlvbi5tYXgnLCAvYXVkaW98dmlkZW8vLFxuICAgICAgdGhpcy5tZWRpYUR1cmF0aW9uLCBmdW5jdGlvbiAoZCwgdmFsKSB7XG4gICAgICAgIHJldHVybiBkIDw9IHVwbG9hZC50cmFuc2xhdGVTY2FsYXJzKHZhbCk7XG4gICAgICB9KSk7XG4gICAgcHJvbWlzZXMucHVzaCh2YWxpZGF0ZUFzeW5jKCdtaW5EdXJhdGlvbicsICdkdXJhdGlvbi5taW4nLCAvYXVkaW98dmlkZW8vLFxuICAgICAgdGhpcy5tZWRpYUR1cmF0aW9uLCBmdW5jdGlvbiAoZCwgdmFsKSB7XG4gICAgICAgIHJldHVybiBkID49IHVwbG9hZC50cmFuc2xhdGVTY2FsYXJzKHZhbCk7XG4gICAgICB9KSk7XG4gICAgcHJvbWlzZXMucHVzaCh2YWxpZGF0ZUFzeW5jKCdkdXJhdGlvbicsIG51bGwsIC9hdWRpb3x2aWRlby8sXG4gICAgICBmdW5jdGlvbiAoZmlsZSwgdmFsKSB7XG4gICAgICAgIHJldHVybiB1cGxvYWQuZW1wdHlQcm9taXNlKHZhbCk7XG4gICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0pKTtcblxuICAgIHByb21pc2VzLnB1c2godmFsaWRhdGVBc3luYygndmFsaWRhdGVBc3luY0ZuJywgbnVsbCwgbnVsbCxcbiAgICAgIGZ1bmN0aW9uIChmaWxlLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0sIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByID09PSB0cnVlIHx8IHIgPT09IG51bGwgfHwgciA9PT0gJyc7XG4gICAgICB9KSk7XG5cbiAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAocnVuQWxsVmFsaWRhdGlvbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpbGUgPSBmaWxlc1tpXTtcbiAgICAgICAgICBpZiAoZmlsZS4kZXJyb3IpIHtcbiAgICAgICAgICAgIGZpbGVzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBydW5BbGxWYWxpZGF0aW9uID0gZmFsc2U7XG4gICAgICB2YWxpZGF0ZVN5bmMoJ21heEZpbGVzJywgbnVsbCwgZnVuY3Rpb24gKGZpbGUsIHZhbCwgaSkge1xuICAgICAgICByZXR1cm4gcHJldkxlbmd0aCArIGkgPCB2YWw7XG4gICAgICB9KTtcblxuICAgICAgZGVmZmVyLnJlc29sdmUoeyd2YWxpZEZpbGVzJzogZmlsZXMsICdpbnZhbGlkRmlsZXMnOiBpbnZhbGlkRmlsZXN9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZmVyLnByb21pc2U7XG4gIH07XG5cbiAgdXBsb2FkLmltYWdlRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgaWYgKGZpbGUuJG5nZldpZHRoICYmIGZpbGUuJG5nZkhlaWdodCkge1xuICAgICAgdmFyIGQgPSAkcS5kZWZlcigpO1xuICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkLnJlc29sdmUoe3dpZHRoOiBmaWxlLiRuZ2ZXaWR0aCwgaGVpZ2h0OiBmaWxlLiRuZ2ZIZWlnaHR9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKGZpbGUuJG5nZkRpbWVuc2lvblByb21pc2UpIHJldHVybiBmaWxlLiRuZ2ZEaW1lbnNpb25Qcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZmlsZS50eXBlLmluZGV4T2YoJ2ltYWdlJykgIT09IDApIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdub3QgaW1hZ2UnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdXBsb2FkLmRhdGFVcmwoZmlsZSkudGhlbihmdW5jdGlvbiAoZGF0YVVybCkge1xuICAgICAgICB2YXIgaW1nID0gYW5ndWxhci5lbGVtZW50KCc8aW1nPicpLmF0dHIoJ3NyYycsIGRhdGFVcmwpXG4gICAgICAgICAgLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKS5jc3MoJ3Bvc2l0aW9uJywgJ2ZpeGVkJylcbiAgICAgICAgICAuY3NzKCdtYXgtd2lkdGgnLCAnbm9uZSAhaW1wb3J0YW50JykuY3NzKCdtYXgtaGVpZ2h0JywgJ25vbmUgIWltcG9ydGFudCcpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgICAgICAgdmFyIHdpZHRoID0gaW1nWzBdLm5hdHVyYWxXaWR0aCB8fCBpbWdbMF0uY2xpZW50V2lkdGg7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGltZ1swXS5uYXR1cmFsSGVpZ2h0IHx8IGltZ1swXS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgaW1nLnJlbW92ZSgpO1xuICAgICAgICAgIGZpbGUuJG5nZldpZHRoID0gd2lkdGg7XG4gICAgICAgICAgZmlsZS4kbmdmSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoe3dpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHR9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgICAgIGltZy5yZW1vdmUoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoJ2xvYWQgZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltZy5vbignbG9hZCcsIHN1Y2Nlc3MpO1xuICAgICAgICBpbWcub24oJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgICAgIHZhciBzZWNvbmRzQ291bnRlciA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZEVycm9ySW5DYXNlT2ZOb0NhbGxiYWNrKCkge1xuICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbWdbMF0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBpZiAoaW1nWzBdLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcygpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlY29uZHNDb3VudGVyKysgPiAxMCkge1xuICAgICAgICAgICAgICAgIGVycm9yKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkRXJyb3JJbkNhc2VPZk5vQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tMb2FkRXJyb3JJbkNhc2VPZk5vQ2FsbGJhY2soKTtcblxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXSkuYXBwZW5kKGltZyk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCgnbG9hZCBlcnJvcicpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmaWxlLiRuZ2ZEaW1lbnNpb25Qcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZTtcbiAgICBmaWxlLiRuZ2ZEaW1lbnNpb25Qcm9taXNlWydmaW5hbGx5J10oZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIGZpbGUuJG5nZkRpbWVuc2lvblByb21pc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbGUuJG5nZkRpbWVuc2lvblByb21pc2U7XG4gIH07XG5cbiAgdXBsb2FkLm1lZGlhRHVyYXRpb24gPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgIGlmIChmaWxlLiRuZ2ZEdXJhdGlvbikge1xuICAgICAgdmFyIGQgPSAkcS5kZWZlcigpO1xuICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkLnJlc29sdmUoZmlsZS4kbmdmRHVyYXRpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZC5wcm9taXNlO1xuICAgIH1cbiAgICBpZiAoZmlsZS4kbmdmRHVyYXRpb25Qcm9taXNlKSByZXR1cm4gZmlsZS4kbmdmRHVyYXRpb25Qcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZmlsZS50eXBlLmluZGV4T2YoJ2F1ZGlvJykgIT09IDAgJiYgZmlsZS50eXBlLmluZGV4T2YoJ3ZpZGVvJykgIT09IDApIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdub3QgbWVkaWEnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdXBsb2FkLmRhdGFVcmwoZmlsZSkudGhlbihmdW5jdGlvbiAoZGF0YVVybCkge1xuICAgICAgICB2YXIgZWwgPSBhbmd1bGFyLmVsZW1lbnQoZmlsZS50eXBlLmluZGV4T2YoJ2F1ZGlvJykgPT09IDAgPyAnPGF1ZGlvPicgOiAnPHZpZGVvPicpXG4gICAgICAgICAgLmF0dHIoJ3NyYycsIGRhdGFVcmwpLmNzcygndmlzaWJpbGl0eScsICdub25lJykuY3NzKCdwb3NpdGlvbicsICdmaXhlZCcpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gZWxbMF0uZHVyYXRpb247XG4gICAgICAgICAgZmlsZS4kbmdmRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgICAgIGVsLnJlbW92ZSgpO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgnbG9hZCBlcnJvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwub24oJ2xvYWRlZG1ldGFkYXRhJywgc3VjY2Vzcyk7XG4gICAgICAgIGVsLm9uKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBjaGVja0xvYWRFcnJvcigpIHtcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZWxbMF0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBpZiAoZWxbMF0uZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPiAxMCkge1xuICAgICAgICAgICAgICAgIGVycm9yKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tMb2FkRXJyb3IoKTtcblxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQuYm9keSkuYXBwZW5kKGVsKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdsb2FkIGVycm9yJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZpbGUuJG5nZkR1cmF0aW9uUHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG4gICAgZmlsZS4kbmdmRHVyYXRpb25Qcm9taXNlWydmaW5hbGx5J10oZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIGZpbGUuJG5nZkR1cmF0aW9uUHJvbWlzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmlsZS4kbmdmRHVyYXRpb25Qcm9taXNlO1xuICB9O1xuICByZXR1cm4gdXBsb2FkO1xufVxuXSk7XG5cbm5nRmlsZVVwbG9hZC5zZXJ2aWNlKCdVcGxvYWRSZXNpemUnLCBbJ1VwbG9hZFZhbGlkYXRlJywgJyRxJywgZnVuY3Rpb24gKFVwbG9hZFZhbGlkYXRlLCAkcSkge1xuICB2YXIgdXBsb2FkID0gVXBsb2FkVmFsaWRhdGU7XG5cbiAgLyoqXG4gICAqIENvbnNlcnZlIGFzcGVjdCByYXRpbyBvZiB0aGUgb3JpZ2luYWwgcmVnaW9uLiBVc2VmdWwgd2hlbiBzaHJpbmtpbmcvZW5sYXJnaW5nXG4gICAqIGltYWdlcyB0byBmaXQgaW50byBhIGNlcnRhaW4gYXJlYS5cbiAgICogU291cmNlOiAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTQ3MzE5MjJcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY1dpZHRoIFNvdXJjZSBhcmVhIHdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzcmNIZWlnaHQgU291cmNlIGFyZWEgaGVpZ2h0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhXaWR0aCBOZXN0YWJsZSBhcmVhIG1heGltdW0gYXZhaWxhYmxlIHdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhIZWlnaHQgTmVzdGFibGUgYXJlYSBtYXhpbXVtIGF2YWlsYWJsZSBoZWlnaHRcbiAgICogQHJldHVybiB7T2JqZWN0fSB7IHdpZHRoLCBoZWlnaHQgfVxuICAgKi9cbiAgdmFyIGNhbGN1bGF0ZUFzcGVjdFJhdGlvRml0ID0gZnVuY3Rpb24gKHNyY1dpZHRoLCBzcmNIZWlnaHQsIG1heFdpZHRoLCBtYXhIZWlnaHQsIGNlbnRlckNyb3ApIHtcbiAgICB2YXIgcmF0aW8gPSBjZW50ZXJDcm9wID8gTWF0aC5tYXgobWF4V2lkdGggLyBzcmNXaWR0aCwgbWF4SGVpZ2h0IC8gc3JjSGVpZ2h0KSA6XG4gICAgICBNYXRoLm1pbihtYXhXaWR0aCAvIHNyY1dpZHRoLCBtYXhIZWlnaHQgLyBzcmNIZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogc3JjV2lkdGggKiByYXRpbywgaGVpZ2h0OiBzcmNIZWlnaHQgKiByYXRpbyxcbiAgICAgIG1hcmdpblg6IHNyY1dpZHRoICogcmF0aW8gLSBtYXhXaWR0aCwgbWFyZ2luWTogc3JjSGVpZ2h0ICogcmF0aW8gLSBtYXhIZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIC8vIEV4dHJhY3RlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9yb21lbGdvbWV6L2FuZ3VsYXItZmlyZWJhc2UtaW1hZ2UtdXBsb2FkL2Jsb2IvbWFzdGVyL2FwcC9zY3JpcHRzL2ZpbGVVcGxvYWQuanMjTDg5XG4gIHZhciByZXNpemUgPSBmdW5jdGlvbiAoaW1hZ2VuLCB3aWR0aCwgaGVpZ2h0LCBxdWFsaXR5LCB0eXBlLCByYXRpbywgY2VudGVyQ3JvcCwgcmVzaXplSWYpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGltYWdlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGltYWdlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3Zpc2liaWxpdHk6aGlkZGVuO3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6LTEwMDAwMCcpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1hZ2VFbGVtZW50KTtcblxuICAgIGltYWdlRWxlbWVudC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW1nV2lkdGggPSBpbWFnZUVsZW1lbnQud2lkdGgsIGltZ0hlaWdodCA9IGltYWdlRWxlbWVudC5oZWlnaHQ7XG4gICAgICBpbWFnZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWFnZUVsZW1lbnQpO1xuICAgICAgaWYgKHJlc2l6ZUlmICE9IG51bGwgJiYgcmVzaXplSWYoaW1nV2lkdGgsIGltZ0hlaWdodCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCgncmVzaXplSWYnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHJhdGlvKSB7XG4gICAgICAgICAgdmFyIHJhdGlvRmxvYXQgPSB1cGxvYWQucmF0aW9Ub0Zsb2F0KHJhdGlvKTtcbiAgICAgICAgICB2YXIgaW1nUmF0aW8gPSBpbWdXaWR0aCAvIGltZ0hlaWdodDtcbiAgICAgICAgICBpZiAoaW1nUmF0aW8gPCByYXRpb0Zsb2F0KSB7XG4gICAgICAgICAgICB3aWR0aCA9IGltZ1dpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyByYXRpb0Zsb2F0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBpbWdIZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIHJhdGlvRmxvYXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IGltZ1dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgaGVpZ2h0ID0gaW1nSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gY2FsY3VsYXRlQXNwZWN0UmF0aW9GaXQoaW1nV2lkdGgsIGltZ0hlaWdodCwgd2lkdGgsIGhlaWdodCwgY2VudGVyQ3JvcCk7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQud2lkdGggPSBNYXRoLm1pbihkaW1lbnNpb25zLndpZHRoLCB3aWR0aCk7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gTWF0aC5taW4oZGltZW5zaW9ucy5oZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZUVsZW1lbnQsXG4gICAgICAgICAgTWF0aC5taW4oMCwgLWRpbWVuc2lvbnMubWFyZ2luWCAvIDIpLCBNYXRoLm1pbigwLCAtZGltZW5zaW9ucy5tYXJnaW5ZIC8gMiksXG4gICAgICAgICAgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGNhbnZhc0VsZW1lbnQudG9EYXRhVVJMKHR5cGUgfHwgJ2ltYWdlL1dlYlAnLCBxdWFsaXR5IHx8IDAuOTM0KSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgaW1hZ2VFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1hZ2VFbGVtZW50KTtcbiAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgIH07XG4gICAgaW1hZ2VFbGVtZW50LnNyYyA9IGltYWdlbjtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfTtcblxuICB1cGxvYWQuZGF0YVVybHRvQmxvYiA9IGZ1bmN0aW9uIChkYXRhdXJsLCBuYW1lLCBvcmlnU2l6ZSkge1xuICAgIHZhciBhcnIgPSBkYXRhdXJsLnNwbGl0KCcsJyksIG1pbWUgPSBhcnJbMF0ubWF0Y2goLzooLio/KTsvKVsxXSxcbiAgICAgIGJzdHIgPSBhdG9iKGFyclsxXSksIG4gPSBic3RyLmxlbmd0aCwgdThhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICB3aGlsZSAobi0tKSB7XG4gICAgICB1OGFycltuXSA9IGJzdHIuY2hhckNvZGVBdChuKTtcbiAgICB9XG4gICAgdmFyIGJsb2IgPSBuZXcgd2luZG93LkJsb2IoW3U4YXJyXSwge3R5cGU6IG1pbWV9KTtcbiAgICBibG9iLm5hbWUgPSBuYW1lO1xuICAgIGJsb2IuJG5nZk9yaWdTaXplID0gb3JpZ1NpemU7XG4gICAgcmV0dXJuIGJsb2I7XG4gIH07XG5cbiAgdXBsb2FkLmlzUmVzaXplU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iICYmIGVsZW0uZ2V0Q29udGV4dCAmJiBlbGVtLmdldENvbnRleHQoJzJkJykgJiYgd2luZG93LkJsb2I7XG4gIH07XG5cbiAgaWYgKHVwbG9hZC5pc1Jlc2l6ZVN1cHBvcnRlZCgpKSB7XG4gICAgLy8gYWRkIG5hbWUgZ2V0dGVyIHRvIHRoZSBibG9iIGNvbnN0cnVjdG9yIHByb3RvdHlwZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuQmxvYi5wcm90b3R5cGUsICduYW1lJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRuZ2ZOYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpcy4kbmdmTmFtZSA9IHY7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICB1cGxvYWQucmVzaXplID0gZnVuY3Rpb24gKGZpbGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoZmlsZS50eXBlLmluZGV4T2YoJ2ltYWdlJykgIT09IDApIHJldHVybiB1cGxvYWQuZW1wdHlQcm9taXNlKGZpbGUpO1xuXG4gICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICB1cGxvYWQuZGF0YVVybChmaWxlLCB0cnVlKS50aGVuKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHJlc2l6ZSh1cmwsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0LCBvcHRpb25zLnF1YWxpdHksIG9wdGlvbnMudHlwZSB8fCBmaWxlLnR5cGUsXG4gICAgICAgIG9wdGlvbnMucmF0aW8sIG9wdGlvbnMuY2VudGVyQ3JvcCwgb3B0aW9ucy5yZXNpemVJZilcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGFVcmwpIHtcbiAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnaW1hZ2UvanBlZycgJiYgb3B0aW9ucy5yZXN0b3JlRXhpZiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRhdGFVcmwgPSB1cGxvYWQucmVzdG9yZUV4aWYodXJsLCBkYXRhVXJsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7dGhyb3cgZTt9LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBibG9iID0gdXBsb2FkLmRhdGFVcmx0b0Jsb2IoZGF0YVVybCwgZmlsZS5uYW1lLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShibG9iKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgIGlmIChyID09PSAncmVzaXplSWYnKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3Qocik7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIHVwbG9hZDtcbn1dKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgbmdGaWxlVXBsb2FkLmRpcmVjdGl2ZSgnbmdmRHJvcCcsIFsnJHBhcnNlJywgJyR0aW1lb3V0JywgJyR3aW5kb3cnLCAnVXBsb2FkJywgJyRodHRwJywgJyRxJyxcbiAgICBmdW5jdGlvbiAoJHBhcnNlLCAkdGltZW91dCwgJHdpbmRvdywgVXBsb2FkLCAkaHR0cCwgJHEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnQUVDJyxcbiAgICAgICAgcmVxdWlyZTogJz9uZ01vZGVsJyxcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtLCBhdHRyLCBuZ01vZGVsKSB7XG4gICAgICAgICAgbGlua0Ryb3Aoc2NvcGUsIGVsZW0sIGF0dHIsIG5nTW9kZWwsICRwYXJzZSwgJHRpbWVvdXQsICR3aW5kb3csIFVwbG9hZCwgJGh0dHAsICRxKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XSk7XG5cbiAgbmdGaWxlVXBsb2FkLmRpcmVjdGl2ZSgnbmdmTm9GaWxlRHJvcCcsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCBlbGVtKSB7XG4gICAgICBpZiAoZHJvcEF2YWlsYWJsZSgpKSBlbGVtLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgbmdGaWxlVXBsb2FkLmRpcmVjdGl2ZSgnbmdmRHJvcEF2YWlsYWJsZScsIFsnJHBhcnNlJywgJyR0aW1lb3V0JywgJ1VwbG9hZCcsIGZ1bmN0aW9uICgkcGFyc2UsICR0aW1lb3V0LCBVcGxvYWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCBlbGVtLCBhdHRyKSB7XG4gICAgICBpZiAoZHJvcEF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHZhciBtb2RlbCA9ICRwYXJzZShVcGxvYWQuYXR0ckdldHRlcignbmdmRHJvcEF2YWlsYWJsZScsIGF0dHIpKTtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1vZGVsKHNjb3BlKTtcbiAgICAgICAgICBpZiAobW9kZWwuYXNzaWduKSB7XG4gICAgICAgICAgICBtb2RlbC5hc3NpZ24oc2NvcGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIGxpbmtEcm9wKHNjb3BlLCBlbGVtLCBhdHRyLCBuZ01vZGVsLCAkcGFyc2UsICR0aW1lb3V0LCAkd2luZG93LCB1cGxvYWQsICRodHRwLCAkcSkge1xuICAgIHZhciBhdmFpbGFibGUgPSBkcm9wQXZhaWxhYmxlKCk7XG5cbiAgICB2YXIgYXR0ckdldHRlciA9IGZ1bmN0aW9uIChuYW1lLCBzY29wZSwgcGFyYW1zKSB7XG4gICAgICByZXR1cm4gdXBsb2FkLmF0dHJHZXR0ZXIobmFtZSwgYXR0ciwgc2NvcGUsIHBhcmFtcyk7XG4gICAgfTtcblxuICAgIGlmIChhdHRyR2V0dGVyKCdkcm9wQXZhaWxhYmxlJykpIHtcbiAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNjb3BlW2F0dHJHZXR0ZXIoJ2Ryb3BBdmFpbGFibGUnKV0pIHtcbiAgICAgICAgICBzY29wZVthdHRyR2V0dGVyKCdkcm9wQXZhaWxhYmxlJyldLnZhbHVlID0gYXZhaWxhYmxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlW2F0dHJHZXR0ZXIoJ2Ryb3BBdmFpbGFibGUnKV0gPSBhdmFpbGFibGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWF2YWlsYWJsZSkge1xuICAgICAgaWYgKGF0dHJHZXR0ZXIoJ25nZkhpZGVPbkRyb3BOb3RBdmFpbGFibGUnLCBzY29wZSkgPT09IHRydWUpIHtcbiAgICAgICAgZWxlbS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGlzYWJsZWQoKSB7XG4gICAgICByZXR1cm4gZWxlbS5hdHRyKCdkaXNhYmxlZCcpIHx8IGF0dHJHZXR0ZXIoJ25nZkRyb3BEaXNhYmxlZCcsIHNjb3BlKTtcbiAgICB9XG5cbiAgICBpZiAoYXR0ckdldHRlcignbmdmU2VsZWN0JykgPT0gbnVsbCkge1xuICAgICAgdXBsb2FkLnJlZ2lzdGVyTW9kZWxDaGFuZ2VWYWxpZGF0b3IobmdNb2RlbCwgYXR0ciwgc2NvcGUpO1xuICAgIH1cblxuICAgIHZhciBsZWF2ZVRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBzdG9wUHJvcGFnYXRpb24gPSAkcGFyc2UoYXR0ckdldHRlcignbmdmU3RvcFByb3BhZ2F0aW9uJykpO1xuICAgIHZhciBkcmFnT3ZlckRlbGF5ID0gMTtcbiAgICB2YXIgYWN0dWFsRHJhZ092ZXJDbGFzcztcblxuICAgIGVsZW1bMF0uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoaXNEaXNhYmxlZCgpIHx8ICF1cGxvYWQuc2hvdWxkVXBkYXRlT24oJ2Ryb3AnLCBhdHRyLCBzY29wZSkpIHJldHVybjtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbihzY29wZSkpIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIC8vIGhhbmRsaW5nIGRyYWdvdmVyIGV2ZW50cyBmcm9tIHRoZSBDaHJvbWUgZG93bmxvYWQgYmFyXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xKSB7XG4gICAgICAgIHZhciBiID0gZXZ0LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkO1xuICAgICAgICBldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAoJ21vdmUnID09PSBiIHx8ICdsaW5rTW92ZScgPT09IGIpID8gJ21vdmUnIDogJ2NvcHknO1xuICAgICAgfVxuICAgICAgJHRpbWVvdXQuY2FuY2VsKGxlYXZlVGltZW91dCk7XG4gICAgICBpZiAoIWFjdHVhbERyYWdPdmVyQ2xhc3MpIHtcbiAgICAgICAgYWN0dWFsRHJhZ092ZXJDbGFzcyA9ICdDJztcbiAgICAgICAgY2FsY3VsYXRlRHJhZ092ZXJDbGFzcyhzY29wZSwgYXR0ciwgZXZ0LCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICBhY3R1YWxEcmFnT3ZlckNsYXNzID0gY2xheno7XG4gICAgICAgICAgZWxlbS5hZGRDbGFzcyhhY3R1YWxEcmFnT3ZlckNsYXNzKTtcbiAgICAgICAgICBhdHRyR2V0dGVyKCduZ2ZEcmFnJywgc2NvcGUsIHskaXNEcmFnZ2luZzogdHJ1ZSwgJGNsYXNzOiBhY3R1YWxEcmFnT3ZlckNsYXNzLCAkZXZlbnQ6IGV2dH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gICAgZWxlbVswXS5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoaXNEaXNhYmxlZCgpIHx8ICF1cGxvYWQuc2hvdWxkVXBkYXRlT24oJ2Ryb3AnLCBhdHRyLCBzY29wZSkpIHJldHVybjtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbihzY29wZSkpIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgZWxlbVswXS5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoaXNEaXNhYmxlZCgpIHx8ICF1cGxvYWQuc2hvdWxkVXBkYXRlT24oJ2Ryb3AnLCBhdHRyLCBzY29wZSkpIHJldHVybjtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbihzY29wZSkpIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGxlYXZlVGltZW91dCA9ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGFjdHVhbERyYWdPdmVyQ2xhc3MpIGVsZW0ucmVtb3ZlQ2xhc3MoYWN0dWFsRHJhZ092ZXJDbGFzcyk7XG4gICAgICAgIGFjdHVhbERyYWdPdmVyQ2xhc3MgPSBudWxsO1xuICAgICAgICBhdHRyR2V0dGVyKCduZ2ZEcmFnJywgc2NvcGUsIHskaXNEcmFnZ2luZzogZmFsc2UsICRldmVudDogZXZ0fSk7XG4gICAgICB9LCBkcmFnT3ZlckRlbGF5IHx8IDEwMCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGVsZW1bMF0uYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmIChpc0Rpc2FibGVkKCkgfHwgIXVwbG9hZC5zaG91bGRVcGRhdGVPbignZHJvcCcsIGF0dHIsIHNjb3BlKSkgcmV0dXJuO1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKHNjb3BlKSkgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKGFjdHVhbERyYWdPdmVyQ2xhc3MpIGVsZW0ucmVtb3ZlQ2xhc3MoYWN0dWFsRHJhZ092ZXJDbGFzcyk7XG4gICAgICBhY3R1YWxEcmFnT3ZlckNsYXNzID0gbnVsbDtcbiAgICAgIGV4dHJhY3RGaWxlc0FuZFVwZGF0ZU1vZGVsKGV2dC5kYXRhVHJhbnNmZXIsIGV2dCwgJ2Ryb3BVcmwnKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgZWxlbVswXS5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTEgJiZcbiAgICAgICAgYXR0ckdldHRlcignbmdmRW5hYmxlRmlyZWZveFBhc3RlJywgc2NvcGUpKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlzYWJsZWQoKSB8fCAhdXBsb2FkLnNob3VsZFVwZGF0ZU9uKCdwYXN0ZScsIGF0dHIsIHNjb3BlKSkgcmV0dXJuO1xuICAgICAgZXh0cmFjdEZpbGVzQW5kVXBkYXRlTW9kZWwoZXZ0LmNsaXBib2FyZERhdGEgfHwgZXZ0Lm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YSwgZXZ0LCAncGFzdGVVcmwnKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA+IC0xICYmXG4gICAgICBhdHRyR2V0dGVyKCduZ2ZFbmFibGVGaXJlZm94UGFzdGUnLCBzY29wZSkpIHtcbiAgICAgIGVsZW0uYXR0cignY29udGVudGVkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICBlbGVtLm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGaWxlc0FuZFVwZGF0ZU1vZGVsKHNvdXJjZSwgZXZ0LCB1cGRhdGVPblR5cGUpIHtcbiAgICAgIGlmICghc291cmNlKSByZXR1cm47XG4gICAgICAvLyBodG1sIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgb24gdGhlIHNhbWUgcHJvY2VzcyBvdGhlcndpc2UgdGhlIGRhdGEgd2lsbCBiZSB3aXBlZFxuICAgICAgLy8gYWZ0ZXIgcHJvbWlzZSByZXNvbHZlIG9yIHNldFRpbWVvdXQuXG4gICAgICB2YXIgaHRtbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGh0bWwgPSBzb3VyY2UgJiYgc291cmNlLmdldERhdGEgJiYgc291cmNlLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICAgICAgfSBjYXRjaCAoZSkgey8qIEZpeCBJRTExIHRoYXQgdGhyb3cgZXJyb3IgY2FsbGluZyBnZXREYXRhICovXG4gICAgICB9XG4gICAgICBleHRyYWN0RmlsZXMoc291cmNlLml0ZW1zLCBzb3VyY2UuZmlsZXMsIGF0dHJHZXR0ZXIoJ25nZkFsbG93RGlyJywgc2NvcGUpICE9PSBmYWxzZSxcbiAgICAgICAgYXR0ckdldHRlcignbXVsdGlwbGUnKSB8fCBhdHRyR2V0dGVyKCduZ2ZNdWx0aXBsZScsIHNjb3BlKSkudGhlbihmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHVwZGF0ZU1vZGVsKGZpbGVzLCBldnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dHJhY3RGaWxlc0Zyb21IdG1sKHVwZGF0ZU9uVHlwZSwgaHRtbCkudGhlbihmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZU1vZGVsKGZpbGVzLCBldnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNb2RlbChmaWxlcywgZXZ0KSB7XG4gICAgICB1cGxvYWQudXBkYXRlTW9kZWwobmdNb2RlbCwgYXR0ciwgc2NvcGUsIGF0dHJHZXR0ZXIoJ25nZkNoYW5nZScpIHx8IGF0dHJHZXR0ZXIoJ25nZkRyb3AnKSwgZmlsZXMsIGV2dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZpbGVzRnJvbUh0bWwodXBkYXRlT24sIGh0bWwpIHtcbiAgICAgIGlmICghdXBsb2FkLnNob3VsZFVwZGF0ZU9uKHVwZGF0ZU9uLCBhdHRyLCBzY29wZSkgfHwgdHlwZW9mIGh0bWwgIT09ICdzdHJpbmcnKSByZXR1cm4gdXBsb2FkLnJlamVjdFByb21pc2UoW10pO1xuICAgICAgdmFyIHVybHMgPSBbXTtcbiAgICAgIGh0bWwucmVwbGFjZSgvPChpbWcgc3JjfGltZyBbXj5dKiBzcmMpICo9XFxcIihbXlxcXCJdKilcXFwiL2dpLCBmdW5jdGlvbiAobSwgbiwgc3JjKSB7XG4gICAgICAgIHVybHMucHVzaChzcmMpO1xuICAgICAgfSk7XG4gICAgICB2YXIgcHJvbWlzZXMgPSBbXSwgZmlsZXMgPSBbXTtcbiAgICAgIGlmICh1cmxzLmxlbmd0aCkge1xuICAgICAgICBhbmd1bGFyLmZvckVhY2godXJscywgZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2godXBsb2FkLnVybFRvQmxvYih1cmwpLnRoZW4oZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goYmxvYik7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlZmVyID0gJHEuZGVmZXIoKTtcbiAgICAgICAgJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWZlci5yZXNvbHZlKGZpbGVzKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGxvYWQuZW1wdHlQcm9taXNlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlRHJhZ092ZXJDbGFzcyhzY29wZSwgYXR0ciwgZXZ0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIG9iaiA9IGF0dHJHZXR0ZXIoJ25nZkRyYWdPdmVyQ2xhc3MnLCBzY29wZSwgeyRldmVudDogZXZ0fSksIGRDbGFzcyA9ICdkcmFnb3Zlcic7XG4gICAgICBpZiAoYW5ndWxhci5pc1N0cmluZyhvYmopKSB7XG4gICAgICAgIGRDbGFzcyA9IG9iajtcbiAgICAgIH0gZWxzZSBpZiAob2JqKSB7XG4gICAgICAgIGlmIChvYmouZGVsYXkpIGRyYWdPdmVyRGVsYXkgPSBvYmouZGVsYXk7XG4gICAgICAgIGlmIChvYmouYWNjZXB0IHx8IG9iai5yZWplY3QpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSBldnQuZGF0YVRyYW5zZmVyLml0ZW1zO1xuICAgICAgICAgIGlmIChpdGVtcyA9PSBudWxsIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRDbGFzcyA9IG9iai5hY2NlcHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gb2JqLnBhdHRlcm4gfHwgYXR0ckdldHRlcignbmdmUGF0dGVybicsIHNjb3BlLCB7JGV2ZW50OiBldnR9KTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgICAgaWYgKCF1cGxvYWQudmFsaWRhdGVQYXR0ZXJuKGl0ZW1zW2xlbl0sIHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgZENsYXNzID0gb2JqLnJlamVjdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkQ2xhc3MgPSBvYmouYWNjZXB0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhkQ2xhc3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGaWxlcyhpdGVtcywgZmlsZUxpc3QsIGFsbG93RGlyLCBtdWx0aXBsZSkge1xuICAgICAgdmFyIG1heEZpbGVzID0gdXBsb2FkLmdldFZhbGlkYXRpb25BdHRyKGF0dHIsIHNjb3BlLCAnbWF4RmlsZXMnKTtcbiAgICAgIGlmIChtYXhGaWxlcyA9PSBudWxsKSB7XG4gICAgICAgIG1heEZpbGVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXhUb3RhbFNpemUgPSB1cGxvYWQuZ2V0VmFsaWRhdGlvbkF0dHIoYXR0ciwgc2NvcGUsICdtYXhUb3RhbFNpemUnKTtcbiAgICAgIGlmIChtYXhUb3RhbFNpemUgPT0gbnVsbCkge1xuICAgICAgICBtYXhUb3RhbFNpemUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgfVxuICAgICAgdmFyIGluY2x1ZGVEaXIgPSBhdHRyR2V0dGVyKCduZ2ZJbmNsdWRlRGlyJywgc2NvcGUpO1xuICAgICAgdmFyIGZpbGVzID0gW10sIHRvdGFsU2l6ZSA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIHRyYXZlcnNlRmlsZVRyZWUoZW50cnksIHBhdGgpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gJHEuZGVmZXIoKTtcbiAgICAgICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFt1cGxvYWQuZW1wdHlQcm9taXNlKCldO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVEaXIpIHtcbiAgICAgICAgICAgICAgdmFyIGZpbGUgPSB7dHlwZTogJ2RpcmVjdG9yeSd9O1xuICAgICAgICAgICAgICBmaWxlLm5hbWUgPSBmaWxlLnBhdGggPSAocGF0aCB8fCAnJykgKyBlbnRyeS5uYW1lO1xuICAgICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpclJlYWRlciA9IGVudHJ5LmNyZWF0ZVJlYWRlcigpO1xuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciByZWFkRW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZGlyUmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVudHJpZXMuc2xpY2UoMCksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA8PSBtYXhGaWxlcyAmJiB0b3RhbFNpemUgPD0gbWF4VG90YWxTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRyYXZlcnNlRmlsZVRyZWUoZSwgKHBhdGggPyBwYXRoIDogJycpICsgZW50cnkubmFtZSArICcvJykpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzID0gZW50cmllcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocmVzdWx0cyB8fCBbXSwgMCkpO1xuICAgICAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGRlZmVyLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRyeS5maWxlKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmlsZS5wYXRoID0gKHBhdGggPyBwYXRoIDogJycpICsgZmlsZS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlRGlyKSB7XG4gICAgICAgICAgICAgICAgICBmaWxlID0gdXBsb2FkLnJlbmFtZShmaWxlLCBmaWxlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBmaWxlLnNpemU7XG4gICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlcyA9IFt1cGxvYWQuZW1wdHlQcm9taXNlKCldO1xuXG4gICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCAmJiAkd2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAnZmlsZTonKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaXRlbXNbaV0ud2Via2l0R2V0QXNFbnRyeSAmJiBpdGVtc1tpXS53ZWJraXRHZXRBc0VudHJ5KCkgJiYgaXRlbXNbaV0ud2Via2l0R2V0QXNFbnRyeSgpLmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBpdGVtc1tpXS53ZWJraXRHZXRBc0VudHJ5KCk7XG4gICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkgJiYgIWFsbG93RGlyKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0cmF2ZXJzZUZpbGVUcmVlKGVudHJ5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmID0gaXRlbXNbaV0uZ2V0QXNGaWxlKCk7XG4gICAgICAgICAgICBpZiAoZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGZpbGVzLnB1c2goZik7XG4gICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBmLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGggPiBtYXhGaWxlcyB8fCB0b3RhbFNpemUgPiBtYXhUb3RhbFNpemUgfHxcbiAgICAgICAgICAgICghbXVsdGlwbGUgJiYgZmlsZXMubGVuZ3RoID4gMCkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmlsZUxpc3QgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsZUxpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBmaWxlID0gZmlsZUxpc3QuaXRlbShqKTtcbiAgICAgICAgICAgIGlmIChmaWxlLnR5cGUgfHwgZmlsZS5zaXplID4gMCkge1xuICAgICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgICB0b3RhbFNpemUgKz0gZmlsZS5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IG1heEZpbGVzIHx8IHRvdGFsU2l6ZSA+IG1heFRvdGFsU2l6ZSB8fFxuICAgICAgICAgICAgICAoIW11bHRpcGxlICYmIGZpbGVzLmxlbmd0aCA+IDApKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmVyID0gJHEuZGVmZXIoKTtcbiAgICAgICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghbXVsdGlwbGUgJiYgIWluY2x1ZGVEaXIgJiYgZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChmaWxlc1tpXSAmJiBmaWxlc1tpXS50eXBlID09PSAnZGlyZWN0b3J5JykgaSsrO1xuICAgICAgICAgIGRlZmVyLnJlc29sdmUoW2ZpbGVzW2ldXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmZXIucmVzb2x2ZShmaWxlcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRlZmVyLnJlamVjdChlKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcm9wQXZhaWxhYmxlKCkge1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXR1cm4gKCdkcmFnZ2FibGUnIGluIGRpdikgJiYgKCdvbmRyb3AnIGluIGRpdikgJiYgIS9FZGdlXFwvMTIuL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG59KSgpO1xuXG4vLyBjdXN0b21pemVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2V4aWYtanMvZXhpZi1qc1xubmdGaWxlVXBsb2FkLnNlcnZpY2UoJ1VwbG9hZEV4aWYnLCBbJ1VwbG9hZFJlc2l6ZScsICckcScsIGZ1bmN0aW9uIChVcGxvYWRSZXNpemUsICRxKSB7XG4gIHZhciB1cGxvYWQgPSBVcGxvYWRSZXNpemU7XG5cbiAgdXBsb2FkLmlzRXhpZlN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2luZG93LkZpbGVSZWFkZXIgJiYgbmV3IEZpbGVSZWFkZXIoKS5yZWFkQXNBcnJheUJ1ZmZlciAmJiB1cGxvYWQuaXNSZXNpemVTdXBwb3J0ZWQoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShjdHgsIG9yaWVudGF0aW9uLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gY3R4LnRyYW5zZm9ybSgtMSwgMCwgMCwgMSwgd2lkdGgsIDApO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gY3R4LnRyYW5zZm9ybSgtMSwgMCwgMCwgLTEsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgaGVpZ2h0KTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIGN0eC50cmFuc2Zvcm0oMCwgMSwgMSwgMCwgMCwgMCk7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiBjdHgudHJhbnNmb3JtKDAsIDEsIC0xLCAwLCBoZWlnaHQsIDApO1xuICAgICAgY2FzZSA3OlxuICAgICAgICByZXR1cm4gY3R4LnRyYW5zZm9ybSgwLCAtMSwgLTEsIDAsIGhlaWdodCwgd2lkdGgpO1xuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gY3R4LnRyYW5zZm9ybSgwLCAtMSwgMSwgMCwgMCwgd2lkdGgpO1xuICAgIH1cbiAgfVxuXG4gIHVwbG9hZC5yZWFkT3JpZW50YXRpb24gPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHNsaWNlZEZpbGUgPSBmaWxlLnNsaWNlID8gZmlsZS5zbGljZSgwLCA2NCAqIDEwMjQpIDogZmlsZTtcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoc2xpY2VkRmlsZSk7XG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGRlZmVyLnJlamVjdChlKTtcbiAgICB9O1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtvcmllbnRhdGlvbjogMX07XG4gICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLnJlc3VsdCk7XG4gICAgICBpZiAodmlldy5nZXRVaW50MTYoMCwgZmFsc2UpICE9PSAweEZGRDgpIHJldHVybiBkZWZlci5yZXNvbHZlKHJlc3VsdCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IDI7XG4gICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSB2aWV3LmdldFVpbnQxNihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4RkZFMSkge1xuICAgICAgICAgIGlmICh2aWV3LmdldFVpbnQzMihvZmZzZXQgKz0gMiwgZmFsc2UpICE9PSAweDQ1Nzg2OTY2KSByZXR1cm4gZGVmZXIucmVzb2x2ZShyZXN1bHQpO1xuXG4gICAgICAgICAgdmFyIGxpdHRsZSA9IHZpZXcuZ2V0VWludDE2KG9mZnNldCArPSA2LCBmYWxzZSkgPT09IDB4NDk0OTtcbiAgICAgICAgICBvZmZzZXQgKz0gdmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCwgbGl0dGxlKTtcbiAgICAgICAgICB2YXIgdGFncyA9IHZpZXcuZ2V0VWludDE2KG9mZnNldCwgbGl0dGxlKTtcbiAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhZ3M7IGkrKylcbiAgICAgICAgICAgIGlmICh2aWV3LmdldFVpbnQxNihvZmZzZXQgKyAoaSAqIDEyKSwgbGl0dGxlKSA9PT0gMHgwMTEyKSB7XG4gICAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbiA9IHZpZXcuZ2V0VWludDE2KG9mZnNldCArIChpICogMTIpICsgOCwgbGl0dGxlKTtcbiAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID49IDIgJiYgb3JpZW50YXRpb24gPD0gOCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDE2KG9mZnNldCArIChpICogMTIpICsgOCwgMSwgbGl0dGxlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZml4ZWRBcnJheUJ1ZmZlciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgobWFya2VyICYgMHhGRjAwKSAhPT0gMHhGRjAwKSBicmVhaztcbiAgICAgICAgZWxzZSBvZmZzZXQgKz0gdmlldy5nZXRVaW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmZXIucmVzb2x2ZShyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgICB2YXIgYmluYXJ5ID0gJyc7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB2YXIgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuYnRvYShiaW5hcnkpO1xuICB9XG5cbiAgdXBsb2FkLmFwcGx5RXhpZlJvdGF0aW9uID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBpZiAoZmlsZS50eXBlLmluZGV4T2YoJ2ltYWdlL2pwZWcnKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHVwbG9hZC5lbXB0eVByb21pc2UoZmlsZSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICB1cGxvYWQucmVhZE9yaWVudGF0aW9uKGZpbGUpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdC5vcmllbnRhdGlvbiA8IDIgfHwgcmVzdWx0Lm9yaWVudGF0aW9uID4gOCkge1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVzb2x2ZShmaWxlKTtcbiAgICAgIH1cbiAgICAgIHVwbG9hZC5kYXRhVXJsKGZpbGUsIHRydWUpLnRoZW4oZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSByZXN1bHQub3JpZW50YXRpb24gPiA0ID8gaW1nLmhlaWdodCA6IGltZy53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSByZXN1bHQub3JpZW50YXRpb24gPiA0ID8gaW1nLndpZHRoIDogaW1nLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKGN0eCwgcmVzdWx0Lm9yaWVudGF0aW9uLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgdmFyIGRhdGFVcmwgPSBjYW52YXMudG9EYXRhVVJMKGZpbGUudHlwZSB8fCAnaW1hZ2UvV2ViUCcsIDAuOTM0KTtcbiAgICAgICAgICAgIGRhdGFVcmwgPSB1cGxvYWQucmVzdG9yZUV4aWYoYXJyYXlCdWZmZXJUb0Jhc2U2NChyZXN1bHQuZml4ZWRBcnJheUJ1ZmZlciksIGRhdGFVcmwpO1xuICAgICAgICAgICAgdmFyIGJsb2IgPSB1cGxvYWQuZGF0YVVybHRvQmxvYihkYXRhVXJsLCBmaWxlLm5hbWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShibG9iKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9O1xuXG4gIHVwbG9hZC5yZXN0b3JlRXhpZiA9IGZ1bmN0aW9uIChvcmlnLCByZXNpemVkKSB7XG4gICAgdmFyIEV4aWZSZXN0b3JlciA9IHt9O1xuXG4gICAgRXhpZlJlc3RvcmVyLktFWV9TVFIgPSAnQUJDREVGR0hJSktMTU5PUCcgK1xuICAgICAgJ1FSU1RVVldYWVphYmNkZWYnICtcbiAgICAgICdnaGlqa2xtbm9wcXJzdHV2JyArXG4gICAgICAnd3h5ejAxMjM0NTY3ODkrLycgK1xuICAgICAgJz0nO1xuXG4gICAgRXhpZlJlc3RvcmVyLmVuY29kZTY0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB2YXIgb3V0cHV0ID0gJycsXG4gICAgICAgIGNocjEsIGNocjIsIGNocjMgPSAnJyxcbiAgICAgICAgZW5jMSwgZW5jMiwgZW5jMywgZW5jNCA9ICcnLFxuICAgICAgICBpID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgICAgIGNocjMgPSBpbnB1dFtpKytdO1xuXG4gICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xuICAgICAgICBlbmMzID0gKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNik7XG4gICAgICAgIGVuYzQgPSBjaHIzICYgNjM7XG5cbiAgICAgICAgaWYgKGlzTmFOKGNocjIpKSB7XG4gICAgICAgICAgZW5jMyA9IGVuYzQgPSA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTihjaHIzKSkge1xuICAgICAgICAgIGVuYzQgPSA2NDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCA9IG91dHB1dCArXG4gICAgICAgICAgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMxKSArXG4gICAgICAgICAgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMyKSArXG4gICAgICAgICAgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMzKSArXG4gICAgICAgICAgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmM0KTtcbiAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gJyc7XG4gICAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSAnJztcbiAgICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpO1xuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICBFeGlmUmVzdG9yZXIucmVzdG9yZSA9IGZ1bmN0aW9uIChvcmlnRmlsZUJhc2U2NCwgcmVzaXplZEZpbGVCYXNlNjQpIHtcbiAgICAgIGlmIChvcmlnRmlsZUJhc2U2NC5tYXRjaCgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnKSkge1xuICAgICAgICBvcmlnRmlsZUJhc2U2NCA9IG9yaWdGaWxlQmFzZTY0LnJlcGxhY2UoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJywgJycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmF3SW1hZ2UgPSB0aGlzLmRlY29kZTY0KG9yaWdGaWxlQmFzZTY0KTtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2xpY2UyU2VnbWVudHMocmF3SW1hZ2UpO1xuXG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmV4aWZNYW5pcHVsYXRpb24ocmVzaXplZEZpbGVCYXNlNjQsIHNlZ21lbnRzKTtcblxuICAgICAgcmV0dXJuICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCcgKyB0aGlzLmVuY29kZTY0KGltYWdlKTtcbiAgICB9O1xuXG5cbiAgICBFeGlmUmVzdG9yZXIuZXhpZk1hbmlwdWxhdGlvbiA9IGZ1bmN0aW9uIChyZXNpemVkRmlsZUJhc2U2NCwgc2VnbWVudHMpIHtcbiAgICAgIHZhciBleGlmQXJyYXkgPSB0aGlzLmdldEV4aWZBcnJheShzZWdtZW50cyksXG4gICAgICAgIG5ld0ltYWdlQXJyYXkgPSB0aGlzLmluc2VydEV4aWYocmVzaXplZEZpbGVCYXNlNjQsIGV4aWZBcnJheSk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3SW1hZ2VBcnJheSk7XG4gICAgfTtcblxuXG4gICAgRXhpZlJlc3RvcmVyLmdldEV4aWZBcnJheSA9IGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgICAgdmFyIHNlZztcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgc2VnbWVudHMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgc2VnID0gc2VnbWVudHNbeF07XG4gICAgICAgIGlmIChzZWdbMF0gPT09IDI1NSAmIHNlZ1sxXSA9PT0gMjI1KSAvLyhmZiBlMSlcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzZWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuXG5cbiAgICBFeGlmUmVzdG9yZXIuaW5zZXJ0RXhpZiA9IGZ1bmN0aW9uIChyZXNpemVkRmlsZUJhc2U2NCwgZXhpZkFycmF5KSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gcmVzaXplZEZpbGVCYXNlNjQucmVwbGFjZSgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnLCAnJyksXG4gICAgICAgIGJ1ZiA9IHRoaXMuZGVjb2RlNjQoaW1hZ2VEYXRhKSxcbiAgICAgICAgc2VwYXJhdGVQb2ludCA9IGJ1Zi5pbmRleE9mKDI1NSwgMyksXG4gICAgICAgIG1hZSA9IGJ1Zi5zbGljZSgwLCBzZXBhcmF0ZVBvaW50KSxcbiAgICAgICAgYXRvID0gYnVmLnNsaWNlKHNlcGFyYXRlUG9pbnQpLFxuICAgICAgICBhcnJheSA9IG1hZTtcblxuICAgICAgYXJyYXkgPSBhcnJheS5jb25jYXQoZXhpZkFycmF5KTtcbiAgICAgIGFycmF5ID0gYXJyYXkuY29uY2F0KGF0byk7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfTtcblxuXG4gICAgRXhpZlJlc3RvcmVyLnNsaWNlMlNlZ21lbnRzID0gZnVuY3Rpb24gKHJhd0ltYWdlQXJyYXkpIHtcbiAgICAgIHZhciBoZWFkID0gMCxcbiAgICAgICAgc2VnbWVudHMgPSBbXTtcblxuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgaWYgKHJhd0ltYWdlQXJyYXlbaGVhZF0gPT09IDI1NSAmIHJhd0ltYWdlQXJyYXlbaGVhZCArIDFdID09PSAyMTgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmF3SW1hZ2VBcnJheVtoZWFkXSA9PT0gMjU1ICYgcmF3SW1hZ2VBcnJheVtoZWFkICsgMV0gPT09IDIxNikge1xuICAgICAgICAgIGhlYWQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gcmF3SW1hZ2VBcnJheVtoZWFkICsgMl0gKiAyNTYgKyByYXdJbWFnZUFycmF5W2hlYWQgKyAzXSxcbiAgICAgICAgICAgIGVuZFBvaW50ID0gaGVhZCArIGxlbmd0aCArIDIsXG4gICAgICAgICAgICBzZWcgPSByYXdJbWFnZUFycmF5LnNsaWNlKGhlYWQsIGVuZFBvaW50KTtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZyk7XG4gICAgICAgICAgaGVhZCA9IGVuZFBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkID4gcmF3SW1hZ2VBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgfTtcblxuXG4gICAgRXhpZlJlc3RvcmVyLmRlY29kZTY0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB2YXIgY2hyMSwgY2hyMiwgY2hyMyA9ICcnLFxuICAgICAgICBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0ID0gJycsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBidWYgPSBbXTtcblxuICAgICAgLy8gcmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBBLVosIGEteiwgMC05LCArLCAvLCBvciA9XG4gICAgICB2YXIgYmFzZTY0dGVzdCA9IC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZztcbiAgICAgIGlmIChiYXNlNjR0ZXN0LmV4ZWMoaW5wdXQpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdUaGVyZSB3ZXJlIGludmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0IHRleHQuXFxuJyArXG4gICAgICAgICAgJ1ZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGFyZSBBLVosIGEteiwgMC05LCAnICsgJywgJyAvICcsYW5kIFwiPVwiXFxuJyArXG4gICAgICAgICAgJ0V4cGVjdCBlcnJvcnMgaW4gZGVjb2RpbmcuJyk7XG4gICAgICB9XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgZW5jMSA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMiA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMyA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcblxuICAgICAgICBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICAgICAgY2hyMiA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xuICAgICAgICBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuXG4gICAgICAgIGJ1Zi5wdXNoKGNocjEpO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgIGJ1Zi5wdXNoKGNocjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmM0ICE9PSA2NCkge1xuICAgICAgICAgIGJ1Zi5wdXNoKGNocjMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gJyc7XG4gICAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSAnJztcblxuICAgICAgfSB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfTtcblxuICAgIHJldHVybiBFeGlmUmVzdG9yZXIucmVzdG9yZShvcmlnLCByZXNpemVkKTsgIC8vPD0gRVhJRlxuICB9O1xuXG4gIHJldHVybiB1cGxvYWQ7XG59XSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9uZy1maWxlLXVwbG9hZC9kaXN0L25nLWZpbGUtdXBsb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports) {

"use strict";
eval("\"use strict\";angular.module(\"com.2fdevs.videogular.plugins.controls\",[]).run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-controls\",'<div class=\"controls-container\" ng-mousemove=\"onMouseMove()\" ng-class=\"animationClass\" ng-transclude></div>')}]).directive(\"vgControls\",[\"$timeout\",\"VG_STATES\",function(a,b){return{restrict:\"E\",require:\"^videogular\",transclude:!0,templateUrl:function(a,b){return b.vgTemplate||\"vg-templates/vg-controls\"},scope:{vgAutohide:\"=?\",vgAutohideTime:\"=?\"},link:function(c,d,e,f){var g,h=2e3;c.API=f,c.onMouseMove=function(){c.vgAutohide&&c.showControls()},c.setAutohide=function(d){d&&f.currentState==b.PLAY?g=a(c.hideControls,h):(c.animationClass=\"\",a.cancel(g),c.showControls())},c.setAutohideTime=function(a){h=a},c.hideControls=function(){c.animationClass=\"hide-animation\"},c.showControls=function(){c.animationClass=\"show-animation\",a.cancel(g),c.vgAutohide&&f.currentState==b.PLAY&&(g=a(c.hideControls,h))},f.isConfig?c.$watch(\"API.config\",function(){if(c.API.config){var a=c.API.config.plugins.controls.autohide||!1,b=c.API.config.plugins.controls.autohideTime||2e3;c.vgAutohide=a,c.vgAutohideTime=b,c.setAutohideTime(b),c.setAutohide(a)}}):(void 0!=c.vgAutohide&&c.$watch(\"vgAutohide\",c.setAutohide),void 0!=c.vgAutohideTime&&c.$watch(\"vgAutohideTime\",c.setAutohideTime)),c.$watch(function(){return f.currentState},function(a,b){c.vgAutohide&&c.showControls()})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-fullscreen-button\",'<button class=\"iconButton\" ng-click=\"onClickFullScreen()\" ng-class=\"fullscreenIcon\" aria-label=\"Toggle full screen\" type=\"button\"> </button>')}]).directive(\"vgFullscreenButton\",[function(){return{restrict:\"E\",require:\"^videogular\",scope:{},templateUrl:function(a,b){return b.vgTemplate||\"vg-templates/vg-fullscreen-button\"},link:function(a,b,c,d){a.onChangeFullScreen=function(b){a.fullscreenIcon={enter:!b,exit:b}},a.onClickFullScreen=function(){d.toggleFullScreen()},a.fullscreenIcon={enter:!0},a.$watch(function(){return d.isFullScreen},function(b,c){b!=c&&a.onChangeFullScreen(b)})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-play-pause-button\",'<button class=\"iconButton\" ng-click=\"onClickPlayPause()\" ng-class=\"playPauseIcon\" aria-label=\"Play/Pause\" type=\"button\"></button>')}]).directive(\"vgPlayPauseButton\",[\"VG_STATES\",function(a){return{restrict:\"E\",require:\"^videogular\",scope:{},templateUrl:function(a,b){return b.vgTemplate||\"vg-templates/vg-play-pause-button\"},link:function(b,c,d,e){b.setState=function(c){switch(c){case a.PLAY:b.playPauseIcon={pause:!0};break;case a.PAUSE:b.playPauseIcon={play:!0};break;case a.STOP:b.playPauseIcon={play:!0}}},b.onClickPlayPause=function(){e.playPause()},b.playPauseIcon={play:!0},b.$watch(function(){return e.currentState},function(a,c){b.setState(a)})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-playback-button\",'<button class=\"playbackValue iconButton\" ng-click=\"onClickPlayback()\">{{playback}}x</button>')}]).directive(\"vgPlaybackButton\",[function(){return{restrict:\"E\",require:\"^videogular\",templateUrl:function(a,b){return b.vgTemplate||\"vg-templates/vg-playback-button\"},scope:{vgSpeeds:\"=?\"},link:function(a,b,c,d){a.playback=\"1\",a.setPlayback=function(b){a.playback=b,d.setPlayback(parseFloat(b))},a.onClickPlayback=function(){var b=a.vgSpeeds||[\"0.5\",\"1\",\"1.5\",\"2\"],c=b.indexOf(a.playback.toString())+1;c>=b.length?a.playback=b[0]:a.playback=b[c],a.setPlayback(a.playback)},a.$watch(function(){return d.playback},function(b,c){b!=c&&a.setPlayback(b)})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").directive(\"vgScrubBarBuffer\",[function(){return{restrict:\"E\",require:\"^videogular\",link:function(a,b,c,d){var e=0;a.onUpdateBuffer=function(a){\"number\"==typeof a&&d.totalTime?(e=100*(a/d.totalTime),b.css(\"width\",e+\"%\")):b.css(\"width\",0)},a.$watch(function(){return d.bufferEnd},function(b,c){a.onUpdateBuffer(b)})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-scrub-bar-cue-points\",'<div class=\"cue-point-timeline\"><div ng-repeat=\"cuePoint in vgCuePoints\" class=\"cue-point\" ng-style=\"cuePoint.$$style\"></div></div>')}]).directive(\"vgScrubBarCuePoints\",[function(){return{restrict:\"E\",require:\"^videogular\",templateUrl:function(a,b){return b.vgTemplate||\"vg-templates/vg-scrub-bar-cue-points\"},scope:{vgCuePoints:\"=\"},link:function(a,b,c,d){a.onPlayerReady=function(){a.updateCuePoints(a.vgCuePoints)},a.updateCuePoints=function(a){var c;if(a){c=parseInt(b[0].clientWidth);for(var e=0,f=a.length;f>e;e++){var g=a[e].timeLapse.end>=0?a[e].timeLapse.end:a[e].timeLapse.start+1,h=1e3*(g-a[e].timeLapse.start),i=100*a[e].timeLapse.start/Math.round(d.totalTime/1e3)+\"%\",j=0;\"number\"==typeof h&&d.totalTime&&(j=100*h/d.totalTime+\"%\"),a[e].$$style={width:j,left:i}}}},a.$watch(\"vgCuePoints\",a.updateCuePoints),a.$watch(function(){return d.totalTime},function(b,c){b>0&&a.onPlayerReady()})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").directive(\"vgScrubBarCurrentTime\",[function(){return{restrict:\"E\",require:\"^videogular\",link:function(a,b,c,d){var e=0;a.onUpdateTime=function(a){\"number\"==typeof a&&d.totalTime?(e=100*(a/d.totalTime),b.css(\"width\",e+\"%\")):b.css(\"width\",0)},a.$watch(function(){return d.currentTime},function(b,c){a.onUpdateTime(b)})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-scrub-bar-thumbnails\",'<div class=\"vg-thumbnails\" ng-show=\"thumbnails\" ng-style=\"thumbnailContainer\"><div class=\"image-thumbnail\" ng-style=\"thumbnails\"></div></div><div class=\"background\"></div>')}]).directive(\"vgScrubBarThumbnails\",[\"VG_UTILS\",function(a){return{restrict:\"E\",require:\"^videogular\",templateUrl:function(a,b){return b.vgTemplate||\"vg-templates/vg-scrub-bar-thumbnails\"},scope:{vgThumbnails:\"=\"},link:function(b,c,d,e){var f=0,g=0,h=c[0].querySelector(\".background\"),i=\"string\"==typeof b.vgThumbnails;b.thumbnails=!1,b.thumbnailContainer={},b.getOffset=function(a){for(var b=a.target,c=0;b&&!isNaN(b.offsetLeft);)c+=b.offsetLeft-b.scrollLeft,b=b.offsetParent;return a.clientX-c},b.onLoadThumbnails=function(a){f=a.currentTarget.naturalWidth,g=f/100},b.onLoadThumbnail=function(a){g=a.currentTarget.naturalWidth},b.updateThumbnails=function(a){var c=Math.round(100*a/(e.totalTime/1e3)),d=h.scrollWidth*c/100-g/2;if(i){var j=Math.round(f*c/100);b.thumbnailContainer={width:g+\"px\",left:d+\"px\"},b.thumbnails={\"background-image\":'url(\"'+b.vgThumbnails+'\")',\"background-position\":-j+\"px 0px\"}}else{var k=e.totalTime/h.scrollWidth/1e3,l={start:Math.floor(a-k/2),end:Math.ceil(a)};if(l.start<0&&(l.start=0),l.end>e.totalTime&&(l.end=e.totalTime),b.thumbnailContainer={left:d+\"px\"},b.thumbnails={\"background-image\":\"none\"},b.vgThumbnails)for(var m=0,n=b.vgThumbnails.length;n>m;m++){var o=b.vgThumbnails[m];if(o.timeLapse.end>=0){if(l.start>=o.timeLapse.start&&(l.end<=o.timeLapse.end||l.end<=o.timeLapse.start)){b.thumbnails={\"background-image\":'url(\"'+o.params.thumbnail+'\")'};break}}else if(o.timeLapse.start>=l.start&&o.timeLapse.start<=l.end){b.thumbnails={\"background-image\":'url(\"'+o.params.thumbnail+'\")'};break}}}},b.onMouseMove=function(a){var c=Math.round(a.offsetX*e.mediaElement[0].duration/h.scrollWidth);b.updateThumbnails(c),b.$digest()},b.onTouchMove=function(a){var c=a.touches,d=b.getOffset(c[0]),f=Math.round(d*e.mediaElement[0].duration/h.scrollWidth);b.updateThumbnails(f),b.$digest()},b.onMouseLeave=function(a){b.thumbnails=!1,b.$digest()},b.onTouchLeave=function(a){b.thumbnails=!1,b.$digest()},b.onDestroy=function(){c.unbind(\"touchmove\",b.onTouchMove),c.unbind(\"touchleave\",b.onTouchLeave),c.unbind(\"touchend\",b.onTouchLeave),c.unbind(\"mousemove\",b.onMouseMove),c.unbind(\"mouseleave\",b.onMouseLeave)};var j;i?(j=new Image,j.onload=b.onLoadThumbnails.bind(b),j.src=b.vgThumbnails):(j=new Image,j.onload=b.onLoadThumbnail.bind(b),j.src=b.vgThumbnails[0].params.thumbnail),a.isMobileDevice()?(c.bind(\"touchmove\",b.onTouchMove),c.bind(\"touchleave\",b.onTouchLeave),c.bind(\"touchend\",b.onTouchLeave)):(c.bind(\"mousemove\",b.onMouseMove),c.bind(\"mouseleave\",b.onMouseLeave)),b.$on(\"destroy\",b.onDestroy.bind(b))}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-scrub-bar\",'<div role=\"slider\" aria-valuemax=\"{{ariaTime(API.totalTime)}}\" aria-valuenow=\"{{ariaTime(API.currentTime)}}\" aria-valuemin=\"0\" aria-label=\"Time scrub bar\" tabindex=\"0\" ng-keydown=\"onScrubBarKeyDown($event)\"></div><div class=\"container\" ng-transclude></div>')}]).directive(\"vgScrubBar\",[\"VG_STATES\",\"VG_UTILS\",function(a,b){return{restrict:\"E\",require:\"^videogular\",transclude:!0,templateUrl:function(a,b){return b.vgTemplate||\"vg-templates/vg-scrub-bar\"},scope:{vgThumbnails:\"=\"},link:function(c,d,e,f){var g=!1,h=!1,i=!1,j=37,k=39,l=5,m=0,n=0,o=d[0].querySelector(\"div[role=slider]\");if(c.thumbnails=!1,c.thumbnailContainer={},c.API=f,c.onLoadThumbnails=function(a){m=a.path[0].naturalWidth,n=m/100},c.ariaTime=function(a){return Math.round(a/1e3)},c.getOffset=function(a){for(var b=a.target,c=0;b&&!isNaN(b.offsetLeft);)c+=b.offsetLeft-b.scrollLeft,b=b.offsetParent;return a.clientX-c},c.onScrubBarTouchStart=function(a){var b=a.originalEvent||a,d=b.touches,e=c.getOffset(d[0]);g=!0,h&&(i=!0),f.pause(),f.seekTime(e*f.mediaElement[0].duration/o.scrollWidth),c.$digest()},c.onScrubBarTouchEnd=function(a){a.originalEvent||a;i&&(i=!1,f.play()),g=!1,c.$digest()},c.onScrubBarTouchMove=function(a){var b=a.originalEvent||a,d=b.touches,e=c.getOffset(d[0]);if(c.vgThumbnails&&c.vgThumbnails.length){var h=Math.round(e*f.mediaElement[0].duration/o.scrollWidth),i=Math.round(100*h/(f.totalTime/1e3));c.updateThumbnails(i)}g&&f.seekTime(e*f.mediaElement[0].duration/o.scrollWidth),c.$digest()},c.onScrubBarTouchLeave=function(a){g=!1,c.thumbnails=!1,c.$digest()},c.onScrubBarMouseDown=function(a){a=b.fixEventOffset(a),g=!0,h&&(i=!0),f.pause(),f.seekTime(a.offsetX*f.mediaElement[0].duration/o.scrollWidth),c.$digest()},c.onScrubBarMouseUp=function(a){i&&(i=!1,f.play()),g=!1,c.$digest()},c.onScrubBarMouseMove=function(a){if(c.vgThumbnails&&c.vgThumbnails.length){var d=Math.round(a.offsetX*f.mediaElement[0].duration/o.scrollWidth),e=Math.round(100*d/(f.totalTime/1e3));c.updateThumbnails(e)}g&&(a=b.fixEventOffset(a),f.seekTime(a.offsetX*f.mediaElement[0].duration/o.scrollWidth)),c.$digest()},c.onScrubBarMouseLeave=function(a){g=!1,c.thumbnails=!1,c.$digest()},c.onScrubBarKeyDown=function(a){var b=f.currentTime/f.totalTime*100;a.which===j||a.keyCode===j?(f.seekTime(b-l,!0),a.preventDefault()):(a.which===k||a.keyCode===k)&&(f.seekTime(b+l,!0),a.preventDefault())},c.updateThumbnails=function(a){var b=Math.round(m*a/100),d=o.scrollWidth*a/100-n/2;c.thumbnailContainer={width:n+\"px\",left:d+\"px\"},c.thumbnails={\"background-image\":'url(\"'+c.vgThumbnails+'\")',\"background-position\":-b+\"px 0px\"}},c.setState=function(b){if(!g)switch(b){case a.PLAY:h=!0;break;case a.PAUSE:h=!1;break;case a.STOP:h=!1}},c.onDestroy=function(){d.unbind(\"touchstart\",c.onScrubBarTouchStart),d.unbind(\"touchend\",c.onScrubBarTouchEnd),d.unbind(\"touchmove\",c.onScrubBarTouchMove),d.unbind(\"touchleave\",c.onScrubBarTouchLeave),d.unbind(\"mousedown\",c.onScrubBarMouseDown),d.unbind(\"mouseup\",c.onScrubBarMouseUp),d.unbind(\"mousemove\",c.onScrubBarMouseMove),d.unbind(\"mouseleave\",c.onScrubBarMouseLeave)},c.$watch(function(){return f.currentState},function(a,b){a!=b&&c.setState(a)}),c.vgThumbnails){var p=new Image;p.onload=c.onLoadThumbnails.bind(c),p.src=c.vgThumbnails}b.isMobileDevice()?(d.bind(\"touchstart\",c.onScrubBarTouchStart),d.bind(\"touchend\",c.onScrubBarTouchEnd),d.bind(\"touchmove\",c.onScrubBarTouchMove),d.bind(\"touchleave\",c.onScrubBarTouchLeave)):(d.bind(\"mousedown\",c.onScrubBarMouseDown),d.bind(\"mouseup\",c.onScrubBarMouseUp),d.bind(\"mousemove\",c.onScrubBarMouseMove),d.bind(\"mouseleave\",c.onScrubBarMouseLeave)),c.$on(\"destroy\",c.onDestroy.bind(c))}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").directive(\"vgTimeDisplay\",[function(){return{require:\"^videogular\",restrict:\"E\",link:function(a,b,c,d){a.currentTime=d.currentTime,a.timeLeft=d.timeLeft,a.totalTime=d.totalTime,a.isLive=d.isLive,a.$watch(function(){return d.currentTime},function(b,c){a.currentTime=b}),a.$watch(function(){return d.timeLeft},function(b,c){a.timeLeft=b}),a.$watch(function(){return d.totalTime},function(b,c){a.totalTime=b}),a.$watch(function(){return d.isLive},function(b,c){a.isLive=b})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-mute-button\",'<button type=\"button\" class=\"iconButton\" ng-class=\"muteIcon\" ng-click=\"onClickMute()\" ng-focus=\"onMuteButtonFocus()\" ng-blur=\"onMuteButtonLoseFocus()\" ng-mouseleave=\"onMuteButtonLeave()\" ng-keydown=\"onMuteButtonKeyDown($event)\" aria-label=\"Mute\"></button>')}]).directive(\"vgMuteButton\",[function(){return{restrict:\"E\",require:\"^videogular\",templateUrl:function(a,b){return b.vgTemplate||\"vg-templates/vg-mute-button\"},link:function(a,b,c,d){var e=!1,f=38,g=40,h=.05;a.onClickMute=function(){e?a.currentVolume=a.defaultVolume:(a.currentVolume=0,a.muteIcon={mute:!0}),e=!e,d.setVolume(a.currentVolume)},a.onMuteButtonFocus=function(){a.volumeVisibility=\"visible\"},a.onMuteButtonLoseFocus=function(){a.volumeVisibility=\"hidden\"},a.onMuteButtonLeave=function(){document.activeElement.blur()},a.onMuteButtonKeyDown=function(a){var b,c=null!=d.volume?d.volume:1;a.which===f||a.keyCode===f?(b=c+h,b>1&&(b=1),d.setVolume(b),a.preventDefault()):(a.which===g||a.keyCode===g)&&(b=c-h,0>b&&(b=0),d.setVolume(b),a.preventDefault())},a.onSetVolume=function(b){a.currentVolume=b,e=0===a.currentVolume,e?b>0&&(a.defaultVolume=b):a.defaultVolume=b;var c=Math.round(100*b);0==c?a.muteIcon={mute:!0}:c>0&&25>c?a.muteIcon={level0:!0}:c>=25&&50>c?a.muteIcon={level1:!0}:c>=50&&75>c?a.muteIcon={level2:!0}:c>=75&&(a.muteIcon={level3:!0})},a.defaultVolume=1,a.currentVolume=a.defaultVolume,a.muteIcon={level3:!0},a.onSetVolume(d.volume),a.$watch(function(){return d.volume},function(b,c){b!=c&&a.onSetVolume(b)})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-volume-bar\",'<div class=\"verticalVolumeBar\">              <div class=\"volumeBackground\" ng-click=\"onClickVolume($event)\" ng-mousedown=\"onMouseDownVolume()\" ng-mouseup=\"onMouseUpVolume()\" ng-mousemove=\"onMouseMoveVolume($event)\" ng-mouseleave=\"onMouseLeaveVolume()\">                <div class=\"volumeValue\"></div>                <div class=\"volumeClickArea\"></div>              </div>            </div>')}]).directive(\"vgVolumeBar\",[\"VG_UTILS\",function(a){return{restrict:\"E\",require:\"^videogular\",templateUrl:function(a,b){return b.vgTemplate||\"vg-templates/vg-volume-bar\"},link:function(b,c,d,e){var f=!1,g=angular.element(c[0].getElementsByClassName(\"volumeBackground\")),h=angular.element(c[0].getElementsByClassName(\"volumeValue\"));b.onClickVolume=function(b){b=a.fixEventOffset(b);var c=parseInt(g.prop(\"offsetHeight\")),d=100*b.offsetY/c,f=1-d/100;e.setVolume(f)},b.onMouseDownVolume=function(){f=!0},b.onMouseUpVolume=function(){f=!1},b.onMouseLeaveVolume=function(){f=!1},b.onMouseMoveVolume=function(b){if(f){b=a.fixEventOffset(b);var c=parseInt(g.prop(\"offsetHeight\")),d=100*b.offsetY/c,h=1-d/100;e.setVolume(h)}},b.updateVolumeView=function(a){a=100*a,h.css(\"height\",a+\"%\"),h.css(\"top\",100-a+\"%\")},b.onChangeVisibility=function(a){c.css(\"visibility\",a)},c.css(\"visibility\",b.volumeVisibility),b.$watch(\"volumeVisibility\",b.onChangeVisibility),b.updateVolumeView(e.volume),b.$watch(function(){return e.volume},function(a,c){a!=c&&b.updateVolumeView(a)})}}}]),angular.module(\"com.2fdevs.videogular.plugins.controls\").directive(\"vgVolume\",[\"VG_UTILS\",function(a){return{restrict:\"E\",link:function(b,c,d){b.onMouseOverVolume=function(){b.$evalAsync(function(){b.volumeVisibility=\"visible\"})},b.onMouseLeaveVolume=function(){b.$evalAsync(function(){b.volumeVisibility=\"hidden\"})},b.onDestroy=function(){c.unbind(\"mouseover\",b.onScrubBarTouchStart),c.unbind(\"mouseleave\",b.onScrubBarTouchEnd)},a.isMobileDevice()?c.css(\"display\",\"none\"):(b.volumeVisibility=\"hidden\",c.bind(\"mouseover\",b.onMouseOverVolume),c.bind(\"mouseleave\",b.onMouseLeaveVolume)),b.$on(\"destroy\",b.onDestroy.bind(b))}}}]);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ZpZGVvZ3VsYXItY29udHJvbHMvdmctY29udHJvbHMubWluLmpzPzc5YWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7YW5ndWxhci5tb2R1bGUoXCJjb20uMmZkZXZzLnZpZGVvZ3VsYXIucGx1Z2lucy5jb250cm9sc1wiLFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIixmdW5jdGlvbihhKXthLnB1dChcInZnLXRlbXBsYXRlcy92Zy1jb250cm9sc1wiLCc8ZGl2IGNsYXNzPVwiY29udHJvbHMtY29udGFpbmVyXCIgbmctbW91c2Vtb3ZlPVwib25Nb3VzZU1vdmUoKVwiIG5nLWNsYXNzPVwiYW5pbWF0aW9uQ2xhc3NcIiBuZy10cmFuc2NsdWRlPjwvZGl2PicpfV0pLmRpcmVjdGl2ZShcInZnQ29udHJvbHNcIixbXCIkdGltZW91dFwiLFwiVkdfU1RBVEVTXCIsZnVuY3Rpb24oYSxiKXtyZXR1cm57cmVzdHJpY3Q6XCJFXCIscmVxdWlyZTpcIl52aWRlb2d1bGFyXCIsdHJhbnNjbHVkZTohMCx0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnZnVGVtcGxhdGV8fFwidmctdGVtcGxhdGVzL3ZnLWNvbnRyb2xzXCJ9LHNjb3BlOnt2Z0F1dG9oaWRlOlwiPT9cIix2Z0F1dG9oaWRlVGltZTpcIj0/XCJ9LGxpbms6ZnVuY3Rpb24oYyxkLGUsZil7dmFyIGcsaD0yZTM7Yy5BUEk9ZixjLm9uTW91c2VNb3ZlPWZ1bmN0aW9uKCl7Yy52Z0F1dG9oaWRlJiZjLnNob3dDb250cm9scygpfSxjLnNldEF1dG9oaWRlPWZ1bmN0aW9uKGQpe2QmJmYuY3VycmVudFN0YXRlPT1iLlBMQVk/Zz1hKGMuaGlkZUNvbnRyb2xzLGgpOihjLmFuaW1hdGlvbkNsYXNzPVwiXCIsYS5jYW5jZWwoZyksYy5zaG93Q29udHJvbHMoKSl9LGMuc2V0QXV0b2hpZGVUaW1lPWZ1bmN0aW9uKGEpe2g9YX0sYy5oaWRlQ29udHJvbHM9ZnVuY3Rpb24oKXtjLmFuaW1hdGlvbkNsYXNzPVwiaGlkZS1hbmltYXRpb25cIn0sYy5zaG93Q29udHJvbHM9ZnVuY3Rpb24oKXtjLmFuaW1hdGlvbkNsYXNzPVwic2hvdy1hbmltYXRpb25cIixhLmNhbmNlbChnKSxjLnZnQXV0b2hpZGUmJmYuY3VycmVudFN0YXRlPT1iLlBMQVkmJihnPWEoYy5oaWRlQ29udHJvbHMsaCkpfSxmLmlzQ29uZmlnP2MuJHdhdGNoKFwiQVBJLmNvbmZpZ1wiLGZ1bmN0aW9uKCl7aWYoYy5BUEkuY29uZmlnKXt2YXIgYT1jLkFQSS5jb25maWcucGx1Z2lucy5jb250cm9scy5hdXRvaGlkZXx8ITEsYj1jLkFQSS5jb25maWcucGx1Z2lucy5jb250cm9scy5hdXRvaGlkZVRpbWV8fDJlMztjLnZnQXV0b2hpZGU9YSxjLnZnQXV0b2hpZGVUaW1lPWIsYy5zZXRBdXRvaGlkZVRpbWUoYiksYy5zZXRBdXRvaGlkZShhKX19KToodm9pZCAwIT1jLnZnQXV0b2hpZGUmJmMuJHdhdGNoKFwidmdBdXRvaGlkZVwiLGMuc2V0QXV0b2hpZGUpLHZvaWQgMCE9Yy52Z0F1dG9oaWRlVGltZSYmYy4kd2F0Y2goXCJ2Z0F1dG9oaWRlVGltZVwiLGMuc2V0QXV0b2hpZGVUaW1lKSksYy4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gZi5jdXJyZW50U3RhdGV9LGZ1bmN0aW9uKGEsYil7Yy52Z0F1dG9oaWRlJiZjLnNob3dDb250cm9scygpfSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhci5wbHVnaW5zLmNvbnRyb2xzXCIpLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLGZ1bmN0aW9uKGEpe2EucHV0KFwidmctdGVtcGxhdGVzL3ZnLWZ1bGxzY3JlZW4tYnV0dG9uXCIsJzxidXR0b24gY2xhc3M9XCJpY29uQnV0dG9uXCIgbmctY2xpY2s9XCJvbkNsaWNrRnVsbFNjcmVlbigpXCIgbmctY2xhc3M9XCJmdWxsc2NyZWVuSWNvblwiIGFyaWEtbGFiZWw9XCJUb2dnbGUgZnVsbCBzY3JlZW5cIiB0eXBlPVwiYnV0dG9uXCI+IDwvYnV0dG9uPicpfV0pLmRpcmVjdGl2ZShcInZnRnVsbHNjcmVlbkJ1dHRvblwiLFtmdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcIkVcIixyZXF1aXJlOlwiXnZpZGVvZ3VsYXJcIixzY29wZTp7fSx0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnZnVGVtcGxhdGV8fFwidmctdGVtcGxhdGVzL3ZnLWZ1bGxzY3JlZW4tYnV0dG9uXCJ9LGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7YS5vbkNoYW5nZUZ1bGxTY3JlZW49ZnVuY3Rpb24oYil7YS5mdWxsc2NyZWVuSWNvbj17ZW50ZXI6IWIsZXhpdDpifX0sYS5vbkNsaWNrRnVsbFNjcmVlbj1mdW5jdGlvbigpe2QudG9nZ2xlRnVsbFNjcmVlbigpfSxhLmZ1bGxzY3JlZW5JY29uPXtlbnRlcjohMH0sYS4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gZC5pc0Z1bGxTY3JlZW59LGZ1bmN0aW9uKGIsYyl7YiE9YyYmYS5vbkNoYW5nZUZ1bGxTY3JlZW4oYil9KX19fV0pLGFuZ3VsYXIubW9kdWxlKFwiY29tLjJmZGV2cy52aWRlb2d1bGFyLnBsdWdpbnMuY29udHJvbHNcIikucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsZnVuY3Rpb24oYSl7YS5wdXQoXCJ2Zy10ZW1wbGF0ZXMvdmctcGxheS1wYXVzZS1idXR0b25cIiwnPGJ1dHRvbiBjbGFzcz1cImljb25CdXR0b25cIiBuZy1jbGljaz1cIm9uQ2xpY2tQbGF5UGF1c2UoKVwiIG5nLWNsYXNzPVwicGxheVBhdXNlSWNvblwiIGFyaWEtbGFiZWw9XCJQbGF5L1BhdXNlXCIgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPicpfV0pLmRpcmVjdGl2ZShcInZnUGxheVBhdXNlQnV0dG9uXCIsW1wiVkdfU1RBVEVTXCIsZnVuY3Rpb24oYSl7cmV0dXJue3Jlc3RyaWN0OlwiRVwiLHJlcXVpcmU6XCJedmlkZW9ndWxhclwiLHNjb3BlOnt9LHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudmdUZW1wbGF0ZXx8XCJ2Zy10ZW1wbGF0ZXMvdmctcGxheS1wYXVzZS1idXR0b25cIn0sbGluazpmdW5jdGlvbihiLGMsZCxlKXtiLnNldFN0YXRlPWZ1bmN0aW9uKGMpe3N3aXRjaChjKXtjYXNlIGEuUExBWTpiLnBsYXlQYXVzZUljb249e3BhdXNlOiEwfTticmVhaztjYXNlIGEuUEFVU0U6Yi5wbGF5UGF1c2VJY29uPXtwbGF5OiEwfTticmVhaztjYXNlIGEuU1RPUDpiLnBsYXlQYXVzZUljb249e3BsYXk6ITB9fX0sYi5vbkNsaWNrUGxheVBhdXNlPWZ1bmN0aW9uKCl7ZS5wbGF5UGF1c2UoKX0sYi5wbGF5UGF1c2VJY29uPXtwbGF5OiEwfSxiLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBlLmN1cnJlbnRTdGF0ZX0sZnVuY3Rpb24oYSxjKXtiLnNldFN0YXRlKGEpfSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhci5wbHVnaW5zLmNvbnRyb2xzXCIpLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLGZ1bmN0aW9uKGEpe2EucHV0KFwidmctdGVtcGxhdGVzL3ZnLXBsYXliYWNrLWJ1dHRvblwiLCc8YnV0dG9uIGNsYXNzPVwicGxheWJhY2tWYWx1ZSBpY29uQnV0dG9uXCIgbmctY2xpY2s9XCJvbkNsaWNrUGxheWJhY2soKVwiPnt7cGxheWJhY2t9fXg8L2J1dHRvbj4nKX1dKS5kaXJlY3RpdmUoXCJ2Z1BsYXliYWNrQnV0dG9uXCIsW2Z1bmN0aW9uKCl7cmV0dXJue3Jlc3RyaWN0OlwiRVwiLHJlcXVpcmU6XCJedmlkZW9ndWxhclwiLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudmdUZW1wbGF0ZXx8XCJ2Zy10ZW1wbGF0ZXMvdmctcGxheWJhY2stYnV0dG9uXCJ9LHNjb3BlOnt2Z1NwZWVkczpcIj0/XCJ9LGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7YS5wbGF5YmFjaz1cIjFcIixhLnNldFBsYXliYWNrPWZ1bmN0aW9uKGIpe2EucGxheWJhY2s9YixkLnNldFBsYXliYWNrKHBhcnNlRmxvYXQoYikpfSxhLm9uQ2xpY2tQbGF5YmFjaz1mdW5jdGlvbigpe3ZhciBiPWEudmdTcGVlZHN8fFtcIjAuNVwiLFwiMVwiLFwiMS41XCIsXCIyXCJdLGM9Yi5pbmRleE9mKGEucGxheWJhY2sudG9TdHJpbmcoKSkrMTtjPj1iLmxlbmd0aD9hLnBsYXliYWNrPWJbMF06YS5wbGF5YmFjaz1iW2NdLGEuc2V0UGxheWJhY2soYS5wbGF5YmFjayl9LGEuJHdhdGNoKGZ1bmN0aW9uKCl7cmV0dXJuIGQucGxheWJhY2t9LGZ1bmN0aW9uKGIsYyl7YiE9YyYmYS5zZXRQbGF5YmFjayhiKX0pfX19XSksYW5ndWxhci5tb2R1bGUoXCJjb20uMmZkZXZzLnZpZGVvZ3VsYXIucGx1Z2lucy5jb250cm9sc1wiKS5kaXJlY3RpdmUoXCJ2Z1NjcnViQmFyQnVmZmVyXCIsW2Z1bmN0aW9uKCl7cmV0dXJue3Jlc3RyaWN0OlwiRVwiLHJlcXVpcmU6XCJedmlkZW9ndWxhclwiLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9MDthLm9uVXBkYXRlQnVmZmVyPWZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PXR5cGVvZiBhJiZkLnRvdGFsVGltZT8oZT0xMDAqKGEvZC50b3RhbFRpbWUpLGIuY3NzKFwid2lkdGhcIixlK1wiJVwiKSk6Yi5jc3MoXCJ3aWR0aFwiLDApfSxhLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBkLmJ1ZmZlckVuZH0sZnVuY3Rpb24oYixjKXthLm9uVXBkYXRlQnVmZmVyKGIpfSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhci5wbHVnaW5zLmNvbnRyb2xzXCIpLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLGZ1bmN0aW9uKGEpe2EucHV0KFwidmctdGVtcGxhdGVzL3ZnLXNjcnViLWJhci1jdWUtcG9pbnRzXCIsJzxkaXYgY2xhc3M9XCJjdWUtcG9pbnQtdGltZWxpbmVcIj48ZGl2IG5nLXJlcGVhdD1cImN1ZVBvaW50IGluIHZnQ3VlUG9pbnRzXCIgY2xhc3M9XCJjdWUtcG9pbnRcIiBuZy1zdHlsZT1cImN1ZVBvaW50LiQkc3R5bGVcIj48L2Rpdj48L2Rpdj4nKX1dKS5kaXJlY3RpdmUoXCJ2Z1NjcnViQmFyQ3VlUG9pbnRzXCIsW2Z1bmN0aW9uKCl7cmV0dXJue3Jlc3RyaWN0OlwiRVwiLHJlcXVpcmU6XCJedmlkZW9ndWxhclwiLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudmdUZW1wbGF0ZXx8XCJ2Zy10ZW1wbGF0ZXMvdmctc2NydWItYmFyLWN1ZS1wb2ludHNcIn0sc2NvcGU6e3ZnQ3VlUG9pbnRzOlwiPVwifSxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2Eub25QbGF5ZXJSZWFkeT1mdW5jdGlvbigpe2EudXBkYXRlQ3VlUG9pbnRzKGEudmdDdWVQb2ludHMpfSxhLnVwZGF0ZUN1ZVBvaW50cz1mdW5jdGlvbihhKXt2YXIgYztpZihhKXtjPXBhcnNlSW50KGJbMF0uY2xpZW50V2lkdGgpO2Zvcih2YXIgZT0wLGY9YS5sZW5ndGg7Zj5lO2UrKyl7dmFyIGc9YVtlXS50aW1lTGFwc2UuZW5kPj0wP2FbZV0udGltZUxhcHNlLmVuZDphW2VdLnRpbWVMYXBzZS5zdGFydCsxLGg9MWUzKihnLWFbZV0udGltZUxhcHNlLnN0YXJ0KSxpPTEwMCphW2VdLnRpbWVMYXBzZS5zdGFydC9NYXRoLnJvdW5kKGQudG90YWxUaW1lLzFlMykrXCIlXCIsaj0wO1wibnVtYmVyXCI9PXR5cGVvZiBoJiZkLnRvdGFsVGltZSYmKGo9MTAwKmgvZC50b3RhbFRpbWUrXCIlXCIpLGFbZV0uJCRzdHlsZT17d2lkdGg6aixsZWZ0Oml9fX19LGEuJHdhdGNoKFwidmdDdWVQb2ludHNcIixhLnVwZGF0ZUN1ZVBvaW50cyksYS4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gZC50b3RhbFRpbWV9LGZ1bmN0aW9uKGIsYyl7Yj4wJiZhLm9uUGxheWVyUmVhZHkoKX0pfX19XSksYW5ndWxhci5tb2R1bGUoXCJjb20uMmZkZXZzLnZpZGVvZ3VsYXIucGx1Z2lucy5jb250cm9sc1wiKS5kaXJlY3RpdmUoXCJ2Z1NjcnViQmFyQ3VycmVudFRpbWVcIixbZnVuY3Rpb24oKXtyZXR1cm57cmVzdHJpY3Q6XCJFXCIscmVxdWlyZTpcIl52aWRlb2d1bGFyXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT0wO2Eub25VcGRhdGVUaW1lPWZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PXR5cGVvZiBhJiZkLnRvdGFsVGltZT8oZT0xMDAqKGEvZC50b3RhbFRpbWUpLGIuY3NzKFwid2lkdGhcIixlK1wiJVwiKSk6Yi5jc3MoXCJ3aWR0aFwiLDApfSxhLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBkLmN1cnJlbnRUaW1lfSxmdW5jdGlvbihiLGMpe2Eub25VcGRhdGVUaW1lKGIpfSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhci5wbHVnaW5zLmNvbnRyb2xzXCIpLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLGZ1bmN0aW9uKGEpe2EucHV0KFwidmctdGVtcGxhdGVzL3ZnLXNjcnViLWJhci10aHVtYm5haWxzXCIsJzxkaXYgY2xhc3M9XCJ2Zy10aHVtYm5haWxzXCIgbmctc2hvdz1cInRodW1ibmFpbHNcIiBuZy1zdHlsZT1cInRodW1ibmFpbENvbnRhaW5lclwiPjxkaXYgY2xhc3M9XCJpbWFnZS10aHVtYm5haWxcIiBuZy1zdHlsZT1cInRodW1ibmFpbHNcIj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwiYmFja2dyb3VuZFwiPjwvZGl2PicpfV0pLmRpcmVjdGl2ZShcInZnU2NydWJCYXJUaHVtYm5haWxzXCIsW1wiVkdfVVRJTFNcIixmdW5jdGlvbihhKXtyZXR1cm57cmVzdHJpY3Q6XCJFXCIscmVxdWlyZTpcIl52aWRlb2d1bGFyXCIsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi52Z1RlbXBsYXRlfHxcInZnLXRlbXBsYXRlcy92Zy1zY3J1Yi1iYXItdGh1bWJuYWlsc1wifSxzY29wZTp7dmdUaHVtYm5haWxzOlwiPVwifSxsaW5rOmZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPTAsZz0wLGg9Y1swXS5xdWVyeVNlbGVjdG9yKFwiLmJhY2tncm91bmRcIiksaT1cInN0cmluZ1wiPT10eXBlb2YgYi52Z1RodW1ibmFpbHM7Yi50aHVtYm5haWxzPSExLGIudGh1bWJuYWlsQ29udGFpbmVyPXt9LGIuZ2V0T2Zmc2V0PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLnRhcmdldCxjPTA7YiYmIWlzTmFOKGIub2Zmc2V0TGVmdCk7KWMrPWIub2Zmc2V0TGVmdC1iLnNjcm9sbExlZnQsYj1iLm9mZnNldFBhcmVudDtyZXR1cm4gYS5jbGllbnRYLWN9LGIub25Mb2FkVGh1bWJuYWlscz1mdW5jdGlvbihhKXtmPWEuY3VycmVudFRhcmdldC5uYXR1cmFsV2lkdGgsZz1mLzEwMH0sYi5vbkxvYWRUaHVtYm5haWw9ZnVuY3Rpb24oYSl7Zz1hLmN1cnJlbnRUYXJnZXQubmF0dXJhbFdpZHRofSxiLnVwZGF0ZVRodW1ibmFpbHM9ZnVuY3Rpb24oYSl7dmFyIGM9TWF0aC5yb3VuZCgxMDAqYS8oZS50b3RhbFRpbWUvMWUzKSksZD1oLnNjcm9sbFdpZHRoKmMvMTAwLWcvMjtpZihpKXt2YXIgaj1NYXRoLnJvdW5kKGYqYy8xMDApO2IudGh1bWJuYWlsQ29udGFpbmVyPXt3aWR0aDpnK1wicHhcIixsZWZ0OmQrXCJweFwifSxiLnRodW1ibmFpbHM9e1wiYmFja2dyb3VuZC1pbWFnZVwiOid1cmwoXCInK2IudmdUaHVtYm5haWxzKydcIiknLFwiYmFja2dyb3VuZC1wb3NpdGlvblwiOi1qK1wicHggMHB4XCJ9fWVsc2V7dmFyIGs9ZS50b3RhbFRpbWUvaC5zY3JvbGxXaWR0aC8xZTMsbD17c3RhcnQ6TWF0aC5mbG9vcihhLWsvMiksZW5kOk1hdGguY2VpbChhKX07aWYobC5zdGFydDwwJiYobC5zdGFydD0wKSxsLmVuZD5lLnRvdGFsVGltZSYmKGwuZW5kPWUudG90YWxUaW1lKSxiLnRodW1ibmFpbENvbnRhaW5lcj17bGVmdDpkK1wicHhcIn0sYi50aHVtYm5haWxzPXtcImJhY2tncm91bmQtaW1hZ2VcIjpcIm5vbmVcIn0sYi52Z1RodW1ibmFpbHMpZm9yKHZhciBtPTAsbj1iLnZnVGh1bWJuYWlscy5sZW5ndGg7bj5tO20rKyl7dmFyIG89Yi52Z1RodW1ibmFpbHNbbV07aWYoby50aW1lTGFwc2UuZW5kPj0wKXtpZihsLnN0YXJ0Pj1vLnRpbWVMYXBzZS5zdGFydCYmKGwuZW5kPD1vLnRpbWVMYXBzZS5lbmR8fGwuZW5kPD1vLnRpbWVMYXBzZS5zdGFydCkpe2IudGh1bWJuYWlscz17XCJiYWNrZ3JvdW5kLWltYWdlXCI6J3VybChcIicrby5wYXJhbXMudGh1bWJuYWlsKydcIiknfTticmVha319ZWxzZSBpZihvLnRpbWVMYXBzZS5zdGFydD49bC5zdGFydCYmby50aW1lTGFwc2Uuc3RhcnQ8PWwuZW5kKXtiLnRodW1ibmFpbHM9e1wiYmFja2dyb3VuZC1pbWFnZVwiOid1cmwoXCInK28ucGFyYW1zLnRodW1ibmFpbCsnXCIpJ307YnJlYWt9fX19LGIub25Nb3VzZU1vdmU9ZnVuY3Rpb24oYSl7dmFyIGM9TWF0aC5yb3VuZChhLm9mZnNldFgqZS5tZWRpYUVsZW1lbnRbMF0uZHVyYXRpb24vaC5zY3JvbGxXaWR0aCk7Yi51cGRhdGVUaHVtYm5haWxzKGMpLGIuJGRpZ2VzdCgpfSxiLm9uVG91Y2hNb3ZlPWZ1bmN0aW9uKGEpe3ZhciBjPWEudG91Y2hlcyxkPWIuZ2V0T2Zmc2V0KGNbMF0pLGY9TWF0aC5yb3VuZChkKmUubWVkaWFFbGVtZW50WzBdLmR1cmF0aW9uL2guc2Nyb2xsV2lkdGgpO2IudXBkYXRlVGh1bWJuYWlscyhmKSxiLiRkaWdlc3QoKX0sYi5vbk1vdXNlTGVhdmU9ZnVuY3Rpb24oYSl7Yi50aHVtYm5haWxzPSExLGIuJGRpZ2VzdCgpfSxiLm9uVG91Y2hMZWF2ZT1mdW5jdGlvbihhKXtiLnRodW1ibmFpbHM9ITEsYi4kZGlnZXN0KCl9LGIub25EZXN0cm95PWZ1bmN0aW9uKCl7Yy51bmJpbmQoXCJ0b3VjaG1vdmVcIixiLm9uVG91Y2hNb3ZlKSxjLnVuYmluZChcInRvdWNobGVhdmVcIixiLm9uVG91Y2hMZWF2ZSksYy51bmJpbmQoXCJ0b3VjaGVuZFwiLGIub25Ub3VjaExlYXZlKSxjLnVuYmluZChcIm1vdXNlbW92ZVwiLGIub25Nb3VzZU1vdmUpLGMudW5iaW5kKFwibW91c2VsZWF2ZVwiLGIub25Nb3VzZUxlYXZlKX07dmFyIGo7aT8oaj1uZXcgSW1hZ2Usai5vbmxvYWQ9Yi5vbkxvYWRUaHVtYm5haWxzLmJpbmQoYiksai5zcmM9Yi52Z1RodW1ibmFpbHMpOihqPW5ldyBJbWFnZSxqLm9ubG9hZD1iLm9uTG9hZFRodW1ibmFpbC5iaW5kKGIpLGouc3JjPWIudmdUaHVtYm5haWxzWzBdLnBhcmFtcy50aHVtYm5haWwpLGEuaXNNb2JpbGVEZXZpY2UoKT8oYy5iaW5kKFwidG91Y2htb3ZlXCIsYi5vblRvdWNoTW92ZSksYy5iaW5kKFwidG91Y2hsZWF2ZVwiLGIub25Ub3VjaExlYXZlKSxjLmJpbmQoXCJ0b3VjaGVuZFwiLGIub25Ub3VjaExlYXZlKSk6KGMuYmluZChcIm1vdXNlbW92ZVwiLGIub25Nb3VzZU1vdmUpLGMuYmluZChcIm1vdXNlbGVhdmVcIixiLm9uTW91c2VMZWF2ZSkpLGIuJG9uKFwiZGVzdHJveVwiLGIub25EZXN0cm95LmJpbmQoYikpfX19XSksYW5ndWxhci5tb2R1bGUoXCJjb20uMmZkZXZzLnZpZGVvZ3VsYXIucGx1Z2lucy5jb250cm9sc1wiKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIixmdW5jdGlvbihhKXthLnB1dChcInZnLXRlbXBsYXRlcy92Zy1zY3J1Yi1iYXJcIiwnPGRpdiByb2xlPVwic2xpZGVyXCIgYXJpYS12YWx1ZW1heD1cInt7YXJpYVRpbWUoQVBJLnRvdGFsVGltZSl9fVwiIGFyaWEtdmFsdWVub3c9XCJ7e2FyaWFUaW1lKEFQSS5jdXJyZW50VGltZSl9fVwiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS1sYWJlbD1cIlRpbWUgc2NydWIgYmFyXCIgdGFiaW5kZXg9XCIwXCIgbmcta2V5ZG93bj1cIm9uU2NydWJCYXJLZXlEb3duKCRldmVudClcIj48L2Rpdj48ZGl2IGNsYXNzPVwiY29udGFpbmVyXCIgbmctdHJhbnNjbHVkZT48L2Rpdj4nKX1dKS5kaXJlY3RpdmUoXCJ2Z1NjcnViQmFyXCIsW1wiVkdfU1RBVEVTXCIsXCJWR19VVElMU1wiLGZ1bmN0aW9uKGEsYil7cmV0dXJue3Jlc3RyaWN0OlwiRVwiLHJlcXVpcmU6XCJedmlkZW9ndWxhclwiLHRyYW5zY2x1ZGU6ITAsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi52Z1RlbXBsYXRlfHxcInZnLXRlbXBsYXRlcy92Zy1zY3J1Yi1iYXJcIn0sc2NvcGU6e3ZnVGh1bWJuYWlsczpcIj1cIn0sbGluazpmdW5jdGlvbihjLGQsZSxmKXt2YXIgZz0hMSxoPSExLGk9ITEsaj0zNyxrPTM5LGw9NSxtPTAsbj0wLG89ZFswXS5xdWVyeVNlbGVjdG9yKFwiZGl2W3JvbGU9c2xpZGVyXVwiKTtpZihjLnRodW1ibmFpbHM9ITEsYy50aHVtYm5haWxDb250YWluZXI9e30sYy5BUEk9ZixjLm9uTG9hZFRodW1ibmFpbHM9ZnVuY3Rpb24oYSl7bT1hLnBhdGhbMF0ubmF0dXJhbFdpZHRoLG49bS8xMDB9LGMuYXJpYVRpbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucm91bmQoYS8xZTMpfSxjLmdldE9mZnNldD1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS50YXJnZXQsYz0wO2ImJiFpc05hTihiLm9mZnNldExlZnQpOyljKz1iLm9mZnNldExlZnQtYi5zY3JvbGxMZWZ0LGI9Yi5vZmZzZXRQYXJlbnQ7cmV0dXJuIGEuY2xpZW50WC1jfSxjLm9uU2NydWJCYXJUb3VjaFN0YXJ0PWZ1bmN0aW9uKGEpe3ZhciBiPWEub3JpZ2luYWxFdmVudHx8YSxkPWIudG91Y2hlcyxlPWMuZ2V0T2Zmc2V0KGRbMF0pO2c9ITAsaCYmKGk9ITApLGYucGF1c2UoKSxmLnNlZWtUaW1lKGUqZi5tZWRpYUVsZW1lbnRbMF0uZHVyYXRpb24vby5zY3JvbGxXaWR0aCksYy4kZGlnZXN0KCl9LGMub25TY3J1YkJhclRvdWNoRW5kPWZ1bmN0aW9uKGEpe2Eub3JpZ2luYWxFdmVudHx8YTtpJiYoaT0hMSxmLnBsYXkoKSksZz0hMSxjLiRkaWdlc3QoKX0sYy5vblNjcnViQmFyVG91Y2hNb3ZlPWZ1bmN0aW9uKGEpe3ZhciBiPWEub3JpZ2luYWxFdmVudHx8YSxkPWIudG91Y2hlcyxlPWMuZ2V0T2Zmc2V0KGRbMF0pO2lmKGMudmdUaHVtYm5haWxzJiZjLnZnVGh1bWJuYWlscy5sZW5ndGgpe3ZhciBoPU1hdGgucm91bmQoZSpmLm1lZGlhRWxlbWVudFswXS5kdXJhdGlvbi9vLnNjcm9sbFdpZHRoKSxpPU1hdGgucm91bmQoMTAwKmgvKGYudG90YWxUaW1lLzFlMykpO2MudXBkYXRlVGh1bWJuYWlscyhpKX1nJiZmLnNlZWtUaW1lKGUqZi5tZWRpYUVsZW1lbnRbMF0uZHVyYXRpb24vby5zY3JvbGxXaWR0aCksYy4kZGlnZXN0KCl9LGMub25TY3J1YkJhclRvdWNoTGVhdmU9ZnVuY3Rpb24oYSl7Zz0hMSxjLnRodW1ibmFpbHM9ITEsYy4kZGlnZXN0KCl9LGMub25TY3J1YkJhck1vdXNlRG93bj1mdW5jdGlvbihhKXthPWIuZml4RXZlbnRPZmZzZXQoYSksZz0hMCxoJiYoaT0hMCksZi5wYXVzZSgpLGYuc2Vla1RpbWUoYS5vZmZzZXRYKmYubWVkaWFFbGVtZW50WzBdLmR1cmF0aW9uL28uc2Nyb2xsV2lkdGgpLGMuJGRpZ2VzdCgpfSxjLm9uU2NydWJCYXJNb3VzZVVwPWZ1bmN0aW9uKGEpe2kmJihpPSExLGYucGxheSgpKSxnPSExLGMuJGRpZ2VzdCgpfSxjLm9uU2NydWJCYXJNb3VzZU1vdmU9ZnVuY3Rpb24oYSl7aWYoYy52Z1RodW1ibmFpbHMmJmMudmdUaHVtYm5haWxzLmxlbmd0aCl7dmFyIGQ9TWF0aC5yb3VuZChhLm9mZnNldFgqZi5tZWRpYUVsZW1lbnRbMF0uZHVyYXRpb24vby5zY3JvbGxXaWR0aCksZT1NYXRoLnJvdW5kKDEwMCpkLyhmLnRvdGFsVGltZS8xZTMpKTtjLnVwZGF0ZVRodW1ibmFpbHMoZSl9ZyYmKGE9Yi5maXhFdmVudE9mZnNldChhKSxmLnNlZWtUaW1lKGEub2Zmc2V0WCpmLm1lZGlhRWxlbWVudFswXS5kdXJhdGlvbi9vLnNjcm9sbFdpZHRoKSksYy4kZGlnZXN0KCl9LGMub25TY3J1YkJhck1vdXNlTGVhdmU9ZnVuY3Rpb24oYSl7Zz0hMSxjLnRodW1ibmFpbHM9ITEsYy4kZGlnZXN0KCl9LGMub25TY3J1YkJhcktleURvd249ZnVuY3Rpb24oYSl7dmFyIGI9Zi5jdXJyZW50VGltZS9mLnRvdGFsVGltZSoxMDA7YS53aGljaD09PWp8fGEua2V5Q29kZT09PWo/KGYuc2Vla1RpbWUoYi1sLCEwKSxhLnByZXZlbnREZWZhdWx0KCkpOihhLndoaWNoPT09a3x8YS5rZXlDb2RlPT09aykmJihmLnNlZWtUaW1lKGIrbCwhMCksYS5wcmV2ZW50RGVmYXVsdCgpKX0sYy51cGRhdGVUaHVtYm5haWxzPWZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgucm91bmQobSphLzEwMCksZD1vLnNjcm9sbFdpZHRoKmEvMTAwLW4vMjtjLnRodW1ibmFpbENvbnRhaW5lcj17d2lkdGg6bitcInB4XCIsbGVmdDpkK1wicHhcIn0sYy50aHVtYm5haWxzPXtcImJhY2tncm91bmQtaW1hZ2VcIjondXJsKFwiJytjLnZnVGh1bWJuYWlscysnXCIpJyxcImJhY2tncm91bmQtcG9zaXRpb25cIjotYitcInB4IDBweFwifX0sYy5zZXRTdGF0ZT1mdW5jdGlvbihiKXtpZighZylzd2l0Y2goYil7Y2FzZSBhLlBMQVk6aD0hMDticmVhaztjYXNlIGEuUEFVU0U6aD0hMTticmVhaztjYXNlIGEuU1RPUDpoPSExfX0sYy5vbkRlc3Ryb3k9ZnVuY3Rpb24oKXtkLnVuYmluZChcInRvdWNoc3RhcnRcIixjLm9uU2NydWJCYXJUb3VjaFN0YXJ0KSxkLnVuYmluZChcInRvdWNoZW5kXCIsYy5vblNjcnViQmFyVG91Y2hFbmQpLGQudW5iaW5kKFwidG91Y2htb3ZlXCIsYy5vblNjcnViQmFyVG91Y2hNb3ZlKSxkLnVuYmluZChcInRvdWNobGVhdmVcIixjLm9uU2NydWJCYXJUb3VjaExlYXZlKSxkLnVuYmluZChcIm1vdXNlZG93blwiLGMub25TY3J1YkJhck1vdXNlRG93biksZC51bmJpbmQoXCJtb3VzZXVwXCIsYy5vblNjcnViQmFyTW91c2VVcCksZC51bmJpbmQoXCJtb3VzZW1vdmVcIixjLm9uU2NydWJCYXJNb3VzZU1vdmUpLGQudW5iaW5kKFwibW91c2VsZWF2ZVwiLGMub25TY3J1YkJhck1vdXNlTGVhdmUpfSxjLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBmLmN1cnJlbnRTdGF0ZX0sZnVuY3Rpb24oYSxiKXthIT1iJiZjLnNldFN0YXRlKGEpfSksYy52Z1RodW1ibmFpbHMpe3ZhciBwPW5ldyBJbWFnZTtwLm9ubG9hZD1jLm9uTG9hZFRodW1ibmFpbHMuYmluZChjKSxwLnNyYz1jLnZnVGh1bWJuYWlsc31iLmlzTW9iaWxlRGV2aWNlKCk/KGQuYmluZChcInRvdWNoc3RhcnRcIixjLm9uU2NydWJCYXJUb3VjaFN0YXJ0KSxkLmJpbmQoXCJ0b3VjaGVuZFwiLGMub25TY3J1YkJhclRvdWNoRW5kKSxkLmJpbmQoXCJ0b3VjaG1vdmVcIixjLm9uU2NydWJCYXJUb3VjaE1vdmUpLGQuYmluZChcInRvdWNobGVhdmVcIixjLm9uU2NydWJCYXJUb3VjaExlYXZlKSk6KGQuYmluZChcIm1vdXNlZG93blwiLGMub25TY3J1YkJhck1vdXNlRG93biksZC5iaW5kKFwibW91c2V1cFwiLGMub25TY3J1YkJhck1vdXNlVXApLGQuYmluZChcIm1vdXNlbW92ZVwiLGMub25TY3J1YkJhck1vdXNlTW92ZSksZC5iaW5kKFwibW91c2VsZWF2ZVwiLGMub25TY3J1YkJhck1vdXNlTGVhdmUpKSxjLiRvbihcImRlc3Ryb3lcIixjLm9uRGVzdHJveS5iaW5kKGMpKX19fV0pLGFuZ3VsYXIubW9kdWxlKFwiY29tLjJmZGV2cy52aWRlb2d1bGFyLnBsdWdpbnMuY29udHJvbHNcIikuZGlyZWN0aXZlKFwidmdUaW1lRGlzcGxheVwiLFtmdW5jdGlvbigpe3JldHVybntyZXF1aXJlOlwiXnZpZGVvZ3VsYXJcIixyZXN0cmljdDpcIkVcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2EuY3VycmVudFRpbWU9ZC5jdXJyZW50VGltZSxhLnRpbWVMZWZ0PWQudGltZUxlZnQsYS50b3RhbFRpbWU9ZC50b3RhbFRpbWUsYS5pc0xpdmU9ZC5pc0xpdmUsYS4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gZC5jdXJyZW50VGltZX0sZnVuY3Rpb24oYixjKXthLmN1cnJlbnRUaW1lPWJ9KSxhLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBkLnRpbWVMZWZ0fSxmdW5jdGlvbihiLGMpe2EudGltZUxlZnQ9Yn0pLGEuJHdhdGNoKGZ1bmN0aW9uKCl7cmV0dXJuIGQudG90YWxUaW1lfSxmdW5jdGlvbihiLGMpe2EudG90YWxUaW1lPWJ9KSxhLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBkLmlzTGl2ZX0sZnVuY3Rpb24oYixjKXthLmlzTGl2ZT1ifSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhci5wbHVnaW5zLmNvbnRyb2xzXCIpLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLGZ1bmN0aW9uKGEpe2EucHV0KFwidmctdGVtcGxhdGVzL3ZnLW11dGUtYnV0dG9uXCIsJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiaWNvbkJ1dHRvblwiIG5nLWNsYXNzPVwibXV0ZUljb25cIiBuZy1jbGljaz1cIm9uQ2xpY2tNdXRlKClcIiBuZy1mb2N1cz1cIm9uTXV0ZUJ1dHRvbkZvY3VzKClcIiBuZy1ibHVyPVwib25NdXRlQnV0dG9uTG9zZUZvY3VzKClcIiBuZy1tb3VzZWxlYXZlPVwib25NdXRlQnV0dG9uTGVhdmUoKVwiIG5nLWtleWRvd249XCJvbk11dGVCdXR0b25LZXlEb3duKCRldmVudClcIiBhcmlhLWxhYmVsPVwiTXV0ZVwiPjwvYnV0dG9uPicpfV0pLmRpcmVjdGl2ZShcInZnTXV0ZUJ1dHRvblwiLFtmdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcIkVcIixyZXF1aXJlOlwiXnZpZGVvZ3VsYXJcIix0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnZnVGVtcGxhdGV8fFwidmctdGVtcGxhdGVzL3ZnLW11dGUtYnV0dG9uXCJ9LGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ITEsZj0zOCxnPTQwLGg9LjA1O2Eub25DbGlja011dGU9ZnVuY3Rpb24oKXtlP2EuY3VycmVudFZvbHVtZT1hLmRlZmF1bHRWb2x1bWU6KGEuY3VycmVudFZvbHVtZT0wLGEubXV0ZUljb249e211dGU6ITB9KSxlPSFlLGQuc2V0Vm9sdW1lKGEuY3VycmVudFZvbHVtZSl9LGEub25NdXRlQnV0dG9uRm9jdXM9ZnVuY3Rpb24oKXthLnZvbHVtZVZpc2liaWxpdHk9XCJ2aXNpYmxlXCJ9LGEub25NdXRlQnV0dG9uTG9zZUZvY3VzPWZ1bmN0aW9uKCl7YS52b2x1bWVWaXNpYmlsaXR5PVwiaGlkZGVuXCJ9LGEub25NdXRlQnV0dG9uTGVhdmU9ZnVuY3Rpb24oKXtkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKX0sYS5vbk11dGVCdXR0b25LZXlEb3duPWZ1bmN0aW9uKGEpe3ZhciBiLGM9bnVsbCE9ZC52b2x1bWU/ZC52b2x1bWU6MTthLndoaWNoPT09Znx8YS5rZXlDb2RlPT09Zj8oYj1jK2gsYj4xJiYoYj0xKSxkLnNldFZvbHVtZShiKSxhLnByZXZlbnREZWZhdWx0KCkpOihhLndoaWNoPT09Z3x8YS5rZXlDb2RlPT09ZykmJihiPWMtaCwwPmImJihiPTApLGQuc2V0Vm9sdW1lKGIpLGEucHJldmVudERlZmF1bHQoKSl9LGEub25TZXRWb2x1bWU9ZnVuY3Rpb24oYil7YS5jdXJyZW50Vm9sdW1lPWIsZT0wPT09YS5jdXJyZW50Vm9sdW1lLGU/Yj4wJiYoYS5kZWZhdWx0Vm9sdW1lPWIpOmEuZGVmYXVsdFZvbHVtZT1iO3ZhciBjPU1hdGgucm91bmQoMTAwKmIpOzA9PWM/YS5tdXRlSWNvbj17bXV0ZTohMH06Yz4wJiYyNT5jP2EubXV0ZUljb249e2xldmVsMDohMH06Yz49MjUmJjUwPmM/YS5tdXRlSWNvbj17bGV2ZWwxOiEwfTpjPj01MCYmNzU+Yz9hLm11dGVJY29uPXtsZXZlbDI6ITB9OmM+PTc1JiYoYS5tdXRlSWNvbj17bGV2ZWwzOiEwfSl9LGEuZGVmYXVsdFZvbHVtZT0xLGEuY3VycmVudFZvbHVtZT1hLmRlZmF1bHRWb2x1bWUsYS5tdXRlSWNvbj17bGV2ZWwzOiEwfSxhLm9uU2V0Vm9sdW1lKGQudm9sdW1lKSxhLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBkLnZvbHVtZX0sZnVuY3Rpb24oYixjKXtiIT1jJiZhLm9uU2V0Vm9sdW1lKGIpfSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhci5wbHVnaW5zLmNvbnRyb2xzXCIpLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLGZ1bmN0aW9uKGEpe2EucHV0KFwidmctdGVtcGxhdGVzL3ZnLXZvbHVtZS1iYXJcIiwnPGRpdiBjbGFzcz1cInZlcnRpY2FsVm9sdW1lQmFyXCI+ICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidm9sdW1lQmFja2dyb3VuZFwiIG5nLWNsaWNrPVwib25DbGlja1ZvbHVtZSgkZXZlbnQpXCIgbmctbW91c2Vkb3duPVwib25Nb3VzZURvd25Wb2x1bWUoKVwiIG5nLW1vdXNldXA9XCJvbk1vdXNlVXBWb2x1bWUoKVwiIG5nLW1vdXNlbW92ZT1cIm9uTW91c2VNb3ZlVm9sdW1lKCRldmVudClcIiBuZy1tb3VzZWxlYXZlPVwib25Nb3VzZUxlYXZlVm9sdW1lKClcIj4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZvbHVtZVZhbHVlXCI+PC9kaXY+ICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2b2x1bWVDbGlja0FyZWFcIj48L2Rpdj4gICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIDwvZGl2PicpfV0pLmRpcmVjdGl2ZShcInZnVm9sdW1lQmFyXCIsW1wiVkdfVVRJTFNcIixmdW5jdGlvbihhKXtyZXR1cm57cmVzdHJpY3Q6XCJFXCIscmVxdWlyZTpcIl52aWRlb2d1bGFyXCIsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi52Z1RlbXBsYXRlfHxcInZnLXRlbXBsYXRlcy92Zy12b2x1bWUtYmFyXCJ9LGxpbms6ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9ITEsZz1hbmd1bGFyLmVsZW1lbnQoY1swXS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidm9sdW1lQmFja2dyb3VuZFwiKSksaD1hbmd1bGFyLmVsZW1lbnQoY1swXS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidm9sdW1lVmFsdWVcIikpO2Iub25DbGlja1ZvbHVtZT1mdW5jdGlvbihiKXtiPWEuZml4RXZlbnRPZmZzZXQoYik7dmFyIGM9cGFyc2VJbnQoZy5wcm9wKFwib2Zmc2V0SGVpZ2h0XCIpKSxkPTEwMCpiLm9mZnNldFkvYyxmPTEtZC8xMDA7ZS5zZXRWb2x1bWUoZil9LGIub25Nb3VzZURvd25Wb2x1bWU9ZnVuY3Rpb24oKXtmPSEwfSxiLm9uTW91c2VVcFZvbHVtZT1mdW5jdGlvbigpe2Y9ITF9LGIub25Nb3VzZUxlYXZlVm9sdW1lPWZ1bmN0aW9uKCl7Zj0hMX0sYi5vbk1vdXNlTW92ZVZvbHVtZT1mdW5jdGlvbihiKXtpZihmKXtiPWEuZml4RXZlbnRPZmZzZXQoYik7dmFyIGM9cGFyc2VJbnQoZy5wcm9wKFwib2Zmc2V0SGVpZ2h0XCIpKSxkPTEwMCpiLm9mZnNldFkvYyxoPTEtZC8xMDA7ZS5zZXRWb2x1bWUoaCl9fSxiLnVwZGF0ZVZvbHVtZVZpZXc9ZnVuY3Rpb24oYSl7YT0xMDAqYSxoLmNzcyhcImhlaWdodFwiLGErXCIlXCIpLGguY3NzKFwidG9wXCIsMTAwLWErXCIlXCIpfSxiLm9uQ2hhbmdlVmlzaWJpbGl0eT1mdW5jdGlvbihhKXtjLmNzcyhcInZpc2liaWxpdHlcIixhKX0sYy5jc3MoXCJ2aXNpYmlsaXR5XCIsYi52b2x1bWVWaXNpYmlsaXR5KSxiLiR3YXRjaChcInZvbHVtZVZpc2liaWxpdHlcIixiLm9uQ2hhbmdlVmlzaWJpbGl0eSksYi51cGRhdGVWb2x1bWVWaWV3KGUudm9sdW1lKSxiLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBlLnZvbHVtZX0sZnVuY3Rpb24oYSxjKXthIT1jJiZiLnVwZGF0ZVZvbHVtZVZpZXcoYSl9KX19fV0pLGFuZ3VsYXIubW9kdWxlKFwiY29tLjJmZGV2cy52aWRlb2d1bGFyLnBsdWdpbnMuY29udHJvbHNcIikuZGlyZWN0aXZlKFwidmdWb2x1bWVcIixbXCJWR19VVElMU1wiLGZ1bmN0aW9uKGEpe3JldHVybntyZXN0cmljdDpcIkVcIixsaW5rOmZ1bmN0aW9uKGIsYyxkKXtiLm9uTW91c2VPdmVyVm9sdW1lPWZ1bmN0aW9uKCl7Yi4kZXZhbEFzeW5jKGZ1bmN0aW9uKCl7Yi52b2x1bWVWaXNpYmlsaXR5PVwidmlzaWJsZVwifSl9LGIub25Nb3VzZUxlYXZlVm9sdW1lPWZ1bmN0aW9uKCl7Yi4kZXZhbEFzeW5jKGZ1bmN0aW9uKCl7Yi52b2x1bWVWaXNpYmlsaXR5PVwiaGlkZGVuXCJ9KX0sYi5vbkRlc3Ryb3k9ZnVuY3Rpb24oKXtjLnVuYmluZChcIm1vdXNlb3ZlclwiLGIub25TY3J1YkJhclRvdWNoU3RhcnQpLGMudW5iaW5kKFwibW91c2VsZWF2ZVwiLGIub25TY3J1YkJhclRvdWNoRW5kKX0sYS5pc01vYmlsZURldmljZSgpP2MuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKTooYi52b2x1bWVWaXNpYmlsaXR5PVwiaGlkZGVuXCIsYy5iaW5kKFwibW91c2VvdmVyXCIsYi5vbk1vdXNlT3ZlclZvbHVtZSksYy5iaW5kKFwibW91c2VsZWF2ZVwiLGIub25Nb3VzZUxlYXZlVm9sdW1lKSksYi4kb24oXCJkZXN0cm95XCIsYi5vbkRlc3Ryb3kuYmluZChiKSl9fX1dKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdmlkZW9ndWxhci1jb250cm9scy92Zy1jb250cm9scy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports) {

"use strict";
eval("\"use strict\";angular.module(\"com.2fdevs.videogular\",[\"ngSanitize\"]).run([\"$templateCache\",function(a){a.put(\"vg-templates/vg-media-video\",\"<video></video>\"),a.put(\"vg-templates/vg-media-audio\",\"<audio></audio>\"),Function.prototype.bind||(Function.prototype.bind=function(a){if(\"function\"!=typeof this)throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");var b=Array.prototype.slice.call(arguments,1),c=this,d=function(){},e=function(){return c.apply(this instanceof d?this:a,b.concat(Array.prototype.slice.call(arguments)))};return d.prototype=this.prototype,e.prototype=new d,e})}]),angular.module(\"com.2fdevs.videogular\").constant(\"VG_STATES\",{PLAY:\"play\",PAUSE:\"pause\",STOP:\"stop\"}).constant(\"VG_VOLUME_KEY\",\"videogularVolume\"),angular.module(\"com.2fdevs.videogular\").controller(\"vgController\",[\"$scope\",\"$window\",\"vgConfigLoader\",\"vgFullscreen\",\"VG_UTILS\",\"VG_STATES\",\"VG_VOLUME_KEY\",function(a,b,c,d,e,f,g){var h=null,i=!1,j=!1,k=!1,l=!1;this.videogularElement=null,this.clearMedia=function(){this.mediaElement[0].src=\"\",this.mediaElement[0].removeEventListener(\"canplay\",this.onCanPlay.bind(this),!1),this.mediaElement[0].removeEventListener(\"loadedmetadata\",this.onLoadMetaData.bind(this),!1),this.mediaElement[0].removeEventListener(\"waiting\",this.onStartBuffering.bind(this),!1),this.mediaElement[0].removeEventListener(\"ended\",this.onComplete.bind(this),!1),this.mediaElement[0].removeEventListener(\"playing\",this.onStartPlaying.bind(this),!1),this.mediaElement[0].removeEventListener(\"play\",this.onPlay.bind(this),!1),this.mediaElement[0].removeEventListener(\"pause\",this.onPause.bind(this),!1),this.mediaElement[0].removeEventListener(\"volumechange\",this.onVolumeChange.bind(this),!1),this.mediaElement[0].removeEventListener(\"playbackchange\",this.onPlaybackChange.bind(this),!1),this.mediaElement[0].removeEventListener(\"timeupdate\",this.onUpdateTime.bind(this),!1),this.mediaElement[0].removeEventListener(\"progress\",this.onProgress.bind(this),!1),this.mediaElement[0].removeEventListener(\"seeking\",this.onSeeking.bind(this),!1),this.mediaElement[0].removeEventListener(\"seeked\",this.onSeeked.bind(this),!1),this.mediaElement[0].removeEventListener(\"error\",this.onVideoError.bind(this),!1)},this.onRouteChange=function(){(void 0===this.clearMediaOnNavigate||this.clearMediaOnNavigate===!0)&&this.clearMedia()},this.onCanPlay=function(b){this.isBuffering=!1,a.$parent.$digest(a.vgCanPlay({$event:b})),!k&&(this.startTime>0||0===this.startTime)&&(this.seekTime(this.startTime),k=!0)},this.onVideoReady=function(){this.isReady=!0,this.autoPlay=a.vgAutoPlay,this.playsInline=a.vgPlaysInline,this.nativeFullscreen=a.vgNativeFullscreen||!0,this.cuePoints=a.vgCuePoints,this.startTime=a.vgStartTime,this.virtualClipDuration=a.vgVirtualClipDuration,this.clearMediaOnNavigate=a.vgClearMediaOnNavigate||!0,this.currentState=f.STOP,j=!0,l=this.startTime>=0&&this.virtualClipDuration>0,e.supportsLocalStorage()&&this.setVolume(parseFloat(b.localStorage.getItem(g)||\"1\")),a.vgConfig?c.loadConfig(a.vgConfig).then(this.onLoadConfig.bind(this)):a.vgPlayerReady({$API:this})},this.onLoadConfig=function(b){this.config=b,a.vgTheme=this.config.theme,a.vgAutoPlay=this.config.autoPlay,a.vgPlaysInline=this.config.playsInline,a.vgNativeFullscreen=this.config.nativeFullscreen,a.vgCuePoints=this.config.cuePoints,a.vgClearMediaOnNavigate=this.config.clearMediaOnNavigate,a.vgStartTime=this.config.startTime,a.vgVirtualClipDuration=this.config.virtualClipDuration,l=a.vgStartTime>=0&&a.vgVirtualClipDuration>0,a.vgPlayerReady({$API:this})},this.onLoadMetaData=function(a){this.isBuffering=!1,this.onUpdateTime(a)},this.onProgress=function(b){this.updateBuffer(b),a.$parent.$digest()},this.updateBuffer=function(a){a.target.buffered.length&&(this.buffered=a.target.buffered,this.bufferEnd=1e3*a.target.buffered.end(a.target.buffered.length-1),this.bufferEnd>this.totalTime&&(this.bufferEnd=this.totalTime))},this.onUpdateTime=function(b){var c=1e3*b.target.currentTime;this.updateBuffer(b),b.target.duration!=1/0&&null!=b.target.duration&&void 0!=b.target.duration&&1.7976931348623157e308!=b.target.duration?(l?k&&(b.target.currentTime<this.startTime||b.target.currentTime-this.startTime>this.virtualClipDuration)?this.onComplete():(this.currentTime=Math.max(0,c-1e3*this.startTime),this.totalTime=1e3*this.virtualClipDuration,this.timeLeft=1e3*this.virtualClipDuration-this.currentTime):(this.currentTime=c,this.totalTime=1e3*b.target.duration,this.timeLeft=1e3*(b.target.duration-b.target.currentTime)),this.isLive=!1):(this.currentTime=c,this.isLive=!0);var d=l?this.currentTime/1e3:b.target.currentTime,e=l?this.totalTime/1e3:b.target.duration;this.cuePoints&&this.checkCuePoints(d),a.vgUpdateTime({$currentTime:d,$duration:e}),\"$apply\"!=a.$$phase&&\"$digest\"!=a.$$phase&&a.$parent.$digest()},this.checkCuePoints=function(a){for(var b in this.cuePoints)for(var c=0,d=this.cuePoints[b].length;d>c;c++){var e=this.cuePoints[b][c],f=parseInt(a,10),g=parseInt(e.timeLapse.start,10);e.timeLapse.end||(e.timeLapse.end=e.timeLapse.start+1),a<e.timeLapse.end&&(e.$$isCompleted=!1),e.$$isDirty||f!==g||\"function\"!=typeof e.onEnter||(e.onEnter(a,e.timeLapse,e.params),e.$$isDirty=!0),a>e.timeLapse.start?(a<e.timeLapse.end&&(e.onUpdate&&e.onUpdate(a,e.timeLapse,e.params),e.$$isDirty||\"function\"!=typeof e.onEnter||e.onEnter(a,e.timeLapse,e.params)),a>=e.timeLapse.end&&e.onComplete&&!e.$$isCompleted&&(e.$$isCompleted=!0,e.onComplete(a,e.timeLapse,e.params)),e.$$isDirty=!0):(e.onLeave&&e.$$isDirty&&e.onLeave(a,e.timeLapse,e.params),e.$$isDirty=!1)}},this.onPlay=function(){this.setState(f.PLAY),a.$parent.$digest()},this.onPause=function(){var b=l?this.currentTime:this.mediaElement[0].currentTime;0==b?this.setState(f.STOP):this.setState(f.PAUSE),a.$parent.$digest()},this.onVolumeChange=function(){this.volume=this.mediaElement[0].volume,a.$parent.$digest()},this.onPlaybackChange=function(){this.playback=this.mediaElement[0].playbackRate,a.$parent.$digest()},this.onSeeking=function(b){a.vgSeeking({$currentTime:b.target.currentTime,$duration:b.target.duration})},this.onSeeked=function(b){a.vgSeeked({$currentTime:b.target.currentTime,$duration:b.target.duration})},this.seekTime=function(a,b){var c;if(b)l?(a=Math.max(0,Math.min(a,100)),c=a*this.virtualClipDuration/100,this.mediaElement[0].currentTime=this.startTime+c):(c=a*this.mediaElement[0].duration/100,this.mediaElement[0].currentTime=c);else if(l){var d=a/this.mediaElement[0].duration;c=k?this.virtualClipDuration*d:0,this.mediaElement[0].currentTime=k?this.startTime+c:this.startTime}else c=a,this.mediaElement[0].currentTime=c;this.currentTime=1e3*c},this.playPause=function(){this.mediaElement[0].paused?this.play():this.pause()},this.setState=function(b){return b&&b!=this.currentState&&(a.vgUpdateState({$state:b}),this.currentState=b),this.currentState},this.play=function(){this.mediaElement[0].play(),this.setState(f.PLAY)},this.pause=function(){this.mediaElement[0].pause(),this.setState(f.PAUSE)},this.stop=function(){try{this.mediaElement[0].pause();var a=l?this.startTime:0;this.mediaElement[0].currentTime=a,this.currentTime=a,this.buffered=[],this.bufferEnd=0,this.setState(f.STOP)}catch(b){return b}},this.toggleFullScreen=function(){d.isAvailable&&this.nativeFullscreen?this.isFullScreen?e.isMobileDevice()||d.exit():e.isMobileDevice()?e.isiOSDevice()?j?this.enterElementInFullScreen(this.mediaElement[0]):(i=!0,this.play()):this.enterElementInFullScreen(this.mediaElement[0]):this.enterElementInFullScreen(this.videogularElement[0]):(this.isFullScreen?(this.videogularElement.removeClass(\"fullscreen\"),this.videogularElement.css(\"z-index\",\"auto\")):(this.videogularElement.addClass(\"fullscreen\"),this.videogularElement.css(\"z-index\",e.getZIndex())),this.isFullScreen=!this.isFullScreen)},this.enterElementInFullScreen=function(a){d.request(a)},this.changeSource=function(b){a.vgChangeSource({$source:b})},this.setVolume=function(c){c=Math.max(Math.min(c,1),0),a.vgUpdateVolume({$volume:c}),this.mediaElement[0].volume=c,this.volume=c,e.supportsLocalStorage()&&b.localStorage.setItem(g,c.toString())},this.setPlayback=function(b){a.vgUpdatePlayback({$playBack:b}),this.mediaElement[0].playbackRate=b,this.playback=b},this.updateTheme=function(a){var b,c,d=document.getElementsByTagName(\"link\");if(h)for(b=0,c=d.length;c>b;b++)if(d[b].outerHTML.indexOf(h)>=0){d[b].parentNode.removeChild(d[b]);break}if(a){var e=angular.element(document).find(\"head\"),f=!1;for(b=0,c=d.length;c>b&&!(f=d[b].outerHTML.indexOf(a)>=0);b++);f||e.append(\"<link rel='stylesheet' href='\"+a+\"'>\"),h=a}},this.onStartBuffering=function(b){this.isBuffering=!0,a.$parent.$digest()},this.onStartPlaying=function(b){this.isBuffering=!1,a.$parent.$digest()},this.onComplete=function(b){a.vgComplete(),this.setState(f.STOP),this.isCompleted=!0,l&&this.stop(),a.$parent.$digest()},this.onVideoError=function(b){a.vgError({$event:b})},this.addListeners=function(){this.mediaElement[0].addEventListener(\"canplay\",this.onCanPlay.bind(this),!1),this.mediaElement[0].addEventListener(\"loadedmetadata\",this.onLoadMetaData.bind(this),!1),this.mediaElement[0].addEventListener(\"waiting\",this.onStartBuffering.bind(this),!1),this.mediaElement[0].addEventListener(\"ended\",this.onComplete.bind(this),!1),this.mediaElement[0].addEventListener(\"playing\",this.onStartPlaying.bind(this),!1),this.mediaElement[0].addEventListener(\"play\",this.onPlay.bind(this),!1),this.mediaElement[0].addEventListener(\"pause\",this.onPause.bind(this),!1),this.mediaElement[0].addEventListener(\"volumechange\",this.onVolumeChange.bind(this),!1),this.mediaElement[0].addEventListener(\"playbackchange\",this.onPlaybackChange.bind(this),!1),this.mediaElement[0].addEventListener(\"timeupdate\",this.onUpdateTime.bind(this),!1),this.mediaElement[0].addEventListener(\"progress\",this.onProgress.bind(this),!1),this.mediaElement[0].addEventListener(\"seeking\",this.onSeeking.bind(this),!1),this.mediaElement[0].addEventListener(\"seeked\",this.onSeeked.bind(this),!1),this.mediaElement[0].addEventListener(\"error\",this.onVideoError.bind(this),!1)},this.init=function(){this.isReady=!1,this.isCompleted=!1,this.buffered=[],this.bufferEnd=0,this.currentTime=0,this.totalTime=0,this.timeLeft=0,this.isLive=!1,this.isFullScreen=!1,this.playback=1,this.isConfig=void 0!=a.vgConfig,this.mediaElement=[{play:function(){},pause:function(){},stop:function(){},addEventListener:function(){},removeEventListener:function(){}}],d.isAvailable&&(this.isFullScreen=d.isFullScreen()),this.updateTheme(a.vgTheme),this.addBindings(),d.isAvailable&&document.addEventListener(d.onchange,this.onFullScreenChange.bind(this))},this.onUpdateTheme=function(a){this.updateTheme(a)},this.onUpdateAutoPlay=function(a){a&&!this.autoPlay&&(this.autoPlay=a,this.play(this))},this.onUpdateStartTime=function(a){if(a&&a!=this.startTime){this.mediaElement[0].currentTime=a,this.startTime=a,l=this.startTime>=0&&this.virtualClipDuration>0;var b={target:this.mediaElement[0]};this.onUpdateTime(b,!0)}},this.onUpdateVirtualClipDuration=function(a){if(a&&a!=this.virtualClipDuration){this.virtualClipDuration=a,l=this.startTime>=0&&this.virtualClipDuration>0;var b={target:this.mediaElement[0]};this.onUpdateTime(b,!0)}},this.onUpdatePlaysInline=function(a){this.playsInline=a},this.onUpdateNativeFullscreen=function(a){void 0==a&&(a=!0),this.nativeFullscreen=a},this.onUpdateCuePoints=function(a){this.cuePoints=a,this.checkCuePoints(this.currentTime)},this.onUpdateClearMediaOnNavigate=function(a){this.clearMediaOnNavigate=a},this.addBindings=function(){a.$watch(\"vgTheme\",this.onUpdateTheme.bind(this)),a.$watch(\"vgAutoPlay\",this.onUpdateAutoPlay.bind(this)),a.$watch(\"vgStartTime\",this.onUpdateStartTime.bind(this)),a.$watch(\"vgVirtualClipDuration\",this.onUpdateVirtualClipDuration.bind(this)),a.$watch(\"vgPlaysInline\",this.onUpdatePlaysInline.bind(this)),a.$watch(\"vgNativeFullscreen\",this.onUpdateNativeFullscreen.bind(this)),a.$watch(\"vgCuePoints\",this.onUpdateCuePoints.bind(this)),a.$watch(\"vgClearMediaOnNavigate\",this.onUpdateClearMediaOnNavigate.bind(this))},this.onFullScreenChange=function(b){this.isFullScreen=d.isFullScreen(),a.$parent.$digest()},a.$on(\"$destroy\",this.clearMedia.bind(this)),a.$on(\"$routeChangeStart\",this.onRouteChange.bind(this)),this.init()}]),angular.module(\"com.2fdevs.videogular\").directive(\"vgCrossorigin\",[function(){return{restrict:\"A\",require:\"^videogular\",link:{pre:function(a,b,c,d){var e;a.setCrossorigin=function(a){a?d.mediaElement.attr(\"crossorigin\",a):d.mediaElement.removeAttr(\"crossorigin\")},d.isConfig?a.$watch(function(){return d.config},function(){d.config&&a.setCrossorigin(d.config.crossorigin)}):a.$watch(c.vgCrossorigin,function(b,c){e&&b==c||!b?a.setCrossorigin():(e=b,a.setCrossorigin(e))})}}}}]),angular.module(\"com.2fdevs.videogular\").directive(\"vgLoop\",[function(){return{restrict:\"A\",require:\"^videogular\",link:{pre:function(a,b,c,d){var e;a.setLoop=function(a){a?d.mediaElement.attr(\"loop\",a):d.mediaElement.removeAttr(\"loop\")},d.isConfig?a.$watch(function(){return d.config},function(){d.config&&a.setLoop(d.config.loop)}):a.$watch(c.vgLoop,function(b,c){e&&b==c||!b?a.setLoop():(e=b,a.setLoop(e))})}}}}]),angular.module(\"com.2fdevs.videogular\").directive(\"vgMedia\",[\"$timeout\",\"VG_UTILS\",\"VG_STATES\",function(a,b,c){return{restrict:\"E\",require:\"^videogular\",templateUrl:function(a,b){var c=b.vgType||\"video\";return b.vgTemplate||\"vg-templates/vg-media-\"+c},scope:{vgSrc:\"=?\",vgType:\"=?\"},link:function(d,e,f,g){var h;f.vgType&&\"video\"!==f.vgType?f.vgType=\"audio\":f.vgType=\"video\",d.onChangeSource=function(a,b){h&&a==b||!a||(h=a,g.currentState!==c.PLAY&&(g.currentState=c.STOP),g.sources=h,d.changeSource())},d.changeSource=function(){if(angular.isArray(h)){var c=\"\";if(g.mediaElement[0].canPlayType){for(var d=0,e=h.length;e>d;d++)if(c=g.mediaElement[0].canPlayType(h[d].type),\"maybe\"==c||\"probably\"==c){g.mediaElement.attr(\"src\",h[d].src),g.mediaElement.attr(\"type\",h[d].type),g.changeSource(h[d]);break}}else g.mediaElement.attr(\"src\",h[0].src),g.mediaElement.attr(\"type\",h[0].type),g.changeSource(h[0])}else g.mediaElement.attr(\"src\",h),g.changeSource(h);b.isMobileDevice()&&g.mediaElement[0].load(),a(function(){!g.autoPlay||!b.isCordova()&&b.isMobileDevice()||g.play()}),\"\"==c&&g.onVideoError()},g.mediaElement=e.find(f.vgType),g.sources=d.vgSrc,g.addListeners(),g.onVideoReady(),d.$watch(\"vgSrc\",d.onChangeSource),d.$watch(function(){return g.sources},d.onChangeSource),d.$watch(function(){return g.playsInline},function(a,b){a?g.mediaElement.attr(\"webkit-playsinline\",\"\"):g.mediaElement.removeAttr(\"webkit-playsinline\")}),g.isConfig&&d.$watch(function(){return g.config},function(){g.config&&(d.vgSrc=g.config.sources)})}}}]),angular.module(\"com.2fdevs.videogular\").directive(\"vgNativeControls\",[function(){return{restrict:\"A\",require:\"^videogular\",link:{pre:function(a,b,c,d){var e;a.setControls=function(a){a?d.mediaElement.attr(\"controls\",a):d.mediaElement.removeAttr(\"controls\")},d.isConfig?a.$watch(function(){return d.config},function(){d.config&&a.setControls(d.config.controls)}):a.$watch(c.vgNativeControls,function(b,c){e&&b==c||!b?a.setControls():(e=b,a.setControls(e))})}}}}]),angular.module(\"com.2fdevs.videogular\").directive(\"vgPreload\",[function(){return{restrict:\"A\",require:\"^videogular\",link:{pre:function(a,b,c,d){var e;a.setPreload=function(a){a?d.mediaElement.attr(\"preload\",a):d.mediaElement.removeAttr(\"preload\")},d.isConfig?a.$watch(function(){return d.config},function(){d.config&&a.setPreload(d.config.preload)}):a.$watch(c.vgPreload,function(b,c){e&&b==c||!b?a.setPreload():(e=b,a.setPreload(e))})}}}}]),angular.module(\"com.2fdevs.videogular\").directive(\"vgTracks\",[function(){return{restrict:\"A\",require:\"^videogular\",link:{pre:function(a,b,c,d){var e,f,g,h=!1;a.onLoadMetaData=function(){h=!0,a.updateTracks()},a.updateTracks=function(){var b=d.mediaElement.children();for(f=0,g=b.length;g>f;f++)b[f].remove&&b[f].remove();if(e)for(f=0,g=e.length;g>f;f++){var c=document.createElement(\"track\");for(var h in e[f])c[h]=e[f][h];c.addEventListener(\"load\",a.onLoadTrack.bind(a,c)),d.mediaElement[0].appendChild(c)}},a.onLoadTrack=function(b){b[\"default\"]?b.mode=\"showing\":b.mode=\"hidden\";for(var c=0,e=d.mediaElement[0].textTracks.length;e>c;c++)b.label==d.mediaElement[0].textTracks[c].label&&(b[\"default\"]?d.mediaElement[0].textTracks[c].mode=\"showing\":d.mediaElement[0].textTracks[c].mode=\"disabled\");b.removeEventListener(\"load\",a.onLoadTrack.bind(a,b))},a.setTracks=function(b){e=b,d.tracks=b,h?a.updateTracks():d.mediaElement[0].addEventListener(\"loadedmetadata\",a.onLoadMetaData.bind(a),!1)},d.isConfig?a.$watch(function(){return d.config},function(){d.config&&a.setTracks(d.config.tracks)}):a.$watch(c.vgTracks,function(b,c){e&&b==c||a.setTracks(b)},!0)}}}}]),angular.module(\"com.2fdevs.videogular\").directive(\"videogular\",[function(){return{restrict:\"EA\",scope:{vgTheme:\"=?\",vgAutoPlay:\"=?\",vgStartTime:\"=?\",vgVirtualClipDuration:\"=?\",vgPlaysInline:\"=?\",vgNativeFullscreen:\"=?\",vgClearMediaOnNavigate:\"=?\",vgCuePoints:\"=?\",vgConfig:\"@\",vgCanPlay:\"&\",vgComplete:\"&\",vgUpdateVolume:\"&\",vgUpdatePlayback:\"&\",vgUpdateTime:\"&\",vgUpdateState:\"&\",vgPlayerReady:\"&\",vgChangeSource:\"&\",vgSeeking:\"&\",vgSeeked:\"&\",vgError:\"&\"},controller:\"vgController\",controllerAs:\"API\",link:{pre:function(a,b,c,d){d.videogularElement=angular.element(b)}}}}]),angular.module(\"com.2fdevs.videogular\").service(\"vgConfigLoader\",[\"$http\",\"$q\",\"$sce\",function(a,b,c){this.loadConfig=function(d){var e=b.defer();return a({method:\"GET\",url:d}).then(function(a){for(var b=a.data,d=0,f=b.sources.length;f>d;d++)b.sources[d].src=c.trustAsResourceUrl(b.sources[d].src);e.resolve(b)},function(){e.reject()}),e.promise}}]),angular.module(\"com.2fdevs.videogular\").service(\"vgFullscreen\",[\"VG_UTILS\",function(a){function b(){var a=!1;return a=c?null!=document[d.element]||c.webkitDisplayingFullscreen:null!=document[d.element]}var c,d=null,e={w3:{enabled:\"fullscreenEnabled\",element:\"fullscreenElement\",request:\"requestFullscreen\",exit:\"exitFullscreen\",onchange:\"fullscreenchange\",onerror:\"fullscreenerror\"},newWebkit:{enabled:\"webkitFullscreenEnabled\",element:\"webkitFullscreenElement\",request:\"webkitRequestFullscreen\",exit:\"webkitExitFullscreen\",onchange:\"webkitfullscreenchange\",onerror:\"webkitfullscreenerror\"},oldWebkit:{enabled:\"webkitIsFullScreen\",element:\"webkitCurrentFullScreenElement\",request:\"webkitRequestFullScreen\",exit:\"webkitCancelFullScreen\",onchange:\"webkitfullscreenchange\",onerror:\"webkitfullscreenerror\"},moz:{enabled:\"mozFullScreen\",element:\"mozFullScreenElement\",request:\"mozRequestFullScreen\",exit:\"mozCancelFullScreen\",onchange:\"mozfullscreenchange\",onerror:\"mozfullscreenerror\"},ios:{enabled:\"webkitFullscreenEnabled\",element:\"webkitFullscreenElement\",request:\"webkitEnterFullscreen\",exit:\"webkitExitFullscreen\",onchange:\"webkitfullscreenchange\",onerror:\"webkitfullscreenerror\"},ms:{enabled:\"msFullscreenEnabled\",element:\"msFullscreenElement\",request:\"msRequestFullscreen\",exit:\"msExitFullscreen\",onchange:\"MSFullscreenChange\",onerror:\"MSFullscreenError\"}};for(var f in e)if(e[f].enabled in document){d=e[f];break}a.isiOSDevice()&&(d=e.ios),this.isAvailable=null!=d,d&&(this.onchange=d.onchange,this.onerror=d.onerror,this.isFullScreen=b,this.exit=function(){document[d.exit]()},this.request=function(a){c=a,c[d.request]()})}]),angular.module(\"com.2fdevs.videogular\").service(\"VG_UTILS\",[\"$window\",function(a){this.fixEventOffset=function(a){var b=navigator.userAgent.match(/Firefox\\/(\\d+)/i);if(b&&Number.parseInt(b.pop())<39){var c=a.currentTarget.currentStyle||window.getComputedStyle(a.target,null),d=parseInt(c.borderLeftWidth,10),e=parseInt(c.borderTopWidth,10),f=a.currentTarget.getBoundingClientRect(),g=a.clientX-d-f.left,h=a.clientY-e-f.top;a.offsetX=g,a.offsetY=h}return a},this.getZIndex=function(){for(var a,b=1,c=document.getElementsByTagName(\"*\"),d=0,e=c.length;e>d;d++)a=parseInt(window.getComputedStyle(c[d])[\"z-index\"]),a>b&&(b=a+1);return b},this.isMobileDevice=function(){return\"undefined\"!=typeof window.orientation||-1!==navigator.userAgent.indexOf(\"IEMobile\")},this.isiOSDevice=function(){return navigator.userAgent.match(/ip(hone|ad|od)/i)&&!navigator.userAgent.match(/(iemobile)[\\/\\s]?([\\w\\.]*)/i)},this.isCordova=function(){return-1===document.URL.indexOf(\"http://\")&&-1===document.URL.indexOf(\"https://\")},this.supportsLocalStorage=function(){var b=\"videogular-test-key\";try{var c=a.sessionStorage;return c.setItem(b,\"1\"),c.removeItem(b),\"localStorage\"in a&&null!==a.localStorage}catch(d){return!1}}}]);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ZpZGVvZ3VsYXIvdmlkZW9ndWxhci5taW4uanM/Njc0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjthbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhclwiLFtcIm5nU2FuaXRpemVcIl0pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLGZ1bmN0aW9uKGEpe2EucHV0KFwidmctdGVtcGxhdGVzL3ZnLW1lZGlhLXZpZGVvXCIsXCI8dmlkZW8+PC92aWRlbz5cIiksYS5wdXQoXCJ2Zy10ZW1wbGF0ZXMvdmctbWVkaWEtYXVkaW9cIixcIjxhdWRpbz48L2F1ZGlvPlwiKSxGdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKGEpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXCIpO3ZhciBiPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxjPXRoaXMsZD1mdW5jdGlvbigpe30sZT1mdW5jdGlvbigpe3JldHVybiBjLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBkP3RoaXM6YSxiLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSl9O3JldHVybiBkLnByb3RvdHlwZT10aGlzLnByb3RvdHlwZSxlLnByb3RvdHlwZT1uZXcgZCxlfSl9XSksYW5ndWxhci5tb2R1bGUoXCJjb20uMmZkZXZzLnZpZGVvZ3VsYXJcIikuY29uc3RhbnQoXCJWR19TVEFURVNcIix7UExBWTpcInBsYXlcIixQQVVTRTpcInBhdXNlXCIsU1RPUDpcInN0b3BcIn0pLmNvbnN0YW50KFwiVkdfVk9MVU1FX0tFWVwiLFwidmlkZW9ndWxhclZvbHVtZVwiKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhclwiKS5jb250cm9sbGVyKFwidmdDb250cm9sbGVyXCIsW1wiJHNjb3BlXCIsXCIkd2luZG93XCIsXCJ2Z0NvbmZpZ0xvYWRlclwiLFwidmdGdWxsc2NyZWVuXCIsXCJWR19VVElMU1wiLFwiVkdfU1RBVEVTXCIsXCJWR19WT0xVTUVfS0VZXCIsZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7dmFyIGg9bnVsbCxpPSExLGo9ITEsaz0hMSxsPSExO3RoaXMudmlkZW9ndWxhckVsZW1lbnQ9bnVsbCx0aGlzLmNsZWFyTWVkaWE9ZnVuY3Rpb24oKXt0aGlzLm1lZGlhRWxlbWVudFswXS5zcmM9XCJcIix0aGlzLm1lZGlhRWxlbWVudFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLHRoaXMub25DYW5QbGF5LmJpbmQodGhpcyksITEpLHRoaXMubWVkaWFFbGVtZW50WzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLHRoaXMub25Mb2FkTWV0YURhdGEuYmluZCh0aGlzKSwhMSksdGhpcy5tZWRpYUVsZW1lbnRbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndhaXRpbmdcIix0aGlzLm9uU3RhcnRCdWZmZXJpbmcuYmluZCh0aGlzKSwhMSksdGhpcy5tZWRpYUVsZW1lbnRbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsdGhpcy5vbkNvbXBsZXRlLmJpbmQodGhpcyksITEpLHRoaXMubWVkaWFFbGVtZW50WzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsdGhpcy5vblN0YXJ0UGxheWluZy5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheVwiLHRoaXMub25QbGF5LmJpbmQodGhpcyksITEpLHRoaXMubWVkaWFFbGVtZW50WzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLHRoaXMub25QYXVzZS5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwidm9sdW1lY2hhbmdlXCIsdGhpcy5vblZvbHVtZUNoYW5nZS5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheWJhY2tjaGFuZ2VcIix0aGlzLm9uUGxheWJhY2tDaGFuZ2UuYmluZCh0aGlzKSwhMSksdGhpcy5tZWRpYUVsZW1lbnRbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRpbWV1cGRhdGVcIix0aGlzLm9uVXBkYXRlVGltZS5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIix0aGlzLm9uUHJvZ3Jlc3MuYmluZCh0aGlzKSwhMSksdGhpcy5tZWRpYUVsZW1lbnRbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlZWtpbmdcIix0aGlzLm9uU2Vla2luZy5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsdGhpcy5vblNlZWtlZC5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIix0aGlzLm9uVmlkZW9FcnJvci5iaW5kKHRoaXMpLCExKX0sdGhpcy5vblJvdXRlQ2hhbmdlPWZ1bmN0aW9uKCl7KHZvaWQgMD09PXRoaXMuY2xlYXJNZWRpYU9uTmF2aWdhdGV8fHRoaXMuY2xlYXJNZWRpYU9uTmF2aWdhdGU9PT0hMCkmJnRoaXMuY2xlYXJNZWRpYSgpfSx0aGlzLm9uQ2FuUGxheT1mdW5jdGlvbihiKXt0aGlzLmlzQnVmZmVyaW5nPSExLGEuJHBhcmVudC4kZGlnZXN0KGEudmdDYW5QbGF5KHskZXZlbnQ6Yn0pKSwhayYmKHRoaXMuc3RhcnRUaW1lPjB8fDA9PT10aGlzLnN0YXJ0VGltZSkmJih0aGlzLnNlZWtUaW1lKHRoaXMuc3RhcnRUaW1lKSxrPSEwKX0sdGhpcy5vblZpZGVvUmVhZHk9ZnVuY3Rpb24oKXt0aGlzLmlzUmVhZHk9ITAsdGhpcy5hdXRvUGxheT1hLnZnQXV0b1BsYXksdGhpcy5wbGF5c0lubGluZT1hLnZnUGxheXNJbmxpbmUsdGhpcy5uYXRpdmVGdWxsc2NyZWVuPWEudmdOYXRpdmVGdWxsc2NyZWVufHwhMCx0aGlzLmN1ZVBvaW50cz1hLnZnQ3VlUG9pbnRzLHRoaXMuc3RhcnRUaW1lPWEudmdTdGFydFRpbWUsdGhpcy52aXJ0dWFsQ2xpcER1cmF0aW9uPWEudmdWaXJ0dWFsQ2xpcER1cmF0aW9uLHRoaXMuY2xlYXJNZWRpYU9uTmF2aWdhdGU9YS52Z0NsZWFyTWVkaWFPbk5hdmlnYXRlfHwhMCx0aGlzLmN1cnJlbnRTdGF0ZT1mLlNUT1Asaj0hMCxsPXRoaXMuc3RhcnRUaW1lPj0wJiZ0aGlzLnZpcnR1YWxDbGlwRHVyYXRpb24+MCxlLnN1cHBvcnRzTG9jYWxTdG9yYWdlKCkmJnRoaXMuc2V0Vm9sdW1lKHBhcnNlRmxvYXQoYi5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShnKXx8XCIxXCIpKSxhLnZnQ29uZmlnP2MubG9hZENvbmZpZyhhLnZnQ29uZmlnKS50aGVuKHRoaXMub25Mb2FkQ29uZmlnLmJpbmQodGhpcykpOmEudmdQbGF5ZXJSZWFkeSh7JEFQSTp0aGlzfSl9LHRoaXMub25Mb2FkQ29uZmlnPWZ1bmN0aW9uKGIpe3RoaXMuY29uZmlnPWIsYS52Z1RoZW1lPXRoaXMuY29uZmlnLnRoZW1lLGEudmdBdXRvUGxheT10aGlzLmNvbmZpZy5hdXRvUGxheSxhLnZnUGxheXNJbmxpbmU9dGhpcy5jb25maWcucGxheXNJbmxpbmUsYS52Z05hdGl2ZUZ1bGxzY3JlZW49dGhpcy5jb25maWcubmF0aXZlRnVsbHNjcmVlbixhLnZnQ3VlUG9pbnRzPXRoaXMuY29uZmlnLmN1ZVBvaW50cyxhLnZnQ2xlYXJNZWRpYU9uTmF2aWdhdGU9dGhpcy5jb25maWcuY2xlYXJNZWRpYU9uTmF2aWdhdGUsYS52Z1N0YXJ0VGltZT10aGlzLmNvbmZpZy5zdGFydFRpbWUsYS52Z1ZpcnR1YWxDbGlwRHVyYXRpb249dGhpcy5jb25maWcudmlydHVhbENsaXBEdXJhdGlvbixsPWEudmdTdGFydFRpbWU+PTAmJmEudmdWaXJ0dWFsQ2xpcER1cmF0aW9uPjAsYS52Z1BsYXllclJlYWR5KHskQVBJOnRoaXN9KX0sdGhpcy5vbkxvYWRNZXRhRGF0YT1mdW5jdGlvbihhKXt0aGlzLmlzQnVmZmVyaW5nPSExLHRoaXMub25VcGRhdGVUaW1lKGEpfSx0aGlzLm9uUHJvZ3Jlc3M9ZnVuY3Rpb24oYil7dGhpcy51cGRhdGVCdWZmZXIoYiksYS4kcGFyZW50LiRkaWdlc3QoKX0sdGhpcy51cGRhdGVCdWZmZXI9ZnVuY3Rpb24oYSl7YS50YXJnZXQuYnVmZmVyZWQubGVuZ3RoJiYodGhpcy5idWZmZXJlZD1hLnRhcmdldC5idWZmZXJlZCx0aGlzLmJ1ZmZlckVuZD0xZTMqYS50YXJnZXQuYnVmZmVyZWQuZW5kKGEudGFyZ2V0LmJ1ZmZlcmVkLmxlbmd0aC0xKSx0aGlzLmJ1ZmZlckVuZD50aGlzLnRvdGFsVGltZSYmKHRoaXMuYnVmZmVyRW5kPXRoaXMudG90YWxUaW1lKSl9LHRoaXMub25VcGRhdGVUaW1lPWZ1bmN0aW9uKGIpe3ZhciBjPTFlMypiLnRhcmdldC5jdXJyZW50VGltZTt0aGlzLnVwZGF0ZUJ1ZmZlcihiKSxiLnRhcmdldC5kdXJhdGlvbiE9MS8wJiZudWxsIT1iLnRhcmdldC5kdXJhdGlvbiYmdm9pZCAwIT1iLnRhcmdldC5kdXJhdGlvbiYmMS43OTc2OTMxMzQ4NjIzMTU3ZTMwOCE9Yi50YXJnZXQuZHVyYXRpb24/KGw/ayYmKGIudGFyZ2V0LmN1cnJlbnRUaW1lPHRoaXMuc3RhcnRUaW1lfHxiLnRhcmdldC5jdXJyZW50VGltZS10aGlzLnN0YXJ0VGltZT50aGlzLnZpcnR1YWxDbGlwRHVyYXRpb24pP3RoaXMub25Db21wbGV0ZSgpOih0aGlzLmN1cnJlbnRUaW1lPU1hdGgubWF4KDAsYy0xZTMqdGhpcy5zdGFydFRpbWUpLHRoaXMudG90YWxUaW1lPTFlMyp0aGlzLnZpcnR1YWxDbGlwRHVyYXRpb24sdGhpcy50aW1lTGVmdD0xZTMqdGhpcy52aXJ0dWFsQ2xpcER1cmF0aW9uLXRoaXMuY3VycmVudFRpbWUpOih0aGlzLmN1cnJlbnRUaW1lPWMsdGhpcy50b3RhbFRpbWU9MWUzKmIudGFyZ2V0LmR1cmF0aW9uLHRoaXMudGltZUxlZnQ9MWUzKihiLnRhcmdldC5kdXJhdGlvbi1iLnRhcmdldC5jdXJyZW50VGltZSkpLHRoaXMuaXNMaXZlPSExKToodGhpcy5jdXJyZW50VGltZT1jLHRoaXMuaXNMaXZlPSEwKTt2YXIgZD1sP3RoaXMuY3VycmVudFRpbWUvMWUzOmIudGFyZ2V0LmN1cnJlbnRUaW1lLGU9bD90aGlzLnRvdGFsVGltZS8xZTM6Yi50YXJnZXQuZHVyYXRpb247dGhpcy5jdWVQb2ludHMmJnRoaXMuY2hlY2tDdWVQb2ludHMoZCksYS52Z1VwZGF0ZVRpbWUoeyRjdXJyZW50VGltZTpkLCRkdXJhdGlvbjplfSksXCIkYXBwbHlcIiE9YS4kJHBoYXNlJiZcIiRkaWdlc3RcIiE9YS4kJHBoYXNlJiZhLiRwYXJlbnQuJGRpZ2VzdCgpfSx0aGlzLmNoZWNrQ3VlUG9pbnRzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYiBpbiB0aGlzLmN1ZVBvaW50cylmb3IodmFyIGM9MCxkPXRoaXMuY3VlUG9pbnRzW2JdLmxlbmd0aDtkPmM7YysrKXt2YXIgZT10aGlzLmN1ZVBvaW50c1tiXVtjXSxmPXBhcnNlSW50KGEsMTApLGc9cGFyc2VJbnQoZS50aW1lTGFwc2Uuc3RhcnQsMTApO2UudGltZUxhcHNlLmVuZHx8KGUudGltZUxhcHNlLmVuZD1lLnRpbWVMYXBzZS5zdGFydCsxKSxhPGUudGltZUxhcHNlLmVuZCYmKGUuJCRpc0NvbXBsZXRlZD0hMSksZS4kJGlzRGlydHl8fGYhPT1nfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlLm9uRW50ZXJ8fChlLm9uRW50ZXIoYSxlLnRpbWVMYXBzZSxlLnBhcmFtcyksZS4kJGlzRGlydHk9ITApLGE+ZS50aW1lTGFwc2Uuc3RhcnQ/KGE8ZS50aW1lTGFwc2UuZW5kJiYoZS5vblVwZGF0ZSYmZS5vblVwZGF0ZShhLGUudGltZUxhcHNlLGUucGFyYW1zKSxlLiQkaXNEaXJ0eXx8XCJmdW5jdGlvblwiIT10eXBlb2YgZS5vbkVudGVyfHxlLm9uRW50ZXIoYSxlLnRpbWVMYXBzZSxlLnBhcmFtcykpLGE+PWUudGltZUxhcHNlLmVuZCYmZS5vbkNvbXBsZXRlJiYhZS4kJGlzQ29tcGxldGVkJiYoZS4kJGlzQ29tcGxldGVkPSEwLGUub25Db21wbGV0ZShhLGUudGltZUxhcHNlLGUucGFyYW1zKSksZS4kJGlzRGlydHk9ITApOihlLm9uTGVhdmUmJmUuJCRpc0RpcnR5JiZlLm9uTGVhdmUoYSxlLnRpbWVMYXBzZSxlLnBhcmFtcyksZS4kJGlzRGlydHk9ITEpfX0sdGhpcy5vblBsYXk9ZnVuY3Rpb24oKXt0aGlzLnNldFN0YXRlKGYuUExBWSksYS4kcGFyZW50LiRkaWdlc3QoKX0sdGhpcy5vblBhdXNlPWZ1bmN0aW9uKCl7dmFyIGI9bD90aGlzLmN1cnJlbnRUaW1lOnRoaXMubWVkaWFFbGVtZW50WzBdLmN1cnJlbnRUaW1lOzA9PWI/dGhpcy5zZXRTdGF0ZShmLlNUT1ApOnRoaXMuc2V0U3RhdGUoZi5QQVVTRSksYS4kcGFyZW50LiRkaWdlc3QoKX0sdGhpcy5vblZvbHVtZUNoYW5nZT1mdW5jdGlvbigpe3RoaXMudm9sdW1lPXRoaXMubWVkaWFFbGVtZW50WzBdLnZvbHVtZSxhLiRwYXJlbnQuJGRpZ2VzdCgpfSx0aGlzLm9uUGxheWJhY2tDaGFuZ2U9ZnVuY3Rpb24oKXt0aGlzLnBsYXliYWNrPXRoaXMubWVkaWFFbGVtZW50WzBdLnBsYXliYWNrUmF0ZSxhLiRwYXJlbnQuJGRpZ2VzdCgpfSx0aGlzLm9uU2Vla2luZz1mdW5jdGlvbihiKXthLnZnU2Vla2luZyh7JGN1cnJlbnRUaW1lOmIudGFyZ2V0LmN1cnJlbnRUaW1lLCRkdXJhdGlvbjpiLnRhcmdldC5kdXJhdGlvbn0pfSx0aGlzLm9uU2Vla2VkPWZ1bmN0aW9uKGIpe2EudmdTZWVrZWQoeyRjdXJyZW50VGltZTpiLnRhcmdldC5jdXJyZW50VGltZSwkZHVyYXRpb246Yi50YXJnZXQuZHVyYXRpb259KX0sdGhpcy5zZWVrVGltZT1mdW5jdGlvbihhLGIpe3ZhciBjO2lmKGIpbD8oYT1NYXRoLm1heCgwLE1hdGgubWluKGEsMTAwKSksYz1hKnRoaXMudmlydHVhbENsaXBEdXJhdGlvbi8xMDAsdGhpcy5tZWRpYUVsZW1lbnRbMF0uY3VycmVudFRpbWU9dGhpcy5zdGFydFRpbWUrYyk6KGM9YSp0aGlzLm1lZGlhRWxlbWVudFswXS5kdXJhdGlvbi8xMDAsdGhpcy5tZWRpYUVsZW1lbnRbMF0uY3VycmVudFRpbWU9Yyk7ZWxzZSBpZihsKXt2YXIgZD1hL3RoaXMubWVkaWFFbGVtZW50WzBdLmR1cmF0aW9uO2M9az90aGlzLnZpcnR1YWxDbGlwRHVyYXRpb24qZDowLHRoaXMubWVkaWFFbGVtZW50WzBdLmN1cnJlbnRUaW1lPWs/dGhpcy5zdGFydFRpbWUrYzp0aGlzLnN0YXJ0VGltZX1lbHNlIGM9YSx0aGlzLm1lZGlhRWxlbWVudFswXS5jdXJyZW50VGltZT1jO3RoaXMuY3VycmVudFRpbWU9MWUzKmN9LHRoaXMucGxheVBhdXNlPWZ1bmN0aW9uKCl7dGhpcy5tZWRpYUVsZW1lbnRbMF0ucGF1c2VkP3RoaXMucGxheSgpOnRoaXMucGF1c2UoKX0sdGhpcy5zZXRTdGF0ZT1mdW5jdGlvbihiKXtyZXR1cm4gYiYmYiE9dGhpcy5jdXJyZW50U3RhdGUmJihhLnZnVXBkYXRlU3RhdGUoeyRzdGF0ZTpifSksdGhpcy5jdXJyZW50U3RhdGU9YiksdGhpcy5jdXJyZW50U3RhdGV9LHRoaXMucGxheT1mdW5jdGlvbigpe3RoaXMubWVkaWFFbGVtZW50WzBdLnBsYXkoKSx0aGlzLnNldFN0YXRlKGYuUExBWSl9LHRoaXMucGF1c2U9ZnVuY3Rpb24oKXt0aGlzLm1lZGlhRWxlbWVudFswXS5wYXVzZSgpLHRoaXMuc2V0U3RhdGUoZi5QQVVTRSl9LHRoaXMuc3RvcD1mdW5jdGlvbigpe3RyeXt0aGlzLm1lZGlhRWxlbWVudFswXS5wYXVzZSgpO3ZhciBhPWw/dGhpcy5zdGFydFRpbWU6MDt0aGlzLm1lZGlhRWxlbWVudFswXS5jdXJyZW50VGltZT1hLHRoaXMuY3VycmVudFRpbWU9YSx0aGlzLmJ1ZmZlcmVkPVtdLHRoaXMuYnVmZmVyRW5kPTAsdGhpcy5zZXRTdGF0ZShmLlNUT1ApfWNhdGNoKGIpe3JldHVybiBifX0sdGhpcy50b2dnbGVGdWxsU2NyZWVuPWZ1bmN0aW9uKCl7ZC5pc0F2YWlsYWJsZSYmdGhpcy5uYXRpdmVGdWxsc2NyZWVuP3RoaXMuaXNGdWxsU2NyZWVuP2UuaXNNb2JpbGVEZXZpY2UoKXx8ZC5leGl0KCk6ZS5pc01vYmlsZURldmljZSgpP2UuaXNpT1NEZXZpY2UoKT9qP3RoaXMuZW50ZXJFbGVtZW50SW5GdWxsU2NyZWVuKHRoaXMubWVkaWFFbGVtZW50WzBdKTooaT0hMCx0aGlzLnBsYXkoKSk6dGhpcy5lbnRlckVsZW1lbnRJbkZ1bGxTY3JlZW4odGhpcy5tZWRpYUVsZW1lbnRbMF0pOnRoaXMuZW50ZXJFbGVtZW50SW5GdWxsU2NyZWVuKHRoaXMudmlkZW9ndWxhckVsZW1lbnRbMF0pOih0aGlzLmlzRnVsbFNjcmVlbj8odGhpcy52aWRlb2d1bGFyRWxlbWVudC5yZW1vdmVDbGFzcyhcImZ1bGxzY3JlZW5cIiksdGhpcy52aWRlb2d1bGFyRWxlbWVudC5jc3MoXCJ6LWluZGV4XCIsXCJhdXRvXCIpKToodGhpcy52aWRlb2d1bGFyRWxlbWVudC5hZGRDbGFzcyhcImZ1bGxzY3JlZW5cIiksdGhpcy52aWRlb2d1bGFyRWxlbWVudC5jc3MoXCJ6LWluZGV4XCIsZS5nZXRaSW5kZXgoKSkpLHRoaXMuaXNGdWxsU2NyZWVuPSF0aGlzLmlzRnVsbFNjcmVlbil9LHRoaXMuZW50ZXJFbGVtZW50SW5GdWxsU2NyZWVuPWZ1bmN0aW9uKGEpe2QucmVxdWVzdChhKX0sdGhpcy5jaGFuZ2VTb3VyY2U9ZnVuY3Rpb24oYil7YS52Z0NoYW5nZVNvdXJjZSh7JHNvdXJjZTpifSl9LHRoaXMuc2V0Vm9sdW1lPWZ1bmN0aW9uKGMpe2M9TWF0aC5tYXgoTWF0aC5taW4oYywxKSwwKSxhLnZnVXBkYXRlVm9sdW1lKHskdm9sdW1lOmN9KSx0aGlzLm1lZGlhRWxlbWVudFswXS52b2x1bWU9Yyx0aGlzLnZvbHVtZT1jLGUuc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSYmYi5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShnLGMudG9TdHJpbmcoKSl9LHRoaXMuc2V0UGxheWJhY2s9ZnVuY3Rpb24oYil7YS52Z1VwZGF0ZVBsYXliYWNrKHskcGxheUJhY2s6Yn0pLHRoaXMubWVkaWFFbGVtZW50WzBdLnBsYXliYWNrUmF0ZT1iLHRoaXMucGxheWJhY2s9Yn0sdGhpcy51cGRhdGVUaGVtZT1mdW5jdGlvbihhKXt2YXIgYixjLGQ9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpO2lmKGgpZm9yKGI9MCxjPWQubGVuZ3RoO2M+YjtiKyspaWYoZFtiXS5vdXRlckhUTUwuaW5kZXhPZihoKT49MCl7ZFtiXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRbYl0pO2JyZWFrfWlmKGEpe3ZhciBlPWFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZChcImhlYWRcIiksZj0hMTtmb3IoYj0wLGM9ZC5sZW5ndGg7Yz5iJiYhKGY9ZFtiXS5vdXRlckhUTUwuaW5kZXhPZihhKT49MCk7YisrKTtmfHxlLmFwcGVuZChcIjxsaW5rIHJlbD0nc3R5bGVzaGVldCcgaHJlZj0nXCIrYStcIic+XCIpLGg9YX19LHRoaXMub25TdGFydEJ1ZmZlcmluZz1mdW5jdGlvbihiKXt0aGlzLmlzQnVmZmVyaW5nPSEwLGEuJHBhcmVudC4kZGlnZXN0KCl9LHRoaXMub25TdGFydFBsYXlpbmc9ZnVuY3Rpb24oYil7dGhpcy5pc0J1ZmZlcmluZz0hMSxhLiRwYXJlbnQuJGRpZ2VzdCgpfSx0aGlzLm9uQ29tcGxldGU9ZnVuY3Rpb24oYil7YS52Z0NvbXBsZXRlKCksdGhpcy5zZXRTdGF0ZShmLlNUT1ApLHRoaXMuaXNDb21wbGV0ZWQ9ITAsbCYmdGhpcy5zdG9wKCksYS4kcGFyZW50LiRkaWdlc3QoKX0sdGhpcy5vblZpZGVvRXJyb3I9ZnVuY3Rpb24oYil7YS52Z0Vycm9yKHskZXZlbnQ6Yn0pfSx0aGlzLmFkZExpc3RlbmVycz1mdW5jdGlvbigpe3RoaXMubWVkaWFFbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsdGhpcy5vbkNhblBsYXkuYmluZCh0aGlzKSwhMSksdGhpcy5tZWRpYUVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsdGhpcy5vbkxvYWRNZXRhRGF0YS5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKFwid2FpdGluZ1wiLHRoaXMub25TdGFydEJ1ZmZlcmluZy5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIix0aGlzLm9uQ29tcGxldGUuYmluZCh0aGlzKSwhMSksdGhpcy5tZWRpYUVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIix0aGlzLm9uU3RhcnRQbGF5aW5nLmJpbmQodGhpcyksITEpLHRoaXMubWVkaWFFbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5XCIsdGhpcy5vblBsYXkuYmluZCh0aGlzKSwhMSksdGhpcy5tZWRpYUVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsdGhpcy5vblBhdXNlLmJpbmQodGhpcyksITEpLHRoaXMubWVkaWFFbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJ2b2x1bWVjaGFuZ2VcIix0aGlzLm9uVm9sdW1lQ2hhbmdlLmJpbmQodGhpcyksITEpLHRoaXMubWVkaWFFbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5YmFja2NoYW5nZVwiLHRoaXMub25QbGF5YmFja0NoYW5nZS5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLHRoaXMub25VcGRhdGVUaW1lLmJpbmQodGhpcyksITEpLHRoaXMubWVkaWFFbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLHRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMpLCExKSx0aGlzLm1lZGlhRWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKFwic2Vla2luZ1wiLHRoaXMub25TZWVraW5nLmJpbmQodGhpcyksITEpLHRoaXMubWVkaWFFbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIix0aGlzLm9uU2Vla2VkLmJpbmQodGhpcyksITEpLHRoaXMubWVkaWFFbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLHRoaXMub25WaWRlb0Vycm9yLmJpbmQodGhpcyksITEpfSx0aGlzLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmlzUmVhZHk9ITEsdGhpcy5pc0NvbXBsZXRlZD0hMSx0aGlzLmJ1ZmZlcmVkPVtdLHRoaXMuYnVmZmVyRW5kPTAsdGhpcy5jdXJyZW50VGltZT0wLHRoaXMudG90YWxUaW1lPTAsdGhpcy50aW1lTGVmdD0wLHRoaXMuaXNMaXZlPSExLHRoaXMuaXNGdWxsU2NyZWVuPSExLHRoaXMucGxheWJhY2s9MSx0aGlzLmlzQ29uZmlnPXZvaWQgMCE9YS52Z0NvbmZpZyx0aGlzLm1lZGlhRWxlbWVudD1be3BsYXk6ZnVuY3Rpb24oKXt9LHBhdXNlOmZ1bmN0aW9uKCl7fSxzdG9wOmZ1bmN0aW9uKCl7fSxhZGRFdmVudExpc3RlbmVyOmZ1bmN0aW9uKCl7fSxyZW1vdmVFdmVudExpc3RlbmVyOmZ1bmN0aW9uKCl7fX1dLGQuaXNBdmFpbGFibGUmJih0aGlzLmlzRnVsbFNjcmVlbj1kLmlzRnVsbFNjcmVlbigpKSx0aGlzLnVwZGF0ZVRoZW1lKGEudmdUaGVtZSksdGhpcy5hZGRCaW5kaW5ncygpLGQuaXNBdmFpbGFibGUmJmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZC5vbmNoYW5nZSx0aGlzLm9uRnVsbFNjcmVlbkNoYW5nZS5iaW5kKHRoaXMpKX0sdGhpcy5vblVwZGF0ZVRoZW1lPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlVGhlbWUoYSl9LHRoaXMub25VcGRhdGVBdXRvUGxheT1mdW5jdGlvbihhKXthJiYhdGhpcy5hdXRvUGxheSYmKHRoaXMuYXV0b1BsYXk9YSx0aGlzLnBsYXkodGhpcykpfSx0aGlzLm9uVXBkYXRlU3RhcnRUaW1lPWZ1bmN0aW9uKGEpe2lmKGEmJmEhPXRoaXMuc3RhcnRUaW1lKXt0aGlzLm1lZGlhRWxlbWVudFswXS5jdXJyZW50VGltZT1hLHRoaXMuc3RhcnRUaW1lPWEsbD10aGlzLnN0YXJ0VGltZT49MCYmdGhpcy52aXJ0dWFsQ2xpcER1cmF0aW9uPjA7dmFyIGI9e3RhcmdldDp0aGlzLm1lZGlhRWxlbWVudFswXX07dGhpcy5vblVwZGF0ZVRpbWUoYiwhMCl9fSx0aGlzLm9uVXBkYXRlVmlydHVhbENsaXBEdXJhdGlvbj1mdW5jdGlvbihhKXtpZihhJiZhIT10aGlzLnZpcnR1YWxDbGlwRHVyYXRpb24pe3RoaXMudmlydHVhbENsaXBEdXJhdGlvbj1hLGw9dGhpcy5zdGFydFRpbWU+PTAmJnRoaXMudmlydHVhbENsaXBEdXJhdGlvbj4wO3ZhciBiPXt0YXJnZXQ6dGhpcy5tZWRpYUVsZW1lbnRbMF19O3RoaXMub25VcGRhdGVUaW1lKGIsITApfX0sdGhpcy5vblVwZGF0ZVBsYXlzSW5saW5lPWZ1bmN0aW9uKGEpe3RoaXMucGxheXNJbmxpbmU9YX0sdGhpcy5vblVwZGF0ZU5hdGl2ZUZ1bGxzY3JlZW49ZnVuY3Rpb24oYSl7dm9pZCAwPT1hJiYoYT0hMCksdGhpcy5uYXRpdmVGdWxsc2NyZWVuPWF9LHRoaXMub25VcGRhdGVDdWVQb2ludHM9ZnVuY3Rpb24oYSl7dGhpcy5jdWVQb2ludHM9YSx0aGlzLmNoZWNrQ3VlUG9pbnRzKHRoaXMuY3VycmVudFRpbWUpfSx0aGlzLm9uVXBkYXRlQ2xlYXJNZWRpYU9uTmF2aWdhdGU9ZnVuY3Rpb24oYSl7dGhpcy5jbGVhck1lZGlhT25OYXZpZ2F0ZT1hfSx0aGlzLmFkZEJpbmRpbmdzPWZ1bmN0aW9uKCl7YS4kd2F0Y2goXCJ2Z1RoZW1lXCIsdGhpcy5vblVwZGF0ZVRoZW1lLmJpbmQodGhpcykpLGEuJHdhdGNoKFwidmdBdXRvUGxheVwiLHRoaXMub25VcGRhdGVBdXRvUGxheS5iaW5kKHRoaXMpKSxhLiR3YXRjaChcInZnU3RhcnRUaW1lXCIsdGhpcy5vblVwZGF0ZVN0YXJ0VGltZS5iaW5kKHRoaXMpKSxhLiR3YXRjaChcInZnVmlydHVhbENsaXBEdXJhdGlvblwiLHRoaXMub25VcGRhdGVWaXJ0dWFsQ2xpcER1cmF0aW9uLmJpbmQodGhpcykpLGEuJHdhdGNoKFwidmdQbGF5c0lubGluZVwiLHRoaXMub25VcGRhdGVQbGF5c0lubGluZS5iaW5kKHRoaXMpKSxhLiR3YXRjaChcInZnTmF0aXZlRnVsbHNjcmVlblwiLHRoaXMub25VcGRhdGVOYXRpdmVGdWxsc2NyZWVuLmJpbmQodGhpcykpLGEuJHdhdGNoKFwidmdDdWVQb2ludHNcIix0aGlzLm9uVXBkYXRlQ3VlUG9pbnRzLmJpbmQodGhpcykpLGEuJHdhdGNoKFwidmdDbGVhck1lZGlhT25OYXZpZ2F0ZVwiLHRoaXMub25VcGRhdGVDbGVhck1lZGlhT25OYXZpZ2F0ZS5iaW5kKHRoaXMpKX0sdGhpcy5vbkZ1bGxTY3JlZW5DaGFuZ2U9ZnVuY3Rpb24oYil7dGhpcy5pc0Z1bGxTY3JlZW49ZC5pc0Z1bGxTY3JlZW4oKSxhLiRwYXJlbnQuJGRpZ2VzdCgpfSxhLiRvbihcIiRkZXN0cm95XCIsdGhpcy5jbGVhck1lZGlhLmJpbmQodGhpcykpLGEuJG9uKFwiJHJvdXRlQ2hhbmdlU3RhcnRcIix0aGlzLm9uUm91dGVDaGFuZ2UuYmluZCh0aGlzKSksdGhpcy5pbml0KCl9XSksYW5ndWxhci5tb2R1bGUoXCJjb20uMmZkZXZzLnZpZGVvZ3VsYXJcIikuZGlyZWN0aXZlKFwidmdDcm9zc29yaWdpblwiLFtmdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcIkFcIixyZXF1aXJlOlwiXnZpZGVvZ3VsYXJcIixsaW5rOntwcmU6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7YS5zZXRDcm9zc29yaWdpbj1mdW5jdGlvbihhKXthP2QubWVkaWFFbGVtZW50LmF0dHIoXCJjcm9zc29yaWdpblwiLGEpOmQubWVkaWFFbGVtZW50LnJlbW92ZUF0dHIoXCJjcm9zc29yaWdpblwiKX0sZC5pc0NvbmZpZz9hLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBkLmNvbmZpZ30sZnVuY3Rpb24oKXtkLmNvbmZpZyYmYS5zZXRDcm9zc29yaWdpbihkLmNvbmZpZy5jcm9zc29yaWdpbil9KTphLiR3YXRjaChjLnZnQ3Jvc3NvcmlnaW4sZnVuY3Rpb24oYixjKXtlJiZiPT1jfHwhYj9hLnNldENyb3Nzb3JpZ2luKCk6KGU9YixhLnNldENyb3Nzb3JpZ2luKGUpKX0pfX19fV0pLGFuZ3VsYXIubW9kdWxlKFwiY29tLjJmZGV2cy52aWRlb2d1bGFyXCIpLmRpcmVjdGl2ZShcInZnTG9vcFwiLFtmdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcIkFcIixyZXF1aXJlOlwiXnZpZGVvZ3VsYXJcIixsaW5rOntwcmU6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7YS5zZXRMb29wPWZ1bmN0aW9uKGEpe2E/ZC5tZWRpYUVsZW1lbnQuYXR0cihcImxvb3BcIixhKTpkLm1lZGlhRWxlbWVudC5yZW1vdmVBdHRyKFwibG9vcFwiKX0sZC5pc0NvbmZpZz9hLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBkLmNvbmZpZ30sZnVuY3Rpb24oKXtkLmNvbmZpZyYmYS5zZXRMb29wKGQuY29uZmlnLmxvb3ApfSk6YS4kd2F0Y2goYy52Z0xvb3AsZnVuY3Rpb24oYixjKXtlJiZiPT1jfHwhYj9hLnNldExvb3AoKTooZT1iLGEuc2V0TG9vcChlKSl9KX19fX1dKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhclwiKS5kaXJlY3RpdmUoXCJ2Z01lZGlhXCIsW1wiJHRpbWVvdXRcIixcIlZHX1VUSUxTXCIsXCJWR19TVEFURVNcIixmdW5jdGlvbihhLGIsYyl7cmV0dXJue3Jlc3RyaWN0OlwiRVwiLHJlcXVpcmU6XCJedmlkZW9ndWxhclwiLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7dmFyIGM9Yi52Z1R5cGV8fFwidmlkZW9cIjtyZXR1cm4gYi52Z1RlbXBsYXRlfHxcInZnLXRlbXBsYXRlcy92Zy1tZWRpYS1cIitjfSxzY29wZTp7dmdTcmM6XCI9P1wiLHZnVHlwZTpcIj0/XCJ9LGxpbms6ZnVuY3Rpb24oZCxlLGYsZyl7dmFyIGg7Zi52Z1R5cGUmJlwidmlkZW9cIiE9PWYudmdUeXBlP2YudmdUeXBlPVwiYXVkaW9cIjpmLnZnVHlwZT1cInZpZGVvXCIsZC5vbkNoYW5nZVNvdXJjZT1mdW5jdGlvbihhLGIpe2gmJmE9PWJ8fCFhfHwoaD1hLGcuY3VycmVudFN0YXRlIT09Yy5QTEFZJiYoZy5jdXJyZW50U3RhdGU9Yy5TVE9QKSxnLnNvdXJjZXM9aCxkLmNoYW5nZVNvdXJjZSgpKX0sZC5jaGFuZ2VTb3VyY2U9ZnVuY3Rpb24oKXtpZihhbmd1bGFyLmlzQXJyYXkoaCkpe3ZhciBjPVwiXCI7aWYoZy5tZWRpYUVsZW1lbnRbMF0uY2FuUGxheVR5cGUpe2Zvcih2YXIgZD0wLGU9aC5sZW5ndGg7ZT5kO2QrKylpZihjPWcubWVkaWFFbGVtZW50WzBdLmNhblBsYXlUeXBlKGhbZF0udHlwZSksXCJtYXliZVwiPT1jfHxcInByb2JhYmx5XCI9PWMpe2cubWVkaWFFbGVtZW50LmF0dHIoXCJzcmNcIixoW2RdLnNyYyksZy5tZWRpYUVsZW1lbnQuYXR0cihcInR5cGVcIixoW2RdLnR5cGUpLGcuY2hhbmdlU291cmNlKGhbZF0pO2JyZWFrfX1lbHNlIGcubWVkaWFFbGVtZW50LmF0dHIoXCJzcmNcIixoWzBdLnNyYyksZy5tZWRpYUVsZW1lbnQuYXR0cihcInR5cGVcIixoWzBdLnR5cGUpLGcuY2hhbmdlU291cmNlKGhbMF0pfWVsc2UgZy5tZWRpYUVsZW1lbnQuYXR0cihcInNyY1wiLGgpLGcuY2hhbmdlU291cmNlKGgpO2IuaXNNb2JpbGVEZXZpY2UoKSYmZy5tZWRpYUVsZW1lbnRbMF0ubG9hZCgpLGEoZnVuY3Rpb24oKXshZy5hdXRvUGxheXx8IWIuaXNDb3Jkb3ZhKCkmJmIuaXNNb2JpbGVEZXZpY2UoKXx8Zy5wbGF5KCl9KSxcIlwiPT1jJiZnLm9uVmlkZW9FcnJvcigpfSxnLm1lZGlhRWxlbWVudD1lLmZpbmQoZi52Z1R5cGUpLGcuc291cmNlcz1kLnZnU3JjLGcuYWRkTGlzdGVuZXJzKCksZy5vblZpZGVvUmVhZHkoKSxkLiR3YXRjaChcInZnU3JjXCIsZC5vbkNoYW5nZVNvdXJjZSksZC4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gZy5zb3VyY2VzfSxkLm9uQ2hhbmdlU291cmNlKSxkLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBnLnBsYXlzSW5saW5lfSxmdW5jdGlvbihhLGIpe2E/Zy5tZWRpYUVsZW1lbnQuYXR0cihcIndlYmtpdC1wbGF5c2lubGluZVwiLFwiXCIpOmcubWVkaWFFbGVtZW50LnJlbW92ZUF0dHIoXCJ3ZWJraXQtcGxheXNpbmxpbmVcIil9KSxnLmlzQ29uZmlnJiZkLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBnLmNvbmZpZ30sZnVuY3Rpb24oKXtnLmNvbmZpZyYmKGQudmdTcmM9Zy5jb25maWcuc291cmNlcyl9KX19fV0pLGFuZ3VsYXIubW9kdWxlKFwiY29tLjJmZGV2cy52aWRlb2d1bGFyXCIpLmRpcmVjdGl2ZShcInZnTmF0aXZlQ29udHJvbHNcIixbZnVuY3Rpb24oKXtyZXR1cm57cmVzdHJpY3Q6XCJBXCIscmVxdWlyZTpcIl52aWRlb2d1bGFyXCIsbGluazp7cHJlOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlO2Euc2V0Q29udHJvbHM9ZnVuY3Rpb24oYSl7YT9kLm1lZGlhRWxlbWVudC5hdHRyKFwiY29udHJvbHNcIixhKTpkLm1lZGlhRWxlbWVudC5yZW1vdmVBdHRyKFwiY29udHJvbHNcIil9LGQuaXNDb25maWc/YS4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gZC5jb25maWd9LGZ1bmN0aW9uKCl7ZC5jb25maWcmJmEuc2V0Q29udHJvbHMoZC5jb25maWcuY29udHJvbHMpfSk6YS4kd2F0Y2goYy52Z05hdGl2ZUNvbnRyb2xzLGZ1bmN0aW9uKGIsYyl7ZSYmYj09Y3x8IWI/YS5zZXRDb250cm9scygpOihlPWIsYS5zZXRDb250cm9scyhlKSl9KX19fX1dKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhclwiKS5kaXJlY3RpdmUoXCJ2Z1ByZWxvYWRcIixbZnVuY3Rpb24oKXtyZXR1cm57cmVzdHJpY3Q6XCJBXCIscmVxdWlyZTpcIl52aWRlb2d1bGFyXCIsbGluazp7cHJlOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlO2Euc2V0UHJlbG9hZD1mdW5jdGlvbihhKXthP2QubWVkaWFFbGVtZW50LmF0dHIoXCJwcmVsb2FkXCIsYSk6ZC5tZWRpYUVsZW1lbnQucmVtb3ZlQXR0cihcInByZWxvYWRcIil9LGQuaXNDb25maWc/YS4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gZC5jb25maWd9LGZ1bmN0aW9uKCl7ZC5jb25maWcmJmEuc2V0UHJlbG9hZChkLmNvbmZpZy5wcmVsb2FkKX0pOmEuJHdhdGNoKGMudmdQcmVsb2FkLGZ1bmN0aW9uKGIsYyl7ZSYmYj09Y3x8IWI/YS5zZXRQcmVsb2FkKCk6KGU9YixhLnNldFByZWxvYWQoZSkpfSl9fX19XSksYW5ndWxhci5tb2R1bGUoXCJjb20uMmZkZXZzLnZpZGVvZ3VsYXJcIikuZGlyZWN0aXZlKFwidmdUcmFja3NcIixbZnVuY3Rpb24oKXtyZXR1cm57cmVzdHJpY3Q6XCJBXCIscmVxdWlyZTpcIl52aWRlb2d1bGFyXCIsbGluazp7cHJlOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlLGYsZyxoPSExO2Eub25Mb2FkTWV0YURhdGE9ZnVuY3Rpb24oKXtoPSEwLGEudXBkYXRlVHJhY2tzKCl9LGEudXBkYXRlVHJhY2tzPWZ1bmN0aW9uKCl7dmFyIGI9ZC5tZWRpYUVsZW1lbnQuY2hpbGRyZW4oKTtmb3IoZj0wLGc9Yi5sZW5ndGg7Zz5mO2YrKyliW2ZdLnJlbW92ZSYmYltmXS5yZW1vdmUoKTtpZihlKWZvcihmPTAsZz1lLmxlbmd0aDtnPmY7ZisrKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJhY2tcIik7Zm9yKHZhciBoIGluIGVbZl0pY1toXT1lW2ZdW2hdO2MuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixhLm9uTG9hZFRyYWNrLmJpbmQoYSxjKSksZC5tZWRpYUVsZW1lbnRbMF0uYXBwZW5kQ2hpbGQoYyl9fSxhLm9uTG9hZFRyYWNrPWZ1bmN0aW9uKGIpe2JbXCJkZWZhdWx0XCJdP2IubW9kZT1cInNob3dpbmdcIjpiLm1vZGU9XCJoaWRkZW5cIjtmb3IodmFyIGM9MCxlPWQubWVkaWFFbGVtZW50WzBdLnRleHRUcmFja3MubGVuZ3RoO2U+YztjKyspYi5sYWJlbD09ZC5tZWRpYUVsZW1lbnRbMF0udGV4dFRyYWNrc1tjXS5sYWJlbCYmKGJbXCJkZWZhdWx0XCJdP2QubWVkaWFFbGVtZW50WzBdLnRleHRUcmFja3NbY10ubW9kZT1cInNob3dpbmdcIjpkLm1lZGlhRWxlbWVudFswXS50ZXh0VHJhY2tzW2NdLm1vZGU9XCJkaXNhYmxlZFwiKTtiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsYS5vbkxvYWRUcmFjay5iaW5kKGEsYikpfSxhLnNldFRyYWNrcz1mdW5jdGlvbihiKXtlPWIsZC50cmFja3M9YixoP2EudXBkYXRlVHJhY2tzKCk6ZC5tZWRpYUVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsYS5vbkxvYWRNZXRhRGF0YS5iaW5kKGEpLCExKX0sZC5pc0NvbmZpZz9hLiR3YXRjaChmdW5jdGlvbigpe3JldHVybiBkLmNvbmZpZ30sZnVuY3Rpb24oKXtkLmNvbmZpZyYmYS5zZXRUcmFja3MoZC5jb25maWcudHJhY2tzKX0pOmEuJHdhdGNoKGMudmdUcmFja3MsZnVuY3Rpb24oYixjKXtlJiZiPT1jfHxhLnNldFRyYWNrcyhiKX0sITApfX19fV0pLGFuZ3VsYXIubW9kdWxlKFwiY29tLjJmZGV2cy52aWRlb2d1bGFyXCIpLmRpcmVjdGl2ZShcInZpZGVvZ3VsYXJcIixbZnVuY3Rpb24oKXtyZXR1cm57cmVzdHJpY3Q6XCJFQVwiLHNjb3BlOnt2Z1RoZW1lOlwiPT9cIix2Z0F1dG9QbGF5OlwiPT9cIix2Z1N0YXJ0VGltZTpcIj0/XCIsdmdWaXJ0dWFsQ2xpcER1cmF0aW9uOlwiPT9cIix2Z1BsYXlzSW5saW5lOlwiPT9cIix2Z05hdGl2ZUZ1bGxzY3JlZW46XCI9P1wiLHZnQ2xlYXJNZWRpYU9uTmF2aWdhdGU6XCI9P1wiLHZnQ3VlUG9pbnRzOlwiPT9cIix2Z0NvbmZpZzpcIkBcIix2Z0NhblBsYXk6XCImXCIsdmdDb21wbGV0ZTpcIiZcIix2Z1VwZGF0ZVZvbHVtZTpcIiZcIix2Z1VwZGF0ZVBsYXliYWNrOlwiJlwiLHZnVXBkYXRlVGltZTpcIiZcIix2Z1VwZGF0ZVN0YXRlOlwiJlwiLHZnUGxheWVyUmVhZHk6XCImXCIsdmdDaGFuZ2VTb3VyY2U6XCImXCIsdmdTZWVraW5nOlwiJlwiLHZnU2Vla2VkOlwiJlwiLHZnRXJyb3I6XCImXCJ9LGNvbnRyb2xsZXI6XCJ2Z0NvbnRyb2xsZXJcIixjb250cm9sbGVyQXM6XCJBUElcIixsaW5rOntwcmU6ZnVuY3Rpb24oYSxiLGMsZCl7ZC52aWRlb2d1bGFyRWxlbWVudD1hbmd1bGFyLmVsZW1lbnQoYil9fX19XSksYW5ndWxhci5tb2R1bGUoXCJjb20uMmZkZXZzLnZpZGVvZ3VsYXJcIikuc2VydmljZShcInZnQ29uZmlnTG9hZGVyXCIsW1wiJGh0dHBcIixcIiRxXCIsXCIkc2NlXCIsZnVuY3Rpb24oYSxiLGMpe3RoaXMubG9hZENvbmZpZz1mdW5jdGlvbihkKXt2YXIgZT1iLmRlZmVyKCk7cmV0dXJuIGEoe21ldGhvZDpcIkdFVFwiLHVybDpkfSkudGhlbihmdW5jdGlvbihhKXtmb3IodmFyIGI9YS5kYXRhLGQ9MCxmPWIuc291cmNlcy5sZW5ndGg7Zj5kO2QrKyliLnNvdXJjZXNbZF0uc3JjPWMudHJ1c3RBc1Jlc291cmNlVXJsKGIuc291cmNlc1tkXS5zcmMpO2UucmVzb2x2ZShiKX0sZnVuY3Rpb24oKXtlLnJlamVjdCgpfSksZS5wcm9taXNlfX1dKSxhbmd1bGFyLm1vZHVsZShcImNvbS4yZmRldnMudmlkZW9ndWxhclwiKS5zZXJ2aWNlKFwidmdGdWxsc2NyZWVuXCIsW1wiVkdfVVRJTFNcIixmdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7dmFyIGE9ITE7cmV0dXJuIGE9Yz9udWxsIT1kb2N1bWVudFtkLmVsZW1lbnRdfHxjLndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuOm51bGwhPWRvY3VtZW50W2QuZWxlbWVudF19dmFyIGMsZD1udWxsLGU9e3czOntlbmFibGVkOlwiZnVsbHNjcmVlbkVuYWJsZWRcIixlbGVtZW50OlwiZnVsbHNjcmVlbkVsZW1lbnRcIixyZXF1ZXN0OlwicmVxdWVzdEZ1bGxzY3JlZW5cIixleGl0OlwiZXhpdEZ1bGxzY3JlZW5cIixvbmNoYW5nZTpcImZ1bGxzY3JlZW5jaGFuZ2VcIixvbmVycm9yOlwiZnVsbHNjcmVlbmVycm9yXCJ9LG5ld1dlYmtpdDp7ZW5hYmxlZDpcIndlYmtpdEZ1bGxzY3JlZW5FbmFibGVkXCIsZWxlbWVudDpcIndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50XCIscmVxdWVzdDpcIndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuXCIsZXhpdDpcIndlYmtpdEV4aXRGdWxsc2NyZWVuXCIsb25jaGFuZ2U6XCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsb25lcnJvcjpcIndlYmtpdGZ1bGxzY3JlZW5lcnJvclwifSxvbGRXZWJraXQ6e2VuYWJsZWQ6XCJ3ZWJraXRJc0Z1bGxTY3JlZW5cIixlbGVtZW50Olwid2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50XCIscmVxdWVzdDpcIndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuXCIsZXhpdDpcIndlYmtpdENhbmNlbEZ1bGxTY3JlZW5cIixvbmNoYW5nZTpcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixvbmVycm9yOlwid2Via2l0ZnVsbHNjcmVlbmVycm9yXCJ9LG1vejp7ZW5hYmxlZDpcIm1vekZ1bGxTY3JlZW5cIixlbGVtZW50OlwibW96RnVsbFNjcmVlbkVsZW1lbnRcIixyZXF1ZXN0OlwibW96UmVxdWVzdEZ1bGxTY3JlZW5cIixleGl0OlwibW96Q2FuY2VsRnVsbFNjcmVlblwiLG9uY2hhbmdlOlwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLG9uZXJyb3I6XCJtb3pmdWxsc2NyZWVuZXJyb3JcIn0saW9zOntlbmFibGVkOlwid2Via2l0RnVsbHNjcmVlbkVuYWJsZWRcIixlbGVtZW50Olwid2Via2l0RnVsbHNjcmVlbkVsZW1lbnRcIixyZXF1ZXN0Olwid2Via2l0RW50ZXJGdWxsc2NyZWVuXCIsZXhpdDpcIndlYmtpdEV4aXRGdWxsc2NyZWVuXCIsb25jaGFuZ2U6XCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsb25lcnJvcjpcIndlYmtpdGZ1bGxzY3JlZW5lcnJvclwifSxtczp7ZW5hYmxlZDpcIm1zRnVsbHNjcmVlbkVuYWJsZWRcIixlbGVtZW50OlwibXNGdWxsc2NyZWVuRWxlbWVudFwiLHJlcXVlc3Q6XCJtc1JlcXVlc3RGdWxsc2NyZWVuXCIsZXhpdDpcIm1zRXhpdEZ1bGxzY3JlZW5cIixvbmNoYW5nZTpcIk1TRnVsbHNjcmVlbkNoYW5nZVwiLG9uZXJyb3I6XCJNU0Z1bGxzY3JlZW5FcnJvclwifX07Zm9yKHZhciBmIGluIGUpaWYoZVtmXS5lbmFibGVkIGluIGRvY3VtZW50KXtkPWVbZl07YnJlYWt9YS5pc2lPU0RldmljZSgpJiYoZD1lLmlvcyksdGhpcy5pc0F2YWlsYWJsZT1udWxsIT1kLGQmJih0aGlzLm9uY2hhbmdlPWQub25jaGFuZ2UsdGhpcy5vbmVycm9yPWQub25lcnJvcix0aGlzLmlzRnVsbFNjcmVlbj1iLHRoaXMuZXhpdD1mdW5jdGlvbigpe2RvY3VtZW50W2QuZXhpdF0oKX0sdGhpcy5yZXF1ZXN0PWZ1bmN0aW9uKGEpe2M9YSxjW2QucmVxdWVzdF0oKX0pfV0pLGFuZ3VsYXIubW9kdWxlKFwiY29tLjJmZGV2cy52aWRlb2d1bGFyXCIpLnNlcnZpY2UoXCJWR19VVElMU1wiLFtcIiR3aW5kb3dcIixmdW5jdGlvbihhKXt0aGlzLmZpeEV2ZW50T2Zmc2V0PWZ1bmN0aW9uKGEpe3ZhciBiPW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8oXFxkKykvaSk7aWYoYiYmTnVtYmVyLnBhcnNlSW50KGIucG9wKCkpPDM5KXt2YXIgYz1hLmN1cnJlbnRUYXJnZXQuY3VycmVudFN0eWxlfHx3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhLnRhcmdldCxudWxsKSxkPXBhcnNlSW50KGMuYm9yZGVyTGVmdFdpZHRoLDEwKSxlPXBhcnNlSW50KGMuYm9yZGVyVG9wV2lkdGgsMTApLGY9YS5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGc9YS5jbGllbnRYLWQtZi5sZWZ0LGg9YS5jbGllbnRZLWUtZi50b3A7YS5vZmZzZXRYPWcsYS5vZmZzZXRZPWh9cmV0dXJuIGF9LHRoaXMuZ2V0WkluZGV4PWZ1bmN0aW9uKCl7Zm9yKHZhciBhLGI9MSxjPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSxkPTAsZT1jLmxlbmd0aDtlPmQ7ZCsrKWE9cGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoY1tkXSlbXCJ6LWluZGV4XCJdKSxhPmImJihiPWErMSk7cmV0dXJuIGJ9LHRoaXMuaXNNb2JpbGVEZXZpY2U9ZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93Lm9yaWVudGF0aW9ufHwtMSE9PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIklFTW9iaWxlXCIpfSx0aGlzLmlzaU9TRGV2aWNlPWZ1bmN0aW9uKCl7cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lwKGhvbmV8YWR8b2QpL2kpJiYhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKGllbW9iaWxlKVtcXC9cXHNdPyhbXFx3XFwuXSopL2kpfSx0aGlzLmlzQ29yZG92YT1mdW5jdGlvbigpe3JldHVybi0xPT09ZG9jdW1lbnQuVVJMLmluZGV4T2YoXCJodHRwOi8vXCIpJiYtMT09PWRvY3VtZW50LlVSTC5pbmRleE9mKFwiaHR0cHM6Ly9cIil9LHRoaXMuc3VwcG9ydHNMb2NhbFN0b3JhZ2U9ZnVuY3Rpb24oKXt2YXIgYj1cInZpZGVvZ3VsYXItdGVzdC1rZXlcIjt0cnl7dmFyIGM9YS5zZXNzaW9uU3RvcmFnZTtyZXR1cm4gYy5zZXRJdGVtKGIsXCIxXCIpLGMucmVtb3ZlSXRlbShiKSxcImxvY2FsU3RvcmFnZVwiaW4gYSYmbnVsbCE9PWEubG9jYWxTdG9yYWdlfWNhdGNoKGQpe3JldHVybiExfX19XSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ZpZGVvZ3VsYXIvdmlkZW9ndWxhci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(6);
__webpack_require__(11);
__webpack_require__(13);
__webpack_require__(15);
__webpack_require__(14);
__webpack_require__(12);
__webpack_require__(2);
__webpack_require__(5);
__webpack_require__(7);
__webpack_require__(10);
__webpack_require__(4);
__webpack_require__(3);
__webpack_require__(1);
__webpack_require__(0);
__webpack_require__(9);
module.exports = __webpack_require__(8);


/***/ }
/******/ ]);